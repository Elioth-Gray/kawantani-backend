
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Provinsi
 * 
 */
export type Provinsi = $Result.DefaultSelection<Prisma.$ProvinsiPayload>
/**
 * Model Kabupaten
 * 
 */
export type Kabupaten = $Result.DefaultSelection<Prisma.$KabupatenPayload>
/**
 * Model Pengguna
 * 
 */
export type Pengguna = $Result.DefaultSelection<Prisma.$PenggunaPayload>
/**
 * Model Facilitator
 * 
 */
export type Facilitator = $Result.DefaultSelection<Prisma.$FacilitatorPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Artikel
 * 
 */
export type Artikel = $Result.DefaultSelection<Prisma.$ArtikelPayload>
/**
 * Model KategoriArtikel
 * 
 */
export type KategoriArtikel = $Result.DefaultSelection<Prisma.$KategoriArtikelPayload>
/**
 * Model ArtikelDisimpan
 * 
 */
export type ArtikelDisimpan = $Result.DefaultSelection<Prisma.$ArtikelDisimpanPayload>
/**
 * Model ArtikelDisukai
 * 
 */
export type ArtikelDisukai = $Result.DefaultSelection<Prisma.$ArtikelDisukaiPayload>
/**
 * Model KomentarArtikel
 * 
 */
export type KomentarArtikel = $Result.DefaultSelection<Prisma.$KomentarArtikelPayload>
/**
 * Model Workshop
 * 
 */
export type Workshop = $Result.DefaultSelection<Prisma.$WorkshopPayload>
/**
 * Model WorkshopTerdaftar
 * 
 */
export type WorkshopTerdaftar = $Result.DefaultSelection<Prisma.$WorkshopTerdaftarPayload>
/**
 * Model kategoriTanaman
 * 
 */
export type kategoriTanaman = $Result.DefaultSelection<Prisma.$kategoriTanamanPayload>
/**
 * Model Tanaman
 * 
 */
export type Tanaman = $Result.DefaultSelection<Prisma.$TanamanPayload>
/**
 * Model InstruksiTanaman
 * 
 */
export type InstruksiTanaman = $Result.DefaultSelection<Prisma.$InstruksiTanamanPayload>
/**
 * Model HariPenanaman
 * 
 */
export type HariPenanaman = $Result.DefaultSelection<Prisma.$HariPenanamanPayload>
/**
 * Model TugasPenanaman
 * 
 */
export type TugasPenanaman = $Result.DefaultSelection<Prisma.$TugasPenanamanPayload>
/**
 * Model TanamanPengguna
 * 
 */
export type TanamanPengguna = $Result.DefaultSelection<Prisma.$TanamanPenggunaPayload>
/**
 * Model HariTanamanPengguna
 * 
 */
export type HariTanamanPengguna = $Result.DefaultSelection<Prisma.$HariTanamanPenggunaPayload>
/**
 * Model TugasPenanamanPengguna
 * 
 */
export type TugasPenanamanPengguna = $Result.DefaultSelection<Prisma.$TugasPenanamanPenggunaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StatusArtikel: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED'
};

export type StatusArtikel = (typeof StatusArtikel)[keyof typeof StatusArtikel]

}

export type StatusArtikel = $Enums.StatusArtikel

export const StatusArtikel: typeof $Enums.StatusArtikel

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Provinsis
 * const provinsis = await prisma.provinsi.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Provinsis
   * const provinsis = await prisma.provinsi.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.provinsi`: Exposes CRUD operations for the **Provinsi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provinsis
    * const provinsis = await prisma.provinsi.findMany()
    * ```
    */
  get provinsi(): Prisma.ProvinsiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kabupaten`: Exposes CRUD operations for the **Kabupaten** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kabupatens
    * const kabupatens = await prisma.kabupaten.findMany()
    * ```
    */
  get kabupaten(): Prisma.KabupatenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pengguna`: Exposes CRUD operations for the **Pengguna** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Penggunas
    * const penggunas = await prisma.pengguna.findMany()
    * ```
    */
  get pengguna(): Prisma.PenggunaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facilitator`: Exposes CRUD operations for the **Facilitator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilitators
    * const facilitators = await prisma.facilitator.findMany()
    * ```
    */
  get facilitator(): Prisma.FacilitatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artikel`: Exposes CRUD operations for the **Artikel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artikels
    * const artikels = await prisma.artikel.findMany()
    * ```
    */
  get artikel(): Prisma.ArtikelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kategoriArtikel`: Exposes CRUD operations for the **KategoriArtikel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KategoriArtikels
    * const kategoriArtikels = await prisma.kategoriArtikel.findMany()
    * ```
    */
  get kategoriArtikel(): Prisma.KategoriArtikelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artikelDisimpan`: Exposes CRUD operations for the **ArtikelDisimpan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArtikelDisimpans
    * const artikelDisimpans = await prisma.artikelDisimpan.findMany()
    * ```
    */
  get artikelDisimpan(): Prisma.ArtikelDisimpanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artikelDisukai`: Exposes CRUD operations for the **ArtikelDisukai** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArtikelDisukais
    * const artikelDisukais = await prisma.artikelDisukai.findMany()
    * ```
    */
  get artikelDisukai(): Prisma.ArtikelDisukaiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.komentarArtikel`: Exposes CRUD operations for the **KomentarArtikel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KomentarArtikels
    * const komentarArtikels = await prisma.komentarArtikel.findMany()
    * ```
    */
  get komentarArtikel(): Prisma.KomentarArtikelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshop`: Exposes CRUD operations for the **Workshop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workshops
    * const workshops = await prisma.workshop.findMany()
    * ```
    */
  get workshop(): Prisma.WorkshopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshopTerdaftar`: Exposes CRUD operations for the **WorkshopTerdaftar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkshopTerdaftars
    * const workshopTerdaftars = await prisma.workshopTerdaftar.findMany()
    * ```
    */
  get workshopTerdaftar(): Prisma.WorkshopTerdaftarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kategoriTanaman`: Exposes CRUD operations for the **kategoriTanaman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KategoriTanamen
    * const kategoriTanamen = await prisma.kategoriTanaman.findMany()
    * ```
    */
  get kategoriTanaman(): Prisma.kategoriTanamanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tanaman`: Exposes CRUD operations for the **Tanaman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tanamen
    * const tanamen = await prisma.tanaman.findMany()
    * ```
    */
  get tanaman(): Prisma.TanamanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instruksiTanaman`: Exposes CRUD operations for the **InstruksiTanaman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstruksiTanamen
    * const instruksiTanamen = await prisma.instruksiTanaman.findMany()
    * ```
    */
  get instruksiTanaman(): Prisma.InstruksiTanamanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hariPenanaman`: Exposes CRUD operations for the **HariPenanaman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HariPenanamen
    * const hariPenanamen = await prisma.hariPenanaman.findMany()
    * ```
    */
  get hariPenanaman(): Prisma.HariPenanamanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tugasPenanaman`: Exposes CRUD operations for the **TugasPenanaman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TugasPenanamen
    * const tugasPenanamen = await prisma.tugasPenanaman.findMany()
    * ```
    */
  get tugasPenanaman(): Prisma.TugasPenanamanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tanamanPengguna`: Exposes CRUD operations for the **TanamanPengguna** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TanamanPenggunas
    * const tanamanPenggunas = await prisma.tanamanPengguna.findMany()
    * ```
    */
  get tanamanPengguna(): Prisma.TanamanPenggunaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hariTanamanPengguna`: Exposes CRUD operations for the **HariTanamanPengguna** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HariTanamanPenggunas
    * const hariTanamanPenggunas = await prisma.hariTanamanPengguna.findMany()
    * ```
    */
  get hariTanamanPengguna(): Prisma.HariTanamanPenggunaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tugasPenanamanPengguna`: Exposes CRUD operations for the **TugasPenanamanPengguna** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TugasPenanamanPenggunas
    * const tugasPenanamanPenggunas = await prisma.tugasPenanamanPengguna.findMany()
    * ```
    */
  get tugasPenanamanPengguna(): Prisma.TugasPenanamanPenggunaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Provinsi: 'Provinsi',
    Kabupaten: 'Kabupaten',
    Pengguna: 'Pengguna',
    Facilitator: 'Facilitator',
    Admin: 'Admin',
    Artikel: 'Artikel',
    KategoriArtikel: 'KategoriArtikel',
    ArtikelDisimpan: 'ArtikelDisimpan',
    ArtikelDisukai: 'ArtikelDisukai',
    KomentarArtikel: 'KomentarArtikel',
    Workshop: 'Workshop',
    WorkshopTerdaftar: 'WorkshopTerdaftar',
    kategoriTanaman: 'kategoriTanaman',
    Tanaman: 'Tanaman',
    InstruksiTanaman: 'InstruksiTanaman',
    HariPenanaman: 'HariPenanaman',
    TugasPenanaman: 'TugasPenanaman',
    TanamanPengguna: 'TanamanPengguna',
    HariTanamanPengguna: 'HariTanamanPengguna',
    TugasPenanamanPengguna: 'TugasPenanamanPengguna'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "provinsi" | "kabupaten" | "pengguna" | "facilitator" | "admin" | "artikel" | "kategoriArtikel" | "artikelDisimpan" | "artikelDisukai" | "komentarArtikel" | "workshop" | "workshopTerdaftar" | "kategoriTanaman" | "tanaman" | "instruksiTanaman" | "hariPenanaman" | "tugasPenanaman" | "tanamanPengguna" | "hariTanamanPengguna" | "tugasPenanamanPengguna"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Provinsi: {
        payload: Prisma.$ProvinsiPayload<ExtArgs>
        fields: Prisma.ProvinsiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvinsiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvinsiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload>
          }
          findFirst: {
            args: Prisma.ProvinsiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvinsiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload>
          }
          findMany: {
            args: Prisma.ProvinsiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload>[]
          }
          create: {
            args: Prisma.ProvinsiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload>
          }
          createMany: {
            args: Prisma.ProvinsiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProvinsiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload>[]
          }
          delete: {
            args: Prisma.ProvinsiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload>
          }
          update: {
            args: Prisma.ProvinsiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload>
          }
          deleteMany: {
            args: Prisma.ProvinsiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvinsiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProvinsiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload>[]
          }
          upsert: {
            args: Prisma.ProvinsiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvinsiPayload>
          }
          aggregate: {
            args: Prisma.ProvinsiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvinsi>
          }
          groupBy: {
            args: Prisma.ProvinsiGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvinsiGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvinsiCountArgs<ExtArgs>
            result: $Utils.Optional<ProvinsiCountAggregateOutputType> | number
          }
        }
      }
      Kabupaten: {
        payload: Prisma.$KabupatenPayload<ExtArgs>
        fields: Prisma.KabupatenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KabupatenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KabupatenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload>
          }
          findFirst: {
            args: Prisma.KabupatenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KabupatenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload>
          }
          findMany: {
            args: Prisma.KabupatenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload>[]
          }
          create: {
            args: Prisma.KabupatenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload>
          }
          createMany: {
            args: Prisma.KabupatenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KabupatenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload>[]
          }
          delete: {
            args: Prisma.KabupatenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload>
          }
          update: {
            args: Prisma.KabupatenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload>
          }
          deleteMany: {
            args: Prisma.KabupatenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KabupatenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KabupatenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload>[]
          }
          upsert: {
            args: Prisma.KabupatenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KabupatenPayload>
          }
          aggregate: {
            args: Prisma.KabupatenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKabupaten>
          }
          groupBy: {
            args: Prisma.KabupatenGroupByArgs<ExtArgs>
            result: $Utils.Optional<KabupatenGroupByOutputType>[]
          }
          count: {
            args: Prisma.KabupatenCountArgs<ExtArgs>
            result: $Utils.Optional<KabupatenCountAggregateOutputType> | number
          }
        }
      }
      Pengguna: {
        payload: Prisma.$PenggunaPayload<ExtArgs>
        fields: Prisma.PenggunaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PenggunaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PenggunaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload>
          }
          findFirst: {
            args: Prisma.PenggunaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PenggunaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload>
          }
          findMany: {
            args: Prisma.PenggunaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload>[]
          }
          create: {
            args: Prisma.PenggunaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload>
          }
          createMany: {
            args: Prisma.PenggunaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PenggunaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload>[]
          }
          delete: {
            args: Prisma.PenggunaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload>
          }
          update: {
            args: Prisma.PenggunaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload>
          }
          deleteMany: {
            args: Prisma.PenggunaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PenggunaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PenggunaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload>[]
          }
          upsert: {
            args: Prisma.PenggunaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PenggunaPayload>
          }
          aggregate: {
            args: Prisma.PenggunaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePengguna>
          }
          groupBy: {
            args: Prisma.PenggunaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PenggunaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PenggunaCountArgs<ExtArgs>
            result: $Utils.Optional<PenggunaCountAggregateOutputType> | number
          }
        }
      }
      Facilitator: {
        payload: Prisma.$FacilitatorPayload<ExtArgs>
        fields: Prisma.FacilitatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilitatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilitatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload>
          }
          findFirst: {
            args: Prisma.FacilitatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilitatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload>
          }
          findMany: {
            args: Prisma.FacilitatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload>[]
          }
          create: {
            args: Prisma.FacilitatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload>
          }
          createMany: {
            args: Prisma.FacilitatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacilitatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload>[]
          }
          delete: {
            args: Prisma.FacilitatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload>
          }
          update: {
            args: Prisma.FacilitatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload>
          }
          deleteMany: {
            args: Prisma.FacilitatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilitatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacilitatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload>[]
          }
          upsert: {
            args: Prisma.FacilitatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilitatorPayload>
          }
          aggregate: {
            args: Prisma.FacilitatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacilitator>
          }
          groupBy: {
            args: Prisma.FacilitatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilitatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilitatorCountArgs<ExtArgs>
            result: $Utils.Optional<FacilitatorCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Artikel: {
        payload: Prisma.$ArtikelPayload<ExtArgs>
        fields: Prisma.ArtikelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtikelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtikelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload>
          }
          findFirst: {
            args: Prisma.ArtikelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtikelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload>
          }
          findMany: {
            args: Prisma.ArtikelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload>[]
          }
          create: {
            args: Prisma.ArtikelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload>
          }
          createMany: {
            args: Prisma.ArtikelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtikelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload>[]
          }
          delete: {
            args: Prisma.ArtikelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload>
          }
          update: {
            args: Prisma.ArtikelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload>
          }
          deleteMany: {
            args: Prisma.ArtikelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtikelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtikelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload>[]
          }
          upsert: {
            args: Prisma.ArtikelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelPayload>
          }
          aggregate: {
            args: Prisma.ArtikelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtikel>
          }
          groupBy: {
            args: Prisma.ArtikelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtikelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtikelCountArgs<ExtArgs>
            result: $Utils.Optional<ArtikelCountAggregateOutputType> | number
          }
        }
      }
      KategoriArtikel: {
        payload: Prisma.$KategoriArtikelPayload<ExtArgs>
        fields: Prisma.KategoriArtikelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KategoriArtikelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KategoriArtikelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload>
          }
          findFirst: {
            args: Prisma.KategoriArtikelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KategoriArtikelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload>
          }
          findMany: {
            args: Prisma.KategoriArtikelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload>[]
          }
          create: {
            args: Prisma.KategoriArtikelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload>
          }
          createMany: {
            args: Prisma.KategoriArtikelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KategoriArtikelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload>[]
          }
          delete: {
            args: Prisma.KategoriArtikelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload>
          }
          update: {
            args: Prisma.KategoriArtikelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload>
          }
          deleteMany: {
            args: Prisma.KategoriArtikelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KategoriArtikelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KategoriArtikelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload>[]
          }
          upsert: {
            args: Prisma.KategoriArtikelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KategoriArtikelPayload>
          }
          aggregate: {
            args: Prisma.KategoriArtikelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKategoriArtikel>
          }
          groupBy: {
            args: Prisma.KategoriArtikelGroupByArgs<ExtArgs>
            result: $Utils.Optional<KategoriArtikelGroupByOutputType>[]
          }
          count: {
            args: Prisma.KategoriArtikelCountArgs<ExtArgs>
            result: $Utils.Optional<KategoriArtikelCountAggregateOutputType> | number
          }
        }
      }
      ArtikelDisimpan: {
        payload: Prisma.$ArtikelDisimpanPayload<ExtArgs>
        fields: Prisma.ArtikelDisimpanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtikelDisimpanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtikelDisimpanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload>
          }
          findFirst: {
            args: Prisma.ArtikelDisimpanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtikelDisimpanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload>
          }
          findMany: {
            args: Prisma.ArtikelDisimpanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload>[]
          }
          create: {
            args: Prisma.ArtikelDisimpanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload>
          }
          createMany: {
            args: Prisma.ArtikelDisimpanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtikelDisimpanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload>[]
          }
          delete: {
            args: Prisma.ArtikelDisimpanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload>
          }
          update: {
            args: Prisma.ArtikelDisimpanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload>
          }
          deleteMany: {
            args: Prisma.ArtikelDisimpanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtikelDisimpanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtikelDisimpanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload>[]
          }
          upsert: {
            args: Prisma.ArtikelDisimpanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisimpanPayload>
          }
          aggregate: {
            args: Prisma.ArtikelDisimpanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtikelDisimpan>
          }
          groupBy: {
            args: Prisma.ArtikelDisimpanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtikelDisimpanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtikelDisimpanCountArgs<ExtArgs>
            result: $Utils.Optional<ArtikelDisimpanCountAggregateOutputType> | number
          }
        }
      }
      ArtikelDisukai: {
        payload: Prisma.$ArtikelDisukaiPayload<ExtArgs>
        fields: Prisma.ArtikelDisukaiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtikelDisukaiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtikelDisukaiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload>
          }
          findFirst: {
            args: Prisma.ArtikelDisukaiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtikelDisukaiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload>
          }
          findMany: {
            args: Prisma.ArtikelDisukaiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload>[]
          }
          create: {
            args: Prisma.ArtikelDisukaiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload>
          }
          createMany: {
            args: Prisma.ArtikelDisukaiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtikelDisukaiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload>[]
          }
          delete: {
            args: Prisma.ArtikelDisukaiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload>
          }
          update: {
            args: Prisma.ArtikelDisukaiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload>
          }
          deleteMany: {
            args: Prisma.ArtikelDisukaiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtikelDisukaiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtikelDisukaiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload>[]
          }
          upsert: {
            args: Prisma.ArtikelDisukaiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtikelDisukaiPayload>
          }
          aggregate: {
            args: Prisma.ArtikelDisukaiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtikelDisukai>
          }
          groupBy: {
            args: Prisma.ArtikelDisukaiGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtikelDisukaiGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtikelDisukaiCountArgs<ExtArgs>
            result: $Utils.Optional<ArtikelDisukaiCountAggregateOutputType> | number
          }
        }
      }
      KomentarArtikel: {
        payload: Prisma.$KomentarArtikelPayload<ExtArgs>
        fields: Prisma.KomentarArtikelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KomentarArtikelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KomentarArtikelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload>
          }
          findFirst: {
            args: Prisma.KomentarArtikelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KomentarArtikelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload>
          }
          findMany: {
            args: Prisma.KomentarArtikelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload>[]
          }
          create: {
            args: Prisma.KomentarArtikelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload>
          }
          createMany: {
            args: Prisma.KomentarArtikelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KomentarArtikelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload>[]
          }
          delete: {
            args: Prisma.KomentarArtikelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload>
          }
          update: {
            args: Prisma.KomentarArtikelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload>
          }
          deleteMany: {
            args: Prisma.KomentarArtikelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KomentarArtikelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KomentarArtikelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload>[]
          }
          upsert: {
            args: Prisma.KomentarArtikelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KomentarArtikelPayload>
          }
          aggregate: {
            args: Prisma.KomentarArtikelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKomentarArtikel>
          }
          groupBy: {
            args: Prisma.KomentarArtikelGroupByArgs<ExtArgs>
            result: $Utils.Optional<KomentarArtikelGroupByOutputType>[]
          }
          count: {
            args: Prisma.KomentarArtikelCountArgs<ExtArgs>
            result: $Utils.Optional<KomentarArtikelCountAggregateOutputType> | number
          }
        }
      }
      Workshop: {
        payload: Prisma.$WorkshopPayload<ExtArgs>
        fields: Prisma.WorkshopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          findFirst: {
            args: Prisma.WorkshopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          findMany: {
            args: Prisma.WorkshopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>[]
          }
          create: {
            args: Prisma.WorkshopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          createMany: {
            args: Prisma.WorkshopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>[]
          }
          delete: {
            args: Prisma.WorkshopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          update: {
            args: Prisma.WorkshopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          deleteMany: {
            args: Prisma.WorkshopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>[]
          }
          upsert: {
            args: Prisma.WorkshopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopPayload>
          }
          aggregate: {
            args: Prisma.WorkshopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshop>
          }
          groupBy: {
            args: Prisma.WorkshopGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopCountAggregateOutputType> | number
          }
        }
      }
      WorkshopTerdaftar: {
        payload: Prisma.$WorkshopTerdaftarPayload<ExtArgs>
        fields: Prisma.WorkshopTerdaftarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkshopTerdaftarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkshopTerdaftarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload>
          }
          findFirst: {
            args: Prisma.WorkshopTerdaftarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkshopTerdaftarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload>
          }
          findMany: {
            args: Prisma.WorkshopTerdaftarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload>[]
          }
          create: {
            args: Prisma.WorkshopTerdaftarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload>
          }
          createMany: {
            args: Prisma.WorkshopTerdaftarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkshopTerdaftarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload>[]
          }
          delete: {
            args: Prisma.WorkshopTerdaftarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload>
          }
          update: {
            args: Prisma.WorkshopTerdaftarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload>
          }
          deleteMany: {
            args: Prisma.WorkshopTerdaftarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkshopTerdaftarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkshopTerdaftarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload>[]
          }
          upsert: {
            args: Prisma.WorkshopTerdaftarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkshopTerdaftarPayload>
          }
          aggregate: {
            args: Prisma.WorkshopTerdaftarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshopTerdaftar>
          }
          groupBy: {
            args: Prisma.WorkshopTerdaftarGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopTerdaftarGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkshopTerdaftarCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopTerdaftarCountAggregateOutputType> | number
          }
        }
      }
      kategoriTanaman: {
        payload: Prisma.$kategoriTanamanPayload<ExtArgs>
        fields: Prisma.kategoriTanamanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kategoriTanamanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kategoriTanamanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload>
          }
          findFirst: {
            args: Prisma.kategoriTanamanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kategoriTanamanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload>
          }
          findMany: {
            args: Prisma.kategoriTanamanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload>[]
          }
          create: {
            args: Prisma.kategoriTanamanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload>
          }
          createMany: {
            args: Prisma.kategoriTanamanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.kategoriTanamanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload>[]
          }
          delete: {
            args: Prisma.kategoriTanamanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload>
          }
          update: {
            args: Prisma.kategoriTanamanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload>
          }
          deleteMany: {
            args: Prisma.kategoriTanamanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kategoriTanamanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.kategoriTanamanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload>[]
          }
          upsert: {
            args: Prisma.kategoriTanamanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kategoriTanamanPayload>
          }
          aggregate: {
            args: Prisma.KategoriTanamanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKategoriTanaman>
          }
          groupBy: {
            args: Prisma.kategoriTanamanGroupByArgs<ExtArgs>
            result: $Utils.Optional<KategoriTanamanGroupByOutputType>[]
          }
          count: {
            args: Prisma.kategoriTanamanCountArgs<ExtArgs>
            result: $Utils.Optional<KategoriTanamanCountAggregateOutputType> | number
          }
        }
      }
      Tanaman: {
        payload: Prisma.$TanamanPayload<ExtArgs>
        fields: Prisma.TanamanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TanamanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TanamanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload>
          }
          findFirst: {
            args: Prisma.TanamanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TanamanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload>
          }
          findMany: {
            args: Prisma.TanamanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload>[]
          }
          create: {
            args: Prisma.TanamanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload>
          }
          createMany: {
            args: Prisma.TanamanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TanamanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload>[]
          }
          delete: {
            args: Prisma.TanamanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload>
          }
          update: {
            args: Prisma.TanamanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload>
          }
          deleteMany: {
            args: Prisma.TanamanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TanamanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TanamanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload>[]
          }
          upsert: {
            args: Prisma.TanamanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPayload>
          }
          aggregate: {
            args: Prisma.TanamanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTanaman>
          }
          groupBy: {
            args: Prisma.TanamanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TanamanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TanamanCountArgs<ExtArgs>
            result: $Utils.Optional<TanamanCountAggregateOutputType> | number
          }
        }
      }
      InstruksiTanaman: {
        payload: Prisma.$InstruksiTanamanPayload<ExtArgs>
        fields: Prisma.InstruksiTanamanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstruksiTanamanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstruksiTanamanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload>
          }
          findFirst: {
            args: Prisma.InstruksiTanamanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstruksiTanamanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload>
          }
          findMany: {
            args: Prisma.InstruksiTanamanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload>[]
          }
          create: {
            args: Prisma.InstruksiTanamanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload>
          }
          createMany: {
            args: Prisma.InstruksiTanamanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstruksiTanamanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload>[]
          }
          delete: {
            args: Prisma.InstruksiTanamanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload>
          }
          update: {
            args: Prisma.InstruksiTanamanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload>
          }
          deleteMany: {
            args: Prisma.InstruksiTanamanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstruksiTanamanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstruksiTanamanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload>[]
          }
          upsert: {
            args: Prisma.InstruksiTanamanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstruksiTanamanPayload>
          }
          aggregate: {
            args: Prisma.InstruksiTanamanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstruksiTanaman>
          }
          groupBy: {
            args: Prisma.InstruksiTanamanGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstruksiTanamanGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstruksiTanamanCountArgs<ExtArgs>
            result: $Utils.Optional<InstruksiTanamanCountAggregateOutputType> | number
          }
        }
      }
      HariPenanaman: {
        payload: Prisma.$HariPenanamanPayload<ExtArgs>
        fields: Prisma.HariPenanamanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HariPenanamanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HariPenanamanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload>
          }
          findFirst: {
            args: Prisma.HariPenanamanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HariPenanamanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload>
          }
          findMany: {
            args: Prisma.HariPenanamanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload>[]
          }
          create: {
            args: Prisma.HariPenanamanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload>
          }
          createMany: {
            args: Prisma.HariPenanamanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HariPenanamanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload>[]
          }
          delete: {
            args: Prisma.HariPenanamanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload>
          }
          update: {
            args: Prisma.HariPenanamanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload>
          }
          deleteMany: {
            args: Prisma.HariPenanamanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HariPenanamanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HariPenanamanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload>[]
          }
          upsert: {
            args: Prisma.HariPenanamanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariPenanamanPayload>
          }
          aggregate: {
            args: Prisma.HariPenanamanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHariPenanaman>
          }
          groupBy: {
            args: Prisma.HariPenanamanGroupByArgs<ExtArgs>
            result: $Utils.Optional<HariPenanamanGroupByOutputType>[]
          }
          count: {
            args: Prisma.HariPenanamanCountArgs<ExtArgs>
            result: $Utils.Optional<HariPenanamanCountAggregateOutputType> | number
          }
        }
      }
      TugasPenanaman: {
        payload: Prisma.$TugasPenanamanPayload<ExtArgs>
        fields: Prisma.TugasPenanamanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TugasPenanamanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TugasPenanamanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload>
          }
          findFirst: {
            args: Prisma.TugasPenanamanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TugasPenanamanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload>
          }
          findMany: {
            args: Prisma.TugasPenanamanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload>[]
          }
          create: {
            args: Prisma.TugasPenanamanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload>
          }
          createMany: {
            args: Prisma.TugasPenanamanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TugasPenanamanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload>[]
          }
          delete: {
            args: Prisma.TugasPenanamanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload>
          }
          update: {
            args: Prisma.TugasPenanamanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload>
          }
          deleteMany: {
            args: Prisma.TugasPenanamanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TugasPenanamanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TugasPenanamanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload>[]
          }
          upsert: {
            args: Prisma.TugasPenanamanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPayload>
          }
          aggregate: {
            args: Prisma.TugasPenanamanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTugasPenanaman>
          }
          groupBy: {
            args: Prisma.TugasPenanamanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TugasPenanamanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TugasPenanamanCountArgs<ExtArgs>
            result: $Utils.Optional<TugasPenanamanCountAggregateOutputType> | number
          }
        }
      }
      TanamanPengguna: {
        payload: Prisma.$TanamanPenggunaPayload<ExtArgs>
        fields: Prisma.TanamanPenggunaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TanamanPenggunaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TanamanPenggunaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload>
          }
          findFirst: {
            args: Prisma.TanamanPenggunaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TanamanPenggunaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload>
          }
          findMany: {
            args: Prisma.TanamanPenggunaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload>[]
          }
          create: {
            args: Prisma.TanamanPenggunaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload>
          }
          createMany: {
            args: Prisma.TanamanPenggunaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TanamanPenggunaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload>[]
          }
          delete: {
            args: Prisma.TanamanPenggunaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload>
          }
          update: {
            args: Prisma.TanamanPenggunaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload>
          }
          deleteMany: {
            args: Prisma.TanamanPenggunaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TanamanPenggunaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TanamanPenggunaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload>[]
          }
          upsert: {
            args: Prisma.TanamanPenggunaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TanamanPenggunaPayload>
          }
          aggregate: {
            args: Prisma.TanamanPenggunaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTanamanPengguna>
          }
          groupBy: {
            args: Prisma.TanamanPenggunaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TanamanPenggunaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TanamanPenggunaCountArgs<ExtArgs>
            result: $Utils.Optional<TanamanPenggunaCountAggregateOutputType> | number
          }
        }
      }
      HariTanamanPengguna: {
        payload: Prisma.$HariTanamanPenggunaPayload<ExtArgs>
        fields: Prisma.HariTanamanPenggunaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HariTanamanPenggunaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HariTanamanPenggunaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload>
          }
          findFirst: {
            args: Prisma.HariTanamanPenggunaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HariTanamanPenggunaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload>
          }
          findMany: {
            args: Prisma.HariTanamanPenggunaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload>[]
          }
          create: {
            args: Prisma.HariTanamanPenggunaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload>
          }
          createMany: {
            args: Prisma.HariTanamanPenggunaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HariTanamanPenggunaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload>[]
          }
          delete: {
            args: Prisma.HariTanamanPenggunaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload>
          }
          update: {
            args: Prisma.HariTanamanPenggunaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload>
          }
          deleteMany: {
            args: Prisma.HariTanamanPenggunaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HariTanamanPenggunaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HariTanamanPenggunaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload>[]
          }
          upsert: {
            args: Prisma.HariTanamanPenggunaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HariTanamanPenggunaPayload>
          }
          aggregate: {
            args: Prisma.HariTanamanPenggunaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHariTanamanPengguna>
          }
          groupBy: {
            args: Prisma.HariTanamanPenggunaGroupByArgs<ExtArgs>
            result: $Utils.Optional<HariTanamanPenggunaGroupByOutputType>[]
          }
          count: {
            args: Prisma.HariTanamanPenggunaCountArgs<ExtArgs>
            result: $Utils.Optional<HariTanamanPenggunaCountAggregateOutputType> | number
          }
        }
      }
      TugasPenanamanPengguna: {
        payload: Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>
        fields: Prisma.TugasPenanamanPenggunaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TugasPenanamanPenggunaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TugasPenanamanPenggunaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload>
          }
          findFirst: {
            args: Prisma.TugasPenanamanPenggunaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TugasPenanamanPenggunaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload>
          }
          findMany: {
            args: Prisma.TugasPenanamanPenggunaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload>[]
          }
          create: {
            args: Prisma.TugasPenanamanPenggunaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload>
          }
          createMany: {
            args: Prisma.TugasPenanamanPenggunaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TugasPenanamanPenggunaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload>[]
          }
          delete: {
            args: Prisma.TugasPenanamanPenggunaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload>
          }
          update: {
            args: Prisma.TugasPenanamanPenggunaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload>
          }
          deleteMany: {
            args: Prisma.TugasPenanamanPenggunaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TugasPenanamanPenggunaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TugasPenanamanPenggunaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload>[]
          }
          upsert: {
            args: Prisma.TugasPenanamanPenggunaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TugasPenanamanPenggunaPayload>
          }
          aggregate: {
            args: Prisma.TugasPenanamanPenggunaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTugasPenanamanPengguna>
          }
          groupBy: {
            args: Prisma.TugasPenanamanPenggunaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TugasPenanamanPenggunaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TugasPenanamanPenggunaCountArgs<ExtArgs>
            result: $Utils.Optional<TugasPenanamanPenggunaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    provinsi?: ProvinsiOmit
    kabupaten?: KabupatenOmit
    pengguna?: PenggunaOmit
    facilitator?: FacilitatorOmit
    admin?: AdminOmit
    artikel?: ArtikelOmit
    kategoriArtikel?: KategoriArtikelOmit
    artikelDisimpan?: ArtikelDisimpanOmit
    artikelDisukai?: ArtikelDisukaiOmit
    komentarArtikel?: KomentarArtikelOmit
    workshop?: WorkshopOmit
    workshopTerdaftar?: WorkshopTerdaftarOmit
    kategoriTanaman?: kategoriTanamanOmit
    tanaman?: TanamanOmit
    instruksiTanaman?: InstruksiTanamanOmit
    hariPenanaman?: HariPenanamanOmit
    tugasPenanaman?: TugasPenanamanOmit
    tanamanPengguna?: TanamanPenggunaOmit
    hariTanamanPengguna?: HariTanamanPenggunaOmit
    tugasPenanamanPengguna?: TugasPenanamanPenggunaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProvinsiCountOutputType
   */

  export type ProvinsiCountOutputType = {
    kabupaten: number
  }

  export type ProvinsiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kabupaten?: boolean | ProvinsiCountOutputTypeCountKabupatenArgs
  }

  // Custom InputTypes
  /**
   * ProvinsiCountOutputType without action
   */
  export type ProvinsiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvinsiCountOutputType
     */
    select?: ProvinsiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvinsiCountOutputType without action
   */
  export type ProvinsiCountOutputTypeCountKabupatenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KabupatenWhereInput
  }


  /**
   * Count Type KabupatenCountOutputType
   */

  export type KabupatenCountOutputType = {
    facilitators: number
    workshop: number
  }

  export type KabupatenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilitators?: boolean | KabupatenCountOutputTypeCountFacilitatorsArgs
    workshop?: boolean | KabupatenCountOutputTypeCountWorkshopArgs
  }

  // Custom InputTypes
  /**
   * KabupatenCountOutputType without action
   */
  export type KabupatenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KabupatenCountOutputType
     */
    select?: KabupatenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KabupatenCountOutputType without action
   */
  export type KabupatenCountOutputTypeCountFacilitatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilitatorWhereInput
  }

  /**
   * KabupatenCountOutputType without action
   */
  export type KabupatenCountOutputTypeCountWorkshopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopWhereInput
  }


  /**
   * Count Type PenggunaCountOutputType
   */

  export type PenggunaCountOutputType = {
    workshop_terdaftar: number
    artikel: number
    artikel_disimpan: number
    artikel_disukai: number
    komentar_artikel: number
    tanaman_pengguna: number
  }

  export type PenggunaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop_terdaftar?: boolean | PenggunaCountOutputTypeCountWorkshop_terdaftarArgs
    artikel?: boolean | PenggunaCountOutputTypeCountArtikelArgs
    artikel_disimpan?: boolean | PenggunaCountOutputTypeCountArtikel_disimpanArgs
    artikel_disukai?: boolean | PenggunaCountOutputTypeCountArtikel_disukaiArgs
    komentar_artikel?: boolean | PenggunaCountOutputTypeCountKomentar_artikelArgs
    tanaman_pengguna?: boolean | PenggunaCountOutputTypeCountTanaman_penggunaArgs
  }

  // Custom InputTypes
  /**
   * PenggunaCountOutputType without action
   */
  export type PenggunaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PenggunaCountOutputType
     */
    select?: PenggunaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PenggunaCountOutputType without action
   */
  export type PenggunaCountOutputTypeCountWorkshop_terdaftarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopTerdaftarWhereInput
  }

  /**
   * PenggunaCountOutputType without action
   */
  export type PenggunaCountOutputTypeCountArtikelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtikelWhereInput
  }

  /**
   * PenggunaCountOutputType without action
   */
  export type PenggunaCountOutputTypeCountArtikel_disimpanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtikelDisimpanWhereInput
  }

  /**
   * PenggunaCountOutputType without action
   */
  export type PenggunaCountOutputTypeCountArtikel_disukaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtikelDisukaiWhereInput
  }

  /**
   * PenggunaCountOutputType without action
   */
  export type PenggunaCountOutputTypeCountKomentar_artikelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KomentarArtikelWhereInput
  }

  /**
   * PenggunaCountOutputType without action
   */
  export type PenggunaCountOutputTypeCountTanaman_penggunaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TanamanPenggunaWhereInput
  }


  /**
   * Count Type FacilitatorCountOutputType
   */

  export type FacilitatorCountOutputType = {
    workshops: number
  }

  export type FacilitatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshops?: boolean | FacilitatorCountOutputTypeCountWorkshopsArgs
  }

  // Custom InputTypes
  /**
   * FacilitatorCountOutputType without action
   */
  export type FacilitatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacilitatorCountOutputType
     */
    select?: FacilitatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacilitatorCountOutputType without action
   */
  export type FacilitatorCountOutputTypeCountWorkshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopWhereInput
  }


  /**
   * Count Type ArtikelCountOutputType
   */

  export type ArtikelCountOutputType = {
    artikel_disimpan: number
    artikel_disukai: number
    komentar_artikel: number
  }

  export type ArtikelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel_disimpan?: boolean | ArtikelCountOutputTypeCountArtikel_disimpanArgs
    artikel_disukai?: boolean | ArtikelCountOutputTypeCountArtikel_disukaiArgs
    komentar_artikel?: boolean | ArtikelCountOutputTypeCountKomentar_artikelArgs
  }

  // Custom InputTypes
  /**
   * ArtikelCountOutputType without action
   */
  export type ArtikelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelCountOutputType
     */
    select?: ArtikelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArtikelCountOutputType without action
   */
  export type ArtikelCountOutputTypeCountArtikel_disimpanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtikelDisimpanWhereInput
  }

  /**
   * ArtikelCountOutputType without action
   */
  export type ArtikelCountOutputTypeCountArtikel_disukaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtikelDisukaiWhereInput
  }

  /**
   * ArtikelCountOutputType without action
   */
  export type ArtikelCountOutputTypeCountKomentar_artikelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KomentarArtikelWhereInput
  }


  /**
   * Count Type KategoriArtikelCountOutputType
   */

  export type KategoriArtikelCountOutputType = {
    artikel: number
  }

  export type KategoriArtikelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | KategoriArtikelCountOutputTypeCountArtikelArgs
  }

  // Custom InputTypes
  /**
   * KategoriArtikelCountOutputType without action
   */
  export type KategoriArtikelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikelCountOutputType
     */
    select?: KategoriArtikelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KategoriArtikelCountOutputType without action
   */
  export type KategoriArtikelCountOutputTypeCountArtikelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtikelWhereInput
  }


  /**
   * Count Type WorkshopCountOutputType
   */

  export type WorkshopCountOutputType = {
    pendaftaran: number
  }

  export type WorkshopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendaftaran?: boolean | WorkshopCountOutputTypeCountPendaftaranArgs
  }

  // Custom InputTypes
  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopCountOutputType
     */
    select?: WorkshopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkshopCountOutputType without action
   */
  export type WorkshopCountOutputTypeCountPendaftaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopTerdaftarWhereInput
  }


  /**
   * Count Type KategoriTanamanCountOutputType
   */

  export type KategoriTanamanCountOutputType = {
    tanaman: number
  }

  export type KategoriTanamanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | KategoriTanamanCountOutputTypeCountTanamanArgs
  }

  // Custom InputTypes
  /**
   * KategoriTanamanCountOutputType without action
   */
  export type KategoriTanamanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriTanamanCountOutputType
     */
    select?: KategoriTanamanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KategoriTanamanCountOutputType without action
   */
  export type KategoriTanamanCountOutputTypeCountTanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TanamanWhereInput
  }


  /**
   * Count Type TanamanCountOutputType
   */

  export type TanamanCountOutputType = {
    instruksi_tanaman: number
    hari_penanaman: number
    tanaman_pengguna: number
  }

  export type TanamanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instruksi_tanaman?: boolean | TanamanCountOutputTypeCountInstruksi_tanamanArgs
    hari_penanaman?: boolean | TanamanCountOutputTypeCountHari_penanamanArgs
    tanaman_pengguna?: boolean | TanamanCountOutputTypeCountTanaman_penggunaArgs
  }

  // Custom InputTypes
  /**
   * TanamanCountOutputType without action
   */
  export type TanamanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanCountOutputType
     */
    select?: TanamanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TanamanCountOutputType without action
   */
  export type TanamanCountOutputTypeCountInstruksi_tanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstruksiTanamanWhereInput
  }

  /**
   * TanamanCountOutputType without action
   */
  export type TanamanCountOutputTypeCountHari_penanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HariPenanamanWhereInput
  }

  /**
   * TanamanCountOutputType without action
   */
  export type TanamanCountOutputTypeCountTanaman_penggunaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TanamanPenggunaWhereInput
  }


  /**
   * Count Type HariPenanamanCountOutputType
   */

  export type HariPenanamanCountOutputType = {
    tugas_penanaman: number
  }

  export type HariPenanamanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tugas_penanaman?: boolean | HariPenanamanCountOutputTypeCountTugas_penanamanArgs
  }

  // Custom InputTypes
  /**
   * HariPenanamanCountOutputType without action
   */
  export type HariPenanamanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanamanCountOutputType
     */
    select?: HariPenanamanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HariPenanamanCountOutputType without action
   */
  export type HariPenanamanCountOutputTypeCountTugas_penanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TugasPenanamanWhereInput
  }


  /**
   * Count Type TanamanPenggunaCountOutputType
   */

  export type TanamanPenggunaCountOutputType = {
    hari_tanaman: number
  }

  export type TanamanPenggunaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hari_tanaman?: boolean | TanamanPenggunaCountOutputTypeCountHari_tanamanArgs
  }

  // Custom InputTypes
  /**
   * TanamanPenggunaCountOutputType without action
   */
  export type TanamanPenggunaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPenggunaCountOutputType
     */
    select?: TanamanPenggunaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TanamanPenggunaCountOutputType without action
   */
  export type TanamanPenggunaCountOutputTypeCountHari_tanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HariTanamanPenggunaWhereInput
  }


  /**
   * Count Type HariTanamanPenggunaCountOutputType
   */

  export type HariTanamanPenggunaCountOutputType = {
    tugas_penanaman: number
  }

  export type HariTanamanPenggunaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tugas_penanaman?: boolean | HariTanamanPenggunaCountOutputTypeCountTugas_penanamanArgs
  }

  // Custom InputTypes
  /**
   * HariTanamanPenggunaCountOutputType without action
   */
  export type HariTanamanPenggunaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPenggunaCountOutputType
     */
    select?: HariTanamanPenggunaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HariTanamanPenggunaCountOutputType without action
   */
  export type HariTanamanPenggunaCountOutputTypeCountTugas_penanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TugasPenanamanPenggunaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Provinsi
   */

  export type AggregateProvinsi = {
    _count: ProvinsiCountAggregateOutputType | null
    _avg: ProvinsiAvgAggregateOutputType | null
    _sum: ProvinsiSumAggregateOutputType | null
    _min: ProvinsiMinAggregateOutputType | null
    _max: ProvinsiMaxAggregateOutputType | null
  }

  export type ProvinsiAvgAggregateOutputType = {
    id_provinsi: number | null
  }

  export type ProvinsiSumAggregateOutputType = {
    id_provinsi: number | null
  }

  export type ProvinsiMinAggregateOutputType = {
    id_provinsi: number | null
    nama_provinsi: string | null
  }

  export type ProvinsiMaxAggregateOutputType = {
    id_provinsi: number | null
    nama_provinsi: string | null
  }

  export type ProvinsiCountAggregateOutputType = {
    id_provinsi: number
    nama_provinsi: number
    _all: number
  }


  export type ProvinsiAvgAggregateInputType = {
    id_provinsi?: true
  }

  export type ProvinsiSumAggregateInputType = {
    id_provinsi?: true
  }

  export type ProvinsiMinAggregateInputType = {
    id_provinsi?: true
    nama_provinsi?: true
  }

  export type ProvinsiMaxAggregateInputType = {
    id_provinsi?: true
    nama_provinsi?: true
  }

  export type ProvinsiCountAggregateInputType = {
    id_provinsi?: true
    nama_provinsi?: true
    _all?: true
  }

  export type ProvinsiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provinsi to aggregate.
     */
    where?: ProvinsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinsis to fetch.
     */
    orderBy?: ProvinsiOrderByWithRelationInput | ProvinsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvinsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Provinsis
    **/
    _count?: true | ProvinsiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinsiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinsiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinsiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinsiMaxAggregateInputType
  }

  export type GetProvinsiAggregateType<T extends ProvinsiAggregateArgs> = {
        [P in keyof T & keyof AggregateProvinsi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvinsi[P]>
      : GetScalarType<T[P], AggregateProvinsi[P]>
  }




  export type ProvinsiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvinsiWhereInput
    orderBy?: ProvinsiOrderByWithAggregationInput | ProvinsiOrderByWithAggregationInput[]
    by: ProvinsiScalarFieldEnum[] | ProvinsiScalarFieldEnum
    having?: ProvinsiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinsiCountAggregateInputType | true
    _avg?: ProvinsiAvgAggregateInputType
    _sum?: ProvinsiSumAggregateInputType
    _min?: ProvinsiMinAggregateInputType
    _max?: ProvinsiMaxAggregateInputType
  }

  export type ProvinsiGroupByOutputType = {
    id_provinsi: number
    nama_provinsi: string
    _count: ProvinsiCountAggregateOutputType | null
    _avg: ProvinsiAvgAggregateOutputType | null
    _sum: ProvinsiSumAggregateOutputType | null
    _min: ProvinsiMinAggregateOutputType | null
    _max: ProvinsiMaxAggregateOutputType | null
  }

  type GetProvinsiGroupByPayload<T extends ProvinsiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvinsiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvinsiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvinsiGroupByOutputType[P]>
            : GetScalarType<T[P], ProvinsiGroupByOutputType[P]>
        }
      >
    >


  export type ProvinsiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_provinsi?: boolean
    nama_provinsi?: boolean
    kabupaten?: boolean | Provinsi$kabupatenArgs<ExtArgs>
    _count?: boolean | ProvinsiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provinsi"]>

  export type ProvinsiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_provinsi?: boolean
    nama_provinsi?: boolean
  }, ExtArgs["result"]["provinsi"]>

  export type ProvinsiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_provinsi?: boolean
    nama_provinsi?: boolean
  }, ExtArgs["result"]["provinsi"]>

  export type ProvinsiSelectScalar = {
    id_provinsi?: boolean
    nama_provinsi?: boolean
  }

  export type ProvinsiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_provinsi" | "nama_provinsi", ExtArgs["result"]["provinsi"]>
  export type ProvinsiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kabupaten?: boolean | Provinsi$kabupatenArgs<ExtArgs>
    _count?: boolean | ProvinsiCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProvinsiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProvinsiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProvinsiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provinsi"
    objects: {
      kabupaten: Prisma.$KabupatenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_provinsi: number
      nama_provinsi: string
    }, ExtArgs["result"]["provinsi"]>
    composites: {}
  }

  type ProvinsiGetPayload<S extends boolean | null | undefined | ProvinsiDefaultArgs> = $Result.GetResult<Prisma.$ProvinsiPayload, S>

  type ProvinsiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvinsiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvinsiCountAggregateInputType | true
    }

  export interface ProvinsiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provinsi'], meta: { name: 'Provinsi' } }
    /**
     * Find zero or one Provinsi that matches the filter.
     * @param {ProvinsiFindUniqueArgs} args - Arguments to find a Provinsi
     * @example
     * // Get one Provinsi
     * const provinsi = await prisma.provinsi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvinsiFindUniqueArgs>(args: SelectSubset<T, ProvinsiFindUniqueArgs<ExtArgs>>): Prisma__ProvinsiClient<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provinsi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvinsiFindUniqueOrThrowArgs} args - Arguments to find a Provinsi
     * @example
     * // Get one Provinsi
     * const provinsi = await prisma.provinsi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvinsiFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvinsiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvinsiClient<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provinsi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinsiFindFirstArgs} args - Arguments to find a Provinsi
     * @example
     * // Get one Provinsi
     * const provinsi = await prisma.provinsi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvinsiFindFirstArgs>(args?: SelectSubset<T, ProvinsiFindFirstArgs<ExtArgs>>): Prisma__ProvinsiClient<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provinsi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinsiFindFirstOrThrowArgs} args - Arguments to find a Provinsi
     * @example
     * // Get one Provinsi
     * const provinsi = await prisma.provinsi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvinsiFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvinsiFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvinsiClient<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provinsis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinsiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provinsis
     * const provinsis = await prisma.provinsi.findMany()
     * 
     * // Get first 10 Provinsis
     * const provinsis = await prisma.provinsi.findMany({ take: 10 })
     * 
     * // Only select the `id_provinsi`
     * const provinsiWithId_provinsiOnly = await prisma.provinsi.findMany({ select: { id_provinsi: true } })
     * 
     */
    findMany<T extends ProvinsiFindManyArgs>(args?: SelectSubset<T, ProvinsiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provinsi.
     * @param {ProvinsiCreateArgs} args - Arguments to create a Provinsi.
     * @example
     * // Create one Provinsi
     * const Provinsi = await prisma.provinsi.create({
     *   data: {
     *     // ... data to create a Provinsi
     *   }
     * })
     * 
     */
    create<T extends ProvinsiCreateArgs>(args: SelectSubset<T, ProvinsiCreateArgs<ExtArgs>>): Prisma__ProvinsiClient<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provinsis.
     * @param {ProvinsiCreateManyArgs} args - Arguments to create many Provinsis.
     * @example
     * // Create many Provinsis
     * const provinsi = await prisma.provinsi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvinsiCreateManyArgs>(args?: SelectSubset<T, ProvinsiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provinsis and returns the data saved in the database.
     * @param {ProvinsiCreateManyAndReturnArgs} args - Arguments to create many Provinsis.
     * @example
     * // Create many Provinsis
     * const provinsi = await prisma.provinsi.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provinsis and only return the `id_provinsi`
     * const provinsiWithId_provinsiOnly = await prisma.provinsi.createManyAndReturn({
     *   select: { id_provinsi: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProvinsiCreateManyAndReturnArgs>(args?: SelectSubset<T, ProvinsiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provinsi.
     * @param {ProvinsiDeleteArgs} args - Arguments to delete one Provinsi.
     * @example
     * // Delete one Provinsi
     * const Provinsi = await prisma.provinsi.delete({
     *   where: {
     *     // ... filter to delete one Provinsi
     *   }
     * })
     * 
     */
    delete<T extends ProvinsiDeleteArgs>(args: SelectSubset<T, ProvinsiDeleteArgs<ExtArgs>>): Prisma__ProvinsiClient<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provinsi.
     * @param {ProvinsiUpdateArgs} args - Arguments to update one Provinsi.
     * @example
     * // Update one Provinsi
     * const provinsi = await prisma.provinsi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvinsiUpdateArgs>(args: SelectSubset<T, ProvinsiUpdateArgs<ExtArgs>>): Prisma__ProvinsiClient<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provinsis.
     * @param {ProvinsiDeleteManyArgs} args - Arguments to filter Provinsis to delete.
     * @example
     * // Delete a few Provinsis
     * const { count } = await prisma.provinsi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvinsiDeleteManyArgs>(args?: SelectSubset<T, ProvinsiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinsiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provinsis
     * const provinsi = await prisma.provinsi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvinsiUpdateManyArgs>(args: SelectSubset<T, ProvinsiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provinsis and returns the data updated in the database.
     * @param {ProvinsiUpdateManyAndReturnArgs} args - Arguments to update many Provinsis.
     * @example
     * // Update many Provinsis
     * const provinsi = await prisma.provinsi.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provinsis and only return the `id_provinsi`
     * const provinsiWithId_provinsiOnly = await prisma.provinsi.updateManyAndReturn({
     *   select: { id_provinsi: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProvinsiUpdateManyAndReturnArgs>(args: SelectSubset<T, ProvinsiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provinsi.
     * @param {ProvinsiUpsertArgs} args - Arguments to update or create a Provinsi.
     * @example
     * // Update or create a Provinsi
     * const provinsi = await prisma.provinsi.upsert({
     *   create: {
     *     // ... data to create a Provinsi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provinsi we want to update
     *   }
     * })
     */
    upsert<T extends ProvinsiUpsertArgs>(args: SelectSubset<T, ProvinsiUpsertArgs<ExtArgs>>): Prisma__ProvinsiClient<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provinsis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinsiCountArgs} args - Arguments to filter Provinsis to count.
     * @example
     * // Count the number of Provinsis
     * const count = await prisma.provinsi.count({
     *   where: {
     *     // ... the filter for the Provinsis we want to count
     *   }
     * })
    **/
    count<T extends ProvinsiCountArgs>(
      args?: Subset<T, ProvinsiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinsiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provinsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinsiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinsiAggregateArgs>(args: Subset<T, ProvinsiAggregateArgs>): Prisma.PrismaPromise<GetProvinsiAggregateType<T>>

    /**
     * Group by Provinsi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinsiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvinsiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvinsiGroupByArgs['orderBy'] }
        : { orderBy?: ProvinsiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvinsiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinsiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provinsi model
   */
  readonly fields: ProvinsiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provinsi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvinsiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kabupaten<T extends Provinsi$kabupatenArgs<ExtArgs> = {}>(args?: Subset<T, Provinsi$kabupatenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Provinsi model
   */
  interface ProvinsiFieldRefs {
    readonly id_provinsi: FieldRef<"Provinsi", 'Int'>
    readonly nama_provinsi: FieldRef<"Provinsi", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Provinsi findUnique
   */
  export type ProvinsiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
    /**
     * Filter, which Provinsi to fetch.
     */
    where: ProvinsiWhereUniqueInput
  }

  /**
   * Provinsi findUniqueOrThrow
   */
  export type ProvinsiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
    /**
     * Filter, which Provinsi to fetch.
     */
    where: ProvinsiWhereUniqueInput
  }

  /**
   * Provinsi findFirst
   */
  export type ProvinsiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
    /**
     * Filter, which Provinsi to fetch.
     */
    where?: ProvinsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinsis to fetch.
     */
    orderBy?: ProvinsiOrderByWithRelationInput | ProvinsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinsis.
     */
    cursor?: ProvinsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinsis.
     */
    distinct?: ProvinsiScalarFieldEnum | ProvinsiScalarFieldEnum[]
  }

  /**
   * Provinsi findFirstOrThrow
   */
  export type ProvinsiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
    /**
     * Filter, which Provinsi to fetch.
     */
    where?: ProvinsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinsis to fetch.
     */
    orderBy?: ProvinsiOrderByWithRelationInput | ProvinsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Provinsis.
     */
    cursor?: ProvinsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinsis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Provinsis.
     */
    distinct?: ProvinsiScalarFieldEnum | ProvinsiScalarFieldEnum[]
  }

  /**
   * Provinsi findMany
   */
  export type ProvinsiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
    /**
     * Filter, which Provinsis to fetch.
     */
    where?: ProvinsiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Provinsis to fetch.
     */
    orderBy?: ProvinsiOrderByWithRelationInput | ProvinsiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Provinsis.
     */
    cursor?: ProvinsiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Provinsis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Provinsis.
     */
    skip?: number
    distinct?: ProvinsiScalarFieldEnum | ProvinsiScalarFieldEnum[]
  }

  /**
   * Provinsi create
   */
  export type ProvinsiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
    /**
     * The data needed to create a Provinsi.
     */
    data: XOR<ProvinsiCreateInput, ProvinsiUncheckedCreateInput>
  }

  /**
   * Provinsi createMany
   */
  export type ProvinsiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Provinsis.
     */
    data: ProvinsiCreateManyInput | ProvinsiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provinsi createManyAndReturn
   */
  export type ProvinsiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * The data used to create many Provinsis.
     */
    data: ProvinsiCreateManyInput | ProvinsiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provinsi update
   */
  export type ProvinsiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
    /**
     * The data needed to update a Provinsi.
     */
    data: XOR<ProvinsiUpdateInput, ProvinsiUncheckedUpdateInput>
    /**
     * Choose, which Provinsi to update.
     */
    where: ProvinsiWhereUniqueInput
  }

  /**
   * Provinsi updateMany
   */
  export type ProvinsiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Provinsis.
     */
    data: XOR<ProvinsiUpdateManyMutationInput, ProvinsiUncheckedUpdateManyInput>
    /**
     * Filter which Provinsis to update
     */
    where?: ProvinsiWhereInput
    /**
     * Limit how many Provinsis to update.
     */
    limit?: number
  }

  /**
   * Provinsi updateManyAndReturn
   */
  export type ProvinsiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * The data used to update Provinsis.
     */
    data: XOR<ProvinsiUpdateManyMutationInput, ProvinsiUncheckedUpdateManyInput>
    /**
     * Filter which Provinsis to update
     */
    where?: ProvinsiWhereInput
    /**
     * Limit how many Provinsis to update.
     */
    limit?: number
  }

  /**
   * Provinsi upsert
   */
  export type ProvinsiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
    /**
     * The filter to search for the Provinsi to update in case it exists.
     */
    where: ProvinsiWhereUniqueInput
    /**
     * In case the Provinsi found by the `where` argument doesn't exist, create a new Provinsi with this data.
     */
    create: XOR<ProvinsiCreateInput, ProvinsiUncheckedCreateInput>
    /**
     * In case the Provinsi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvinsiUpdateInput, ProvinsiUncheckedUpdateInput>
  }

  /**
   * Provinsi delete
   */
  export type ProvinsiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
    /**
     * Filter which Provinsi to delete.
     */
    where: ProvinsiWhereUniqueInput
  }

  /**
   * Provinsi deleteMany
   */
  export type ProvinsiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provinsis to delete
     */
    where?: ProvinsiWhereInput
    /**
     * Limit how many Provinsis to delete.
     */
    limit?: number
  }

  /**
   * Provinsi.kabupaten
   */
  export type Provinsi$kabupatenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    where?: KabupatenWhereInput
    orderBy?: KabupatenOrderByWithRelationInput | KabupatenOrderByWithRelationInput[]
    cursor?: KabupatenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KabupatenScalarFieldEnum | KabupatenScalarFieldEnum[]
  }

  /**
   * Provinsi without action
   */
  export type ProvinsiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provinsi
     */
    select?: ProvinsiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provinsi
     */
    omit?: ProvinsiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProvinsiInclude<ExtArgs> | null
  }


  /**
   * Model Kabupaten
   */

  export type AggregateKabupaten = {
    _count: KabupatenCountAggregateOutputType | null
    _avg: KabupatenAvgAggregateOutputType | null
    _sum: KabupatenSumAggregateOutputType | null
    _min: KabupatenMinAggregateOutputType | null
    _max: KabupatenMaxAggregateOutputType | null
  }

  export type KabupatenAvgAggregateOutputType = {
    id_kabupaten: number | null
    id_provinsi: number | null
  }

  export type KabupatenSumAggregateOutputType = {
    id_kabupaten: number | null
    id_provinsi: number | null
  }

  export type KabupatenMinAggregateOutputType = {
    id_kabupaten: number | null
    nama_kabupaten: string | null
    type: string | null
    id_provinsi: number | null
  }

  export type KabupatenMaxAggregateOutputType = {
    id_kabupaten: number | null
    nama_kabupaten: string | null
    type: string | null
    id_provinsi: number | null
  }

  export type KabupatenCountAggregateOutputType = {
    id_kabupaten: number
    nama_kabupaten: number
    type: number
    id_provinsi: number
    _all: number
  }


  export type KabupatenAvgAggregateInputType = {
    id_kabupaten?: true
    id_provinsi?: true
  }

  export type KabupatenSumAggregateInputType = {
    id_kabupaten?: true
    id_provinsi?: true
  }

  export type KabupatenMinAggregateInputType = {
    id_kabupaten?: true
    nama_kabupaten?: true
    type?: true
    id_provinsi?: true
  }

  export type KabupatenMaxAggregateInputType = {
    id_kabupaten?: true
    nama_kabupaten?: true
    type?: true
    id_provinsi?: true
  }

  export type KabupatenCountAggregateInputType = {
    id_kabupaten?: true
    nama_kabupaten?: true
    type?: true
    id_provinsi?: true
    _all?: true
  }

  export type KabupatenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kabupaten to aggregate.
     */
    where?: KabupatenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kabupatens to fetch.
     */
    orderBy?: KabupatenOrderByWithRelationInput | KabupatenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KabupatenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kabupatens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kabupatens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kabupatens
    **/
    _count?: true | KabupatenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KabupatenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KabupatenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KabupatenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KabupatenMaxAggregateInputType
  }

  export type GetKabupatenAggregateType<T extends KabupatenAggregateArgs> = {
        [P in keyof T & keyof AggregateKabupaten]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKabupaten[P]>
      : GetScalarType<T[P], AggregateKabupaten[P]>
  }




  export type KabupatenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KabupatenWhereInput
    orderBy?: KabupatenOrderByWithAggregationInput | KabupatenOrderByWithAggregationInput[]
    by: KabupatenScalarFieldEnum[] | KabupatenScalarFieldEnum
    having?: KabupatenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KabupatenCountAggregateInputType | true
    _avg?: KabupatenAvgAggregateInputType
    _sum?: KabupatenSumAggregateInputType
    _min?: KabupatenMinAggregateInputType
    _max?: KabupatenMaxAggregateInputType
  }

  export type KabupatenGroupByOutputType = {
    id_kabupaten: number
    nama_kabupaten: string
    type: string
    id_provinsi: number
    _count: KabupatenCountAggregateOutputType | null
    _avg: KabupatenAvgAggregateOutputType | null
    _sum: KabupatenSumAggregateOutputType | null
    _min: KabupatenMinAggregateOutputType | null
    _max: KabupatenMaxAggregateOutputType | null
  }

  type GetKabupatenGroupByPayload<T extends KabupatenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KabupatenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KabupatenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KabupatenGroupByOutputType[P]>
            : GetScalarType<T[P], KabupatenGroupByOutputType[P]>
        }
      >
    >


  export type KabupatenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kabupaten?: boolean
    nama_kabupaten?: boolean
    type?: boolean
    id_provinsi?: boolean
    provinsi?: boolean | ProvinsiDefaultArgs<ExtArgs>
    facilitators?: boolean | Kabupaten$facilitatorsArgs<ExtArgs>
    workshop?: boolean | Kabupaten$workshopArgs<ExtArgs>
    _count?: boolean | KabupatenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kabupaten"]>

  export type KabupatenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kabupaten?: boolean
    nama_kabupaten?: boolean
    type?: boolean
    id_provinsi?: boolean
    provinsi?: boolean | ProvinsiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kabupaten"]>

  export type KabupatenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kabupaten?: boolean
    nama_kabupaten?: boolean
    type?: boolean
    id_provinsi?: boolean
    provinsi?: boolean | ProvinsiDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kabupaten"]>

  export type KabupatenSelectScalar = {
    id_kabupaten?: boolean
    nama_kabupaten?: boolean
    type?: boolean
    id_provinsi?: boolean
  }

  export type KabupatenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_kabupaten" | "nama_kabupaten" | "type" | "id_provinsi", ExtArgs["result"]["kabupaten"]>
  export type KabupatenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provinsi?: boolean | ProvinsiDefaultArgs<ExtArgs>
    facilitators?: boolean | Kabupaten$facilitatorsArgs<ExtArgs>
    workshop?: boolean | Kabupaten$workshopArgs<ExtArgs>
    _count?: boolean | KabupatenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KabupatenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provinsi?: boolean | ProvinsiDefaultArgs<ExtArgs>
  }
  export type KabupatenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provinsi?: boolean | ProvinsiDefaultArgs<ExtArgs>
  }

  export type $KabupatenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kabupaten"
    objects: {
      provinsi: Prisma.$ProvinsiPayload<ExtArgs>
      facilitators: Prisma.$FacilitatorPayload<ExtArgs>[]
      workshop: Prisma.$WorkshopPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_kabupaten: number
      nama_kabupaten: string
      type: string
      id_provinsi: number
    }, ExtArgs["result"]["kabupaten"]>
    composites: {}
  }

  type KabupatenGetPayload<S extends boolean | null | undefined | KabupatenDefaultArgs> = $Result.GetResult<Prisma.$KabupatenPayload, S>

  type KabupatenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KabupatenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KabupatenCountAggregateInputType | true
    }

  export interface KabupatenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kabupaten'], meta: { name: 'Kabupaten' } }
    /**
     * Find zero or one Kabupaten that matches the filter.
     * @param {KabupatenFindUniqueArgs} args - Arguments to find a Kabupaten
     * @example
     * // Get one Kabupaten
     * const kabupaten = await prisma.kabupaten.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KabupatenFindUniqueArgs>(args: SelectSubset<T, KabupatenFindUniqueArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kabupaten that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KabupatenFindUniqueOrThrowArgs} args - Arguments to find a Kabupaten
     * @example
     * // Get one Kabupaten
     * const kabupaten = await prisma.kabupaten.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KabupatenFindUniqueOrThrowArgs>(args: SelectSubset<T, KabupatenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kabupaten that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KabupatenFindFirstArgs} args - Arguments to find a Kabupaten
     * @example
     * // Get one Kabupaten
     * const kabupaten = await prisma.kabupaten.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KabupatenFindFirstArgs>(args?: SelectSubset<T, KabupatenFindFirstArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kabupaten that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KabupatenFindFirstOrThrowArgs} args - Arguments to find a Kabupaten
     * @example
     * // Get one Kabupaten
     * const kabupaten = await prisma.kabupaten.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KabupatenFindFirstOrThrowArgs>(args?: SelectSubset<T, KabupatenFindFirstOrThrowArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kabupatens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KabupatenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kabupatens
     * const kabupatens = await prisma.kabupaten.findMany()
     * 
     * // Get first 10 Kabupatens
     * const kabupatens = await prisma.kabupaten.findMany({ take: 10 })
     * 
     * // Only select the `id_kabupaten`
     * const kabupatenWithId_kabupatenOnly = await prisma.kabupaten.findMany({ select: { id_kabupaten: true } })
     * 
     */
    findMany<T extends KabupatenFindManyArgs>(args?: SelectSubset<T, KabupatenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kabupaten.
     * @param {KabupatenCreateArgs} args - Arguments to create a Kabupaten.
     * @example
     * // Create one Kabupaten
     * const Kabupaten = await prisma.kabupaten.create({
     *   data: {
     *     // ... data to create a Kabupaten
     *   }
     * })
     * 
     */
    create<T extends KabupatenCreateArgs>(args: SelectSubset<T, KabupatenCreateArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kabupatens.
     * @param {KabupatenCreateManyArgs} args - Arguments to create many Kabupatens.
     * @example
     * // Create many Kabupatens
     * const kabupaten = await prisma.kabupaten.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KabupatenCreateManyArgs>(args?: SelectSubset<T, KabupatenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kabupatens and returns the data saved in the database.
     * @param {KabupatenCreateManyAndReturnArgs} args - Arguments to create many Kabupatens.
     * @example
     * // Create many Kabupatens
     * const kabupaten = await prisma.kabupaten.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kabupatens and only return the `id_kabupaten`
     * const kabupatenWithId_kabupatenOnly = await prisma.kabupaten.createManyAndReturn({
     *   select: { id_kabupaten: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KabupatenCreateManyAndReturnArgs>(args?: SelectSubset<T, KabupatenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kabupaten.
     * @param {KabupatenDeleteArgs} args - Arguments to delete one Kabupaten.
     * @example
     * // Delete one Kabupaten
     * const Kabupaten = await prisma.kabupaten.delete({
     *   where: {
     *     // ... filter to delete one Kabupaten
     *   }
     * })
     * 
     */
    delete<T extends KabupatenDeleteArgs>(args: SelectSubset<T, KabupatenDeleteArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kabupaten.
     * @param {KabupatenUpdateArgs} args - Arguments to update one Kabupaten.
     * @example
     * // Update one Kabupaten
     * const kabupaten = await prisma.kabupaten.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KabupatenUpdateArgs>(args: SelectSubset<T, KabupatenUpdateArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kabupatens.
     * @param {KabupatenDeleteManyArgs} args - Arguments to filter Kabupatens to delete.
     * @example
     * // Delete a few Kabupatens
     * const { count } = await prisma.kabupaten.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KabupatenDeleteManyArgs>(args?: SelectSubset<T, KabupatenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kabupatens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KabupatenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kabupatens
     * const kabupaten = await prisma.kabupaten.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KabupatenUpdateManyArgs>(args: SelectSubset<T, KabupatenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kabupatens and returns the data updated in the database.
     * @param {KabupatenUpdateManyAndReturnArgs} args - Arguments to update many Kabupatens.
     * @example
     * // Update many Kabupatens
     * const kabupaten = await prisma.kabupaten.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kabupatens and only return the `id_kabupaten`
     * const kabupatenWithId_kabupatenOnly = await prisma.kabupaten.updateManyAndReturn({
     *   select: { id_kabupaten: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KabupatenUpdateManyAndReturnArgs>(args: SelectSubset<T, KabupatenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kabupaten.
     * @param {KabupatenUpsertArgs} args - Arguments to update or create a Kabupaten.
     * @example
     * // Update or create a Kabupaten
     * const kabupaten = await prisma.kabupaten.upsert({
     *   create: {
     *     // ... data to create a Kabupaten
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kabupaten we want to update
     *   }
     * })
     */
    upsert<T extends KabupatenUpsertArgs>(args: SelectSubset<T, KabupatenUpsertArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kabupatens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KabupatenCountArgs} args - Arguments to filter Kabupatens to count.
     * @example
     * // Count the number of Kabupatens
     * const count = await prisma.kabupaten.count({
     *   where: {
     *     // ... the filter for the Kabupatens we want to count
     *   }
     * })
    **/
    count<T extends KabupatenCountArgs>(
      args?: Subset<T, KabupatenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KabupatenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kabupaten.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KabupatenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KabupatenAggregateArgs>(args: Subset<T, KabupatenAggregateArgs>): Prisma.PrismaPromise<GetKabupatenAggregateType<T>>

    /**
     * Group by Kabupaten.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KabupatenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KabupatenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KabupatenGroupByArgs['orderBy'] }
        : { orderBy?: KabupatenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KabupatenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKabupatenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kabupaten model
   */
  readonly fields: KabupatenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kabupaten.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KabupatenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provinsi<T extends ProvinsiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProvinsiDefaultArgs<ExtArgs>>): Prisma__ProvinsiClient<$Result.GetResult<Prisma.$ProvinsiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    facilitators<T extends Kabupaten$facilitatorsArgs<ExtArgs> = {}>(args?: Subset<T, Kabupaten$facilitatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workshop<T extends Kabupaten$workshopArgs<ExtArgs> = {}>(args?: Subset<T, Kabupaten$workshopArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kabupaten model
   */
  interface KabupatenFieldRefs {
    readonly id_kabupaten: FieldRef<"Kabupaten", 'Int'>
    readonly nama_kabupaten: FieldRef<"Kabupaten", 'String'>
    readonly type: FieldRef<"Kabupaten", 'String'>
    readonly id_provinsi: FieldRef<"Kabupaten", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Kabupaten findUnique
   */
  export type KabupatenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    /**
     * Filter, which Kabupaten to fetch.
     */
    where: KabupatenWhereUniqueInput
  }

  /**
   * Kabupaten findUniqueOrThrow
   */
  export type KabupatenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    /**
     * Filter, which Kabupaten to fetch.
     */
    where: KabupatenWhereUniqueInput
  }

  /**
   * Kabupaten findFirst
   */
  export type KabupatenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    /**
     * Filter, which Kabupaten to fetch.
     */
    where?: KabupatenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kabupatens to fetch.
     */
    orderBy?: KabupatenOrderByWithRelationInput | KabupatenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kabupatens.
     */
    cursor?: KabupatenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kabupatens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kabupatens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kabupatens.
     */
    distinct?: KabupatenScalarFieldEnum | KabupatenScalarFieldEnum[]
  }

  /**
   * Kabupaten findFirstOrThrow
   */
  export type KabupatenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    /**
     * Filter, which Kabupaten to fetch.
     */
    where?: KabupatenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kabupatens to fetch.
     */
    orderBy?: KabupatenOrderByWithRelationInput | KabupatenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kabupatens.
     */
    cursor?: KabupatenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kabupatens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kabupatens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kabupatens.
     */
    distinct?: KabupatenScalarFieldEnum | KabupatenScalarFieldEnum[]
  }

  /**
   * Kabupaten findMany
   */
  export type KabupatenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    /**
     * Filter, which Kabupatens to fetch.
     */
    where?: KabupatenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kabupatens to fetch.
     */
    orderBy?: KabupatenOrderByWithRelationInput | KabupatenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kabupatens.
     */
    cursor?: KabupatenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kabupatens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kabupatens.
     */
    skip?: number
    distinct?: KabupatenScalarFieldEnum | KabupatenScalarFieldEnum[]
  }

  /**
   * Kabupaten create
   */
  export type KabupatenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    /**
     * The data needed to create a Kabupaten.
     */
    data: XOR<KabupatenCreateInput, KabupatenUncheckedCreateInput>
  }

  /**
   * Kabupaten createMany
   */
  export type KabupatenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kabupatens.
     */
    data: KabupatenCreateManyInput | KabupatenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kabupaten createManyAndReturn
   */
  export type KabupatenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * The data used to create many Kabupatens.
     */
    data: KabupatenCreateManyInput | KabupatenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kabupaten update
   */
  export type KabupatenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    /**
     * The data needed to update a Kabupaten.
     */
    data: XOR<KabupatenUpdateInput, KabupatenUncheckedUpdateInput>
    /**
     * Choose, which Kabupaten to update.
     */
    where: KabupatenWhereUniqueInput
  }

  /**
   * Kabupaten updateMany
   */
  export type KabupatenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kabupatens.
     */
    data: XOR<KabupatenUpdateManyMutationInput, KabupatenUncheckedUpdateManyInput>
    /**
     * Filter which Kabupatens to update
     */
    where?: KabupatenWhereInput
    /**
     * Limit how many Kabupatens to update.
     */
    limit?: number
  }

  /**
   * Kabupaten updateManyAndReturn
   */
  export type KabupatenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * The data used to update Kabupatens.
     */
    data: XOR<KabupatenUpdateManyMutationInput, KabupatenUncheckedUpdateManyInput>
    /**
     * Filter which Kabupatens to update
     */
    where?: KabupatenWhereInput
    /**
     * Limit how many Kabupatens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kabupaten upsert
   */
  export type KabupatenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    /**
     * The filter to search for the Kabupaten to update in case it exists.
     */
    where: KabupatenWhereUniqueInput
    /**
     * In case the Kabupaten found by the `where` argument doesn't exist, create a new Kabupaten with this data.
     */
    create: XOR<KabupatenCreateInput, KabupatenUncheckedCreateInput>
    /**
     * In case the Kabupaten was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KabupatenUpdateInput, KabupatenUncheckedUpdateInput>
  }

  /**
   * Kabupaten delete
   */
  export type KabupatenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
    /**
     * Filter which Kabupaten to delete.
     */
    where: KabupatenWhereUniqueInput
  }

  /**
   * Kabupaten deleteMany
   */
  export type KabupatenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kabupatens to delete
     */
    where?: KabupatenWhereInput
    /**
     * Limit how many Kabupatens to delete.
     */
    limit?: number
  }

  /**
   * Kabupaten.facilitators
   */
  export type Kabupaten$facilitatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    where?: FacilitatorWhereInput
    orderBy?: FacilitatorOrderByWithRelationInput | FacilitatorOrderByWithRelationInput[]
    cursor?: FacilitatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacilitatorScalarFieldEnum | FacilitatorScalarFieldEnum[]
  }

  /**
   * Kabupaten.workshop
   */
  export type Kabupaten$workshopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    cursor?: WorkshopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Kabupaten without action
   */
  export type KabupatenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kabupaten
     */
    select?: KabupatenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kabupaten
     */
    omit?: KabupatenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KabupatenInclude<ExtArgs> | null
  }


  /**
   * Model Pengguna
   */

  export type AggregatePengguna = {
    _count: PenggunaCountAggregateOutputType | null
    _avg: PenggunaAvgAggregateOutputType | null
    _sum: PenggunaSumAggregateOutputType | null
    _min: PenggunaMinAggregateOutputType | null
    _max: PenggunaMaxAggregateOutputType | null
  }

  export type PenggunaAvgAggregateOutputType = {
    jenisKelamin: number | null
  }

  export type PenggunaSumAggregateOutputType = {
    jenisKelamin: number | null
  }

  export type PenggunaMinAggregateOutputType = {
    id_pengguna: string | null
    nama_depan_pengguna: string | null
    nama_belakang_pengguna: string | null
    tanggal_lahir_pengguna: Date | null
    email_pengguna: string | null
    nomor_telepon_pengguna: string | null
    jenisKelamin: number | null
    password_pengguna: string | null
    tanggal_pembuatan_akun: Date | null
    kode_verifikasi: string | null
    status_verfikasi: boolean | null
    avatar: string | null
    status_aktif: boolean | null
  }

  export type PenggunaMaxAggregateOutputType = {
    id_pengguna: string | null
    nama_depan_pengguna: string | null
    nama_belakang_pengguna: string | null
    tanggal_lahir_pengguna: Date | null
    email_pengguna: string | null
    nomor_telepon_pengguna: string | null
    jenisKelamin: number | null
    password_pengguna: string | null
    tanggal_pembuatan_akun: Date | null
    kode_verifikasi: string | null
    status_verfikasi: boolean | null
    avatar: string | null
    status_aktif: boolean | null
  }

  export type PenggunaCountAggregateOutputType = {
    id_pengguna: number
    nama_depan_pengguna: number
    nama_belakang_pengguna: number
    tanggal_lahir_pengguna: number
    email_pengguna: number
    nomor_telepon_pengguna: number
    jenisKelamin: number
    password_pengguna: number
    tanggal_pembuatan_akun: number
    kode_verifikasi: number
    status_verfikasi: number
    avatar: number
    status_aktif: number
    _all: number
  }


  export type PenggunaAvgAggregateInputType = {
    jenisKelamin?: true
  }

  export type PenggunaSumAggregateInputType = {
    jenisKelamin?: true
  }

  export type PenggunaMinAggregateInputType = {
    id_pengguna?: true
    nama_depan_pengguna?: true
    nama_belakang_pengguna?: true
    tanggal_lahir_pengguna?: true
    email_pengguna?: true
    nomor_telepon_pengguna?: true
    jenisKelamin?: true
    password_pengguna?: true
    tanggal_pembuatan_akun?: true
    kode_verifikasi?: true
    status_verfikasi?: true
    avatar?: true
    status_aktif?: true
  }

  export type PenggunaMaxAggregateInputType = {
    id_pengguna?: true
    nama_depan_pengguna?: true
    nama_belakang_pengguna?: true
    tanggal_lahir_pengguna?: true
    email_pengguna?: true
    nomor_telepon_pengguna?: true
    jenisKelamin?: true
    password_pengguna?: true
    tanggal_pembuatan_akun?: true
    kode_verifikasi?: true
    status_verfikasi?: true
    avatar?: true
    status_aktif?: true
  }

  export type PenggunaCountAggregateInputType = {
    id_pengguna?: true
    nama_depan_pengguna?: true
    nama_belakang_pengguna?: true
    tanggal_lahir_pengguna?: true
    email_pengguna?: true
    nomor_telepon_pengguna?: true
    jenisKelamin?: true
    password_pengguna?: true
    tanggal_pembuatan_akun?: true
    kode_verifikasi?: true
    status_verfikasi?: true
    avatar?: true
    status_aktif?: true
    _all?: true
  }

  export type PenggunaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pengguna to aggregate.
     */
    where?: PenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penggunas to fetch.
     */
    orderBy?: PenggunaOrderByWithRelationInput | PenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Penggunas
    **/
    _count?: true | PenggunaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PenggunaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PenggunaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PenggunaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PenggunaMaxAggregateInputType
  }

  export type GetPenggunaAggregateType<T extends PenggunaAggregateArgs> = {
        [P in keyof T & keyof AggregatePengguna]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePengguna[P]>
      : GetScalarType<T[P], AggregatePengguna[P]>
  }




  export type PenggunaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PenggunaWhereInput
    orderBy?: PenggunaOrderByWithAggregationInput | PenggunaOrderByWithAggregationInput[]
    by: PenggunaScalarFieldEnum[] | PenggunaScalarFieldEnum
    having?: PenggunaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PenggunaCountAggregateInputType | true
    _avg?: PenggunaAvgAggregateInputType
    _sum?: PenggunaSumAggregateInputType
    _min?: PenggunaMinAggregateInputType
    _max?: PenggunaMaxAggregateInputType
  }

  export type PenggunaGroupByOutputType = {
    id_pengguna: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar: string | null
    status_aktif: boolean
    _count: PenggunaCountAggregateOutputType | null
    _avg: PenggunaAvgAggregateOutputType | null
    _sum: PenggunaSumAggregateOutputType | null
    _min: PenggunaMinAggregateOutputType | null
    _max: PenggunaMaxAggregateOutputType | null
  }

  type GetPenggunaGroupByPayload<T extends PenggunaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PenggunaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PenggunaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PenggunaGroupByOutputType[P]>
            : GetScalarType<T[P], PenggunaGroupByOutputType[P]>
        }
      >
    >


  export type PenggunaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pengguna?: boolean
    nama_depan_pengguna?: boolean
    nama_belakang_pengguna?: boolean
    tanggal_lahir_pengguna?: boolean
    email_pengguna?: boolean
    nomor_telepon_pengguna?: boolean
    jenisKelamin?: boolean
    password_pengguna?: boolean
    tanggal_pembuatan_akun?: boolean
    kode_verifikasi?: boolean
    status_verfikasi?: boolean
    avatar?: boolean
    status_aktif?: boolean
    workshop_terdaftar?: boolean | Pengguna$workshop_terdaftarArgs<ExtArgs>
    artikel?: boolean | Pengguna$artikelArgs<ExtArgs>
    artikel_disimpan?: boolean | Pengguna$artikel_disimpanArgs<ExtArgs>
    artikel_disukai?: boolean | Pengguna$artikel_disukaiArgs<ExtArgs>
    komentar_artikel?: boolean | Pengguna$komentar_artikelArgs<ExtArgs>
    tanaman_pengguna?: boolean | Pengguna$tanaman_penggunaArgs<ExtArgs>
    _count?: boolean | PenggunaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengguna"]>

  export type PenggunaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pengguna?: boolean
    nama_depan_pengguna?: boolean
    nama_belakang_pengguna?: boolean
    tanggal_lahir_pengguna?: boolean
    email_pengguna?: boolean
    nomor_telepon_pengguna?: boolean
    jenisKelamin?: boolean
    password_pengguna?: boolean
    tanggal_pembuatan_akun?: boolean
    kode_verifikasi?: boolean
    status_verfikasi?: boolean
    avatar?: boolean
    status_aktif?: boolean
  }, ExtArgs["result"]["pengguna"]>

  export type PenggunaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pengguna?: boolean
    nama_depan_pengguna?: boolean
    nama_belakang_pengguna?: boolean
    tanggal_lahir_pengguna?: boolean
    email_pengguna?: boolean
    nomor_telepon_pengguna?: boolean
    jenisKelamin?: boolean
    password_pengguna?: boolean
    tanggal_pembuatan_akun?: boolean
    kode_verifikasi?: boolean
    status_verfikasi?: boolean
    avatar?: boolean
    status_aktif?: boolean
  }, ExtArgs["result"]["pengguna"]>

  export type PenggunaSelectScalar = {
    id_pengguna?: boolean
    nama_depan_pengguna?: boolean
    nama_belakang_pengguna?: boolean
    tanggal_lahir_pengguna?: boolean
    email_pengguna?: boolean
    nomor_telepon_pengguna?: boolean
    jenisKelamin?: boolean
    password_pengguna?: boolean
    tanggal_pembuatan_akun?: boolean
    kode_verifikasi?: boolean
    status_verfikasi?: boolean
    avatar?: boolean
    status_aktif?: boolean
  }

  export type PenggunaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pengguna" | "nama_depan_pengguna" | "nama_belakang_pengguna" | "tanggal_lahir_pengguna" | "email_pengguna" | "nomor_telepon_pengguna" | "jenisKelamin" | "password_pengguna" | "tanggal_pembuatan_akun" | "kode_verifikasi" | "status_verfikasi" | "avatar" | "status_aktif", ExtArgs["result"]["pengguna"]>
  export type PenggunaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workshop_terdaftar?: boolean | Pengguna$workshop_terdaftarArgs<ExtArgs>
    artikel?: boolean | Pengguna$artikelArgs<ExtArgs>
    artikel_disimpan?: boolean | Pengguna$artikel_disimpanArgs<ExtArgs>
    artikel_disukai?: boolean | Pengguna$artikel_disukaiArgs<ExtArgs>
    komentar_artikel?: boolean | Pengguna$komentar_artikelArgs<ExtArgs>
    tanaman_pengguna?: boolean | Pengguna$tanaman_penggunaArgs<ExtArgs>
    _count?: boolean | PenggunaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PenggunaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PenggunaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PenggunaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pengguna"
    objects: {
      workshop_terdaftar: Prisma.$WorkshopTerdaftarPayload<ExtArgs>[]
      artikel: Prisma.$ArtikelPayload<ExtArgs>[]
      artikel_disimpan: Prisma.$ArtikelDisimpanPayload<ExtArgs>[]
      artikel_disukai: Prisma.$ArtikelDisukaiPayload<ExtArgs>[]
      komentar_artikel: Prisma.$KomentarArtikelPayload<ExtArgs>[]
      tanaman_pengguna: Prisma.$TanamanPenggunaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pengguna: string
      nama_depan_pengguna: string
      nama_belakang_pengguna: string
      tanggal_lahir_pengguna: Date
      email_pengguna: string
      nomor_telepon_pengguna: string
      jenisKelamin: number
      password_pengguna: string
      tanggal_pembuatan_akun: Date
      kode_verifikasi: string
      status_verfikasi: boolean
      avatar: string | null
      status_aktif: boolean
    }, ExtArgs["result"]["pengguna"]>
    composites: {}
  }

  type PenggunaGetPayload<S extends boolean | null | undefined | PenggunaDefaultArgs> = $Result.GetResult<Prisma.$PenggunaPayload, S>

  type PenggunaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PenggunaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PenggunaCountAggregateInputType | true
    }

  export interface PenggunaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pengguna'], meta: { name: 'Pengguna' } }
    /**
     * Find zero or one Pengguna that matches the filter.
     * @param {PenggunaFindUniqueArgs} args - Arguments to find a Pengguna
     * @example
     * // Get one Pengguna
     * const pengguna = await prisma.pengguna.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PenggunaFindUniqueArgs>(args: SelectSubset<T, PenggunaFindUniqueArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pengguna that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PenggunaFindUniqueOrThrowArgs} args - Arguments to find a Pengguna
     * @example
     * // Get one Pengguna
     * const pengguna = await prisma.pengguna.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PenggunaFindUniqueOrThrowArgs>(args: SelectSubset<T, PenggunaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pengguna that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenggunaFindFirstArgs} args - Arguments to find a Pengguna
     * @example
     * // Get one Pengguna
     * const pengguna = await prisma.pengguna.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PenggunaFindFirstArgs>(args?: SelectSubset<T, PenggunaFindFirstArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pengguna that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenggunaFindFirstOrThrowArgs} args - Arguments to find a Pengguna
     * @example
     * // Get one Pengguna
     * const pengguna = await prisma.pengguna.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PenggunaFindFirstOrThrowArgs>(args?: SelectSubset<T, PenggunaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Penggunas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenggunaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Penggunas
     * const penggunas = await prisma.pengguna.findMany()
     * 
     * // Get first 10 Penggunas
     * const penggunas = await prisma.pengguna.findMany({ take: 10 })
     * 
     * // Only select the `id_pengguna`
     * const penggunaWithId_penggunaOnly = await prisma.pengguna.findMany({ select: { id_pengguna: true } })
     * 
     */
    findMany<T extends PenggunaFindManyArgs>(args?: SelectSubset<T, PenggunaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pengguna.
     * @param {PenggunaCreateArgs} args - Arguments to create a Pengguna.
     * @example
     * // Create one Pengguna
     * const Pengguna = await prisma.pengguna.create({
     *   data: {
     *     // ... data to create a Pengguna
     *   }
     * })
     * 
     */
    create<T extends PenggunaCreateArgs>(args: SelectSubset<T, PenggunaCreateArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Penggunas.
     * @param {PenggunaCreateManyArgs} args - Arguments to create many Penggunas.
     * @example
     * // Create many Penggunas
     * const pengguna = await prisma.pengguna.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PenggunaCreateManyArgs>(args?: SelectSubset<T, PenggunaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Penggunas and returns the data saved in the database.
     * @param {PenggunaCreateManyAndReturnArgs} args - Arguments to create many Penggunas.
     * @example
     * // Create many Penggunas
     * const pengguna = await prisma.pengguna.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Penggunas and only return the `id_pengguna`
     * const penggunaWithId_penggunaOnly = await prisma.pengguna.createManyAndReturn({
     *   select: { id_pengguna: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PenggunaCreateManyAndReturnArgs>(args?: SelectSubset<T, PenggunaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pengguna.
     * @param {PenggunaDeleteArgs} args - Arguments to delete one Pengguna.
     * @example
     * // Delete one Pengguna
     * const Pengguna = await prisma.pengguna.delete({
     *   where: {
     *     // ... filter to delete one Pengguna
     *   }
     * })
     * 
     */
    delete<T extends PenggunaDeleteArgs>(args: SelectSubset<T, PenggunaDeleteArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pengguna.
     * @param {PenggunaUpdateArgs} args - Arguments to update one Pengguna.
     * @example
     * // Update one Pengguna
     * const pengguna = await prisma.pengguna.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PenggunaUpdateArgs>(args: SelectSubset<T, PenggunaUpdateArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Penggunas.
     * @param {PenggunaDeleteManyArgs} args - Arguments to filter Penggunas to delete.
     * @example
     * // Delete a few Penggunas
     * const { count } = await prisma.pengguna.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PenggunaDeleteManyArgs>(args?: SelectSubset<T, PenggunaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Penggunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenggunaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Penggunas
     * const pengguna = await prisma.pengguna.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PenggunaUpdateManyArgs>(args: SelectSubset<T, PenggunaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Penggunas and returns the data updated in the database.
     * @param {PenggunaUpdateManyAndReturnArgs} args - Arguments to update many Penggunas.
     * @example
     * // Update many Penggunas
     * const pengguna = await prisma.pengguna.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Penggunas and only return the `id_pengguna`
     * const penggunaWithId_penggunaOnly = await prisma.pengguna.updateManyAndReturn({
     *   select: { id_pengguna: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PenggunaUpdateManyAndReturnArgs>(args: SelectSubset<T, PenggunaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pengguna.
     * @param {PenggunaUpsertArgs} args - Arguments to update or create a Pengguna.
     * @example
     * // Update or create a Pengguna
     * const pengguna = await prisma.pengguna.upsert({
     *   create: {
     *     // ... data to create a Pengguna
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pengguna we want to update
     *   }
     * })
     */
    upsert<T extends PenggunaUpsertArgs>(args: SelectSubset<T, PenggunaUpsertArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Penggunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenggunaCountArgs} args - Arguments to filter Penggunas to count.
     * @example
     * // Count the number of Penggunas
     * const count = await prisma.pengguna.count({
     *   where: {
     *     // ... the filter for the Penggunas we want to count
     *   }
     * })
    **/
    count<T extends PenggunaCountArgs>(
      args?: Subset<T, PenggunaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PenggunaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pengguna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenggunaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PenggunaAggregateArgs>(args: Subset<T, PenggunaAggregateArgs>): Prisma.PrismaPromise<GetPenggunaAggregateType<T>>

    /**
     * Group by Pengguna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PenggunaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PenggunaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PenggunaGroupByArgs['orderBy'] }
        : { orderBy?: PenggunaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PenggunaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPenggunaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pengguna model
   */
  readonly fields: PenggunaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pengguna.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PenggunaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workshop_terdaftar<T extends Pengguna$workshop_terdaftarArgs<ExtArgs> = {}>(args?: Subset<T, Pengguna$workshop_terdaftarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artikel<T extends Pengguna$artikelArgs<ExtArgs> = {}>(args?: Subset<T, Pengguna$artikelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artikel_disimpan<T extends Pengguna$artikel_disimpanArgs<ExtArgs> = {}>(args?: Subset<T, Pengguna$artikel_disimpanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artikel_disukai<T extends Pengguna$artikel_disukaiArgs<ExtArgs> = {}>(args?: Subset<T, Pengguna$artikel_disukaiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    komentar_artikel<T extends Pengguna$komentar_artikelArgs<ExtArgs> = {}>(args?: Subset<T, Pengguna$komentar_artikelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tanaman_pengguna<T extends Pengguna$tanaman_penggunaArgs<ExtArgs> = {}>(args?: Subset<T, Pengguna$tanaman_penggunaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pengguna model
   */
  interface PenggunaFieldRefs {
    readonly id_pengguna: FieldRef<"Pengguna", 'String'>
    readonly nama_depan_pengguna: FieldRef<"Pengguna", 'String'>
    readonly nama_belakang_pengguna: FieldRef<"Pengguna", 'String'>
    readonly tanggal_lahir_pengguna: FieldRef<"Pengguna", 'DateTime'>
    readonly email_pengguna: FieldRef<"Pengguna", 'String'>
    readonly nomor_telepon_pengguna: FieldRef<"Pengguna", 'String'>
    readonly jenisKelamin: FieldRef<"Pengguna", 'Int'>
    readonly password_pengguna: FieldRef<"Pengguna", 'String'>
    readonly tanggal_pembuatan_akun: FieldRef<"Pengguna", 'DateTime'>
    readonly kode_verifikasi: FieldRef<"Pengguna", 'String'>
    readonly status_verfikasi: FieldRef<"Pengguna", 'Boolean'>
    readonly avatar: FieldRef<"Pengguna", 'String'>
    readonly status_aktif: FieldRef<"Pengguna", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Pengguna findUnique
   */
  export type PenggunaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
    /**
     * Filter, which Pengguna to fetch.
     */
    where: PenggunaWhereUniqueInput
  }

  /**
   * Pengguna findUniqueOrThrow
   */
  export type PenggunaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
    /**
     * Filter, which Pengguna to fetch.
     */
    where: PenggunaWhereUniqueInput
  }

  /**
   * Pengguna findFirst
   */
  export type PenggunaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
    /**
     * Filter, which Pengguna to fetch.
     */
    where?: PenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penggunas to fetch.
     */
    orderBy?: PenggunaOrderByWithRelationInput | PenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penggunas.
     */
    cursor?: PenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penggunas.
     */
    distinct?: PenggunaScalarFieldEnum | PenggunaScalarFieldEnum[]
  }

  /**
   * Pengguna findFirstOrThrow
   */
  export type PenggunaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
    /**
     * Filter, which Pengguna to fetch.
     */
    where?: PenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penggunas to fetch.
     */
    orderBy?: PenggunaOrderByWithRelationInput | PenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Penggunas.
     */
    cursor?: PenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Penggunas.
     */
    distinct?: PenggunaScalarFieldEnum | PenggunaScalarFieldEnum[]
  }

  /**
   * Pengguna findMany
   */
  export type PenggunaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
    /**
     * Filter, which Penggunas to fetch.
     */
    where?: PenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Penggunas to fetch.
     */
    orderBy?: PenggunaOrderByWithRelationInput | PenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Penggunas.
     */
    cursor?: PenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Penggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Penggunas.
     */
    skip?: number
    distinct?: PenggunaScalarFieldEnum | PenggunaScalarFieldEnum[]
  }

  /**
   * Pengguna create
   */
  export type PenggunaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
    /**
     * The data needed to create a Pengguna.
     */
    data: XOR<PenggunaCreateInput, PenggunaUncheckedCreateInput>
  }

  /**
   * Pengguna createMany
   */
  export type PenggunaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Penggunas.
     */
    data: PenggunaCreateManyInput | PenggunaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pengguna createManyAndReturn
   */
  export type PenggunaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * The data used to create many Penggunas.
     */
    data: PenggunaCreateManyInput | PenggunaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pengguna update
   */
  export type PenggunaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
    /**
     * The data needed to update a Pengguna.
     */
    data: XOR<PenggunaUpdateInput, PenggunaUncheckedUpdateInput>
    /**
     * Choose, which Pengguna to update.
     */
    where: PenggunaWhereUniqueInput
  }

  /**
   * Pengguna updateMany
   */
  export type PenggunaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Penggunas.
     */
    data: XOR<PenggunaUpdateManyMutationInput, PenggunaUncheckedUpdateManyInput>
    /**
     * Filter which Penggunas to update
     */
    where?: PenggunaWhereInput
    /**
     * Limit how many Penggunas to update.
     */
    limit?: number
  }

  /**
   * Pengguna updateManyAndReturn
   */
  export type PenggunaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * The data used to update Penggunas.
     */
    data: XOR<PenggunaUpdateManyMutationInput, PenggunaUncheckedUpdateManyInput>
    /**
     * Filter which Penggunas to update
     */
    where?: PenggunaWhereInput
    /**
     * Limit how many Penggunas to update.
     */
    limit?: number
  }

  /**
   * Pengguna upsert
   */
  export type PenggunaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
    /**
     * The filter to search for the Pengguna to update in case it exists.
     */
    where: PenggunaWhereUniqueInput
    /**
     * In case the Pengguna found by the `where` argument doesn't exist, create a new Pengguna with this data.
     */
    create: XOR<PenggunaCreateInput, PenggunaUncheckedCreateInput>
    /**
     * In case the Pengguna was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PenggunaUpdateInput, PenggunaUncheckedUpdateInput>
  }

  /**
   * Pengguna delete
   */
  export type PenggunaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
    /**
     * Filter which Pengguna to delete.
     */
    where: PenggunaWhereUniqueInput
  }

  /**
   * Pengguna deleteMany
   */
  export type PenggunaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Penggunas to delete
     */
    where?: PenggunaWhereInput
    /**
     * Limit how many Penggunas to delete.
     */
    limit?: number
  }

  /**
   * Pengguna.workshop_terdaftar
   */
  export type Pengguna$workshop_terdaftarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    where?: WorkshopTerdaftarWhereInput
    orderBy?: WorkshopTerdaftarOrderByWithRelationInput | WorkshopTerdaftarOrderByWithRelationInput[]
    cursor?: WorkshopTerdaftarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopTerdaftarScalarFieldEnum | WorkshopTerdaftarScalarFieldEnum[]
  }

  /**
   * Pengguna.artikel
   */
  export type Pengguna$artikelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    where?: ArtikelWhereInput
    orderBy?: ArtikelOrderByWithRelationInput | ArtikelOrderByWithRelationInput[]
    cursor?: ArtikelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtikelScalarFieldEnum | ArtikelScalarFieldEnum[]
  }

  /**
   * Pengguna.artikel_disimpan
   */
  export type Pengguna$artikel_disimpanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    where?: ArtikelDisimpanWhereInput
    orderBy?: ArtikelDisimpanOrderByWithRelationInput | ArtikelDisimpanOrderByWithRelationInput[]
    cursor?: ArtikelDisimpanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtikelDisimpanScalarFieldEnum | ArtikelDisimpanScalarFieldEnum[]
  }

  /**
   * Pengguna.artikel_disukai
   */
  export type Pengguna$artikel_disukaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    where?: ArtikelDisukaiWhereInput
    orderBy?: ArtikelDisukaiOrderByWithRelationInput | ArtikelDisukaiOrderByWithRelationInput[]
    cursor?: ArtikelDisukaiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtikelDisukaiScalarFieldEnum | ArtikelDisukaiScalarFieldEnum[]
  }

  /**
   * Pengguna.komentar_artikel
   */
  export type Pengguna$komentar_artikelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    where?: KomentarArtikelWhereInput
    orderBy?: KomentarArtikelOrderByWithRelationInput | KomentarArtikelOrderByWithRelationInput[]
    cursor?: KomentarArtikelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KomentarArtikelScalarFieldEnum | KomentarArtikelScalarFieldEnum[]
  }

  /**
   * Pengguna.tanaman_pengguna
   */
  export type Pengguna$tanaman_penggunaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    where?: TanamanPenggunaWhereInput
    orderBy?: TanamanPenggunaOrderByWithRelationInput | TanamanPenggunaOrderByWithRelationInput[]
    cursor?: TanamanPenggunaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TanamanPenggunaScalarFieldEnum | TanamanPenggunaScalarFieldEnum[]
  }

  /**
   * Pengguna without action
   */
  export type PenggunaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengguna
     */
    select?: PenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pengguna
     */
    omit?: PenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PenggunaInclude<ExtArgs> | null
  }


  /**
   * Model Facilitator
   */

  export type AggregateFacilitator = {
    _count: FacilitatorCountAggregateOutputType | null
    _avg: FacilitatorAvgAggregateOutputType | null
    _sum: FacilitatorSumAggregateOutputType | null
    _min: FacilitatorMinAggregateOutputType | null
    _max: FacilitatorMaxAggregateOutputType | null
  }

  export type FacilitatorAvgAggregateOutputType = {
    id_kabupaten: number | null
  }

  export type FacilitatorSumAggregateOutputType = {
    id_kabupaten: number | null
  }

  export type FacilitatorMinAggregateOutputType = {
    id_facilitator: string | null
    nama_facilitator: string | null
    email_facilitator: string | null
    nomor_telepon_facilitator: string | null
    password_facilitator: string | null
    tanggal_pembuatan_akun: Date | null
    alamat_lengkap_facilitator: string | null
    avatar: string | null
    status_aktif: boolean | null
    id_kabupaten: number | null
  }

  export type FacilitatorMaxAggregateOutputType = {
    id_facilitator: string | null
    nama_facilitator: string | null
    email_facilitator: string | null
    nomor_telepon_facilitator: string | null
    password_facilitator: string | null
    tanggal_pembuatan_akun: Date | null
    alamat_lengkap_facilitator: string | null
    avatar: string | null
    status_aktif: boolean | null
    id_kabupaten: number | null
  }

  export type FacilitatorCountAggregateOutputType = {
    id_facilitator: number
    nama_facilitator: number
    email_facilitator: number
    nomor_telepon_facilitator: number
    password_facilitator: number
    tanggal_pembuatan_akun: number
    alamat_lengkap_facilitator: number
    avatar: number
    status_aktif: number
    id_kabupaten: number
    _all: number
  }


  export type FacilitatorAvgAggregateInputType = {
    id_kabupaten?: true
  }

  export type FacilitatorSumAggregateInputType = {
    id_kabupaten?: true
  }

  export type FacilitatorMinAggregateInputType = {
    id_facilitator?: true
    nama_facilitator?: true
    email_facilitator?: true
    nomor_telepon_facilitator?: true
    password_facilitator?: true
    tanggal_pembuatan_akun?: true
    alamat_lengkap_facilitator?: true
    avatar?: true
    status_aktif?: true
    id_kabupaten?: true
  }

  export type FacilitatorMaxAggregateInputType = {
    id_facilitator?: true
    nama_facilitator?: true
    email_facilitator?: true
    nomor_telepon_facilitator?: true
    password_facilitator?: true
    tanggal_pembuatan_akun?: true
    alamat_lengkap_facilitator?: true
    avatar?: true
    status_aktif?: true
    id_kabupaten?: true
  }

  export type FacilitatorCountAggregateInputType = {
    id_facilitator?: true
    nama_facilitator?: true
    email_facilitator?: true
    nomor_telepon_facilitator?: true
    password_facilitator?: true
    tanggal_pembuatan_akun?: true
    alamat_lengkap_facilitator?: true
    avatar?: true
    status_aktif?: true
    id_kabupaten?: true
    _all?: true
  }

  export type FacilitatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilitator to aggregate.
     */
    where?: FacilitatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilitators to fetch.
     */
    orderBy?: FacilitatorOrderByWithRelationInput | FacilitatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilitatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilitators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilitators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilitators
    **/
    _count?: true | FacilitatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacilitatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacilitatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilitatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilitatorMaxAggregateInputType
  }

  export type GetFacilitatorAggregateType<T extends FacilitatorAggregateArgs> = {
        [P in keyof T & keyof AggregateFacilitator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilitator[P]>
      : GetScalarType<T[P], AggregateFacilitator[P]>
  }




  export type FacilitatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilitatorWhereInput
    orderBy?: FacilitatorOrderByWithAggregationInput | FacilitatorOrderByWithAggregationInput[]
    by: FacilitatorScalarFieldEnum[] | FacilitatorScalarFieldEnum
    having?: FacilitatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilitatorCountAggregateInputType | true
    _avg?: FacilitatorAvgAggregateInputType
    _sum?: FacilitatorSumAggregateInputType
    _min?: FacilitatorMinAggregateInputType
    _max?: FacilitatorMaxAggregateInputType
  }

  export type FacilitatorGroupByOutputType = {
    id_facilitator: string
    nama_facilitator: string
    email_facilitator: string
    nomor_telepon_facilitator: string
    password_facilitator: string
    tanggal_pembuatan_akun: Date
    alamat_lengkap_facilitator: string
    avatar: string | null
    status_aktif: boolean
    id_kabupaten: number
    _count: FacilitatorCountAggregateOutputType | null
    _avg: FacilitatorAvgAggregateOutputType | null
    _sum: FacilitatorSumAggregateOutputType | null
    _min: FacilitatorMinAggregateOutputType | null
    _max: FacilitatorMaxAggregateOutputType | null
  }

  type GetFacilitatorGroupByPayload<T extends FacilitatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilitatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilitatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilitatorGroupByOutputType[P]>
            : GetScalarType<T[P], FacilitatorGroupByOutputType[P]>
        }
      >
    >


  export type FacilitatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_facilitator?: boolean
    nama_facilitator?: boolean
    email_facilitator?: boolean
    nomor_telepon_facilitator?: boolean
    password_facilitator?: boolean
    tanggal_pembuatan_akun?: boolean
    alamat_lengkap_facilitator?: boolean
    avatar?: boolean
    status_aktif?: boolean
    id_kabupaten?: boolean
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
    workshops?: boolean | Facilitator$workshopsArgs<ExtArgs>
    _count?: boolean | FacilitatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilitator"]>

  export type FacilitatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_facilitator?: boolean
    nama_facilitator?: boolean
    email_facilitator?: boolean
    nomor_telepon_facilitator?: boolean
    password_facilitator?: boolean
    tanggal_pembuatan_akun?: boolean
    alamat_lengkap_facilitator?: boolean
    avatar?: boolean
    status_aktif?: boolean
    id_kabupaten?: boolean
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilitator"]>

  export type FacilitatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_facilitator?: boolean
    nama_facilitator?: boolean
    email_facilitator?: boolean
    nomor_telepon_facilitator?: boolean
    password_facilitator?: boolean
    tanggal_pembuatan_akun?: boolean
    alamat_lengkap_facilitator?: boolean
    avatar?: boolean
    status_aktif?: boolean
    id_kabupaten?: boolean
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facilitator"]>

  export type FacilitatorSelectScalar = {
    id_facilitator?: boolean
    nama_facilitator?: boolean
    email_facilitator?: boolean
    nomor_telepon_facilitator?: boolean
    password_facilitator?: boolean
    tanggal_pembuatan_akun?: boolean
    alamat_lengkap_facilitator?: boolean
    avatar?: boolean
    status_aktif?: boolean
    id_kabupaten?: boolean
  }

  export type FacilitatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_facilitator" | "nama_facilitator" | "email_facilitator" | "nomor_telepon_facilitator" | "password_facilitator" | "tanggal_pembuatan_akun" | "alamat_lengkap_facilitator" | "avatar" | "status_aktif" | "id_kabupaten", ExtArgs["result"]["facilitator"]>
  export type FacilitatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
    workshops?: boolean | Facilitator$workshopsArgs<ExtArgs>
    _count?: boolean | FacilitatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacilitatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
  }
  export type FacilitatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
  }

  export type $FacilitatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facilitator"
    objects: {
      kabupaten: Prisma.$KabupatenPayload<ExtArgs>
      workshops: Prisma.$WorkshopPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_facilitator: string
      nama_facilitator: string
      email_facilitator: string
      nomor_telepon_facilitator: string
      password_facilitator: string
      tanggal_pembuatan_akun: Date
      alamat_lengkap_facilitator: string
      avatar: string | null
      status_aktif: boolean
      id_kabupaten: number
    }, ExtArgs["result"]["facilitator"]>
    composites: {}
  }

  type FacilitatorGetPayload<S extends boolean | null | undefined | FacilitatorDefaultArgs> = $Result.GetResult<Prisma.$FacilitatorPayload, S>

  type FacilitatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilitatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilitatorCountAggregateInputType | true
    }

  export interface FacilitatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facilitator'], meta: { name: 'Facilitator' } }
    /**
     * Find zero or one Facilitator that matches the filter.
     * @param {FacilitatorFindUniqueArgs} args - Arguments to find a Facilitator
     * @example
     * // Get one Facilitator
     * const facilitator = await prisma.facilitator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilitatorFindUniqueArgs>(args: SelectSubset<T, FacilitatorFindUniqueArgs<ExtArgs>>): Prisma__FacilitatorClient<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Facilitator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilitatorFindUniqueOrThrowArgs} args - Arguments to find a Facilitator
     * @example
     * // Get one Facilitator
     * const facilitator = await prisma.facilitator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilitatorFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilitatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilitatorClient<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Facilitator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilitatorFindFirstArgs} args - Arguments to find a Facilitator
     * @example
     * // Get one Facilitator
     * const facilitator = await prisma.facilitator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilitatorFindFirstArgs>(args?: SelectSubset<T, FacilitatorFindFirstArgs<ExtArgs>>): Prisma__FacilitatorClient<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Facilitator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilitatorFindFirstOrThrowArgs} args - Arguments to find a Facilitator
     * @example
     * // Get one Facilitator
     * const facilitator = await prisma.facilitator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilitatorFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilitatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilitatorClient<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Facilitators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilitatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilitators
     * const facilitators = await prisma.facilitator.findMany()
     * 
     * // Get first 10 Facilitators
     * const facilitators = await prisma.facilitator.findMany({ take: 10 })
     * 
     * // Only select the `id_facilitator`
     * const facilitatorWithId_facilitatorOnly = await prisma.facilitator.findMany({ select: { id_facilitator: true } })
     * 
     */
    findMany<T extends FacilitatorFindManyArgs>(args?: SelectSubset<T, FacilitatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Facilitator.
     * @param {FacilitatorCreateArgs} args - Arguments to create a Facilitator.
     * @example
     * // Create one Facilitator
     * const Facilitator = await prisma.facilitator.create({
     *   data: {
     *     // ... data to create a Facilitator
     *   }
     * })
     * 
     */
    create<T extends FacilitatorCreateArgs>(args: SelectSubset<T, FacilitatorCreateArgs<ExtArgs>>): Prisma__FacilitatorClient<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Facilitators.
     * @param {FacilitatorCreateManyArgs} args - Arguments to create many Facilitators.
     * @example
     * // Create many Facilitators
     * const facilitator = await prisma.facilitator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilitatorCreateManyArgs>(args?: SelectSubset<T, FacilitatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Facilitators and returns the data saved in the database.
     * @param {FacilitatorCreateManyAndReturnArgs} args - Arguments to create many Facilitators.
     * @example
     * // Create many Facilitators
     * const facilitator = await prisma.facilitator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Facilitators and only return the `id_facilitator`
     * const facilitatorWithId_facilitatorOnly = await prisma.facilitator.createManyAndReturn({
     *   select: { id_facilitator: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacilitatorCreateManyAndReturnArgs>(args?: SelectSubset<T, FacilitatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Facilitator.
     * @param {FacilitatorDeleteArgs} args - Arguments to delete one Facilitator.
     * @example
     * // Delete one Facilitator
     * const Facilitator = await prisma.facilitator.delete({
     *   where: {
     *     // ... filter to delete one Facilitator
     *   }
     * })
     * 
     */
    delete<T extends FacilitatorDeleteArgs>(args: SelectSubset<T, FacilitatorDeleteArgs<ExtArgs>>): Prisma__FacilitatorClient<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Facilitator.
     * @param {FacilitatorUpdateArgs} args - Arguments to update one Facilitator.
     * @example
     * // Update one Facilitator
     * const facilitator = await prisma.facilitator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilitatorUpdateArgs>(args: SelectSubset<T, FacilitatorUpdateArgs<ExtArgs>>): Prisma__FacilitatorClient<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Facilitators.
     * @param {FacilitatorDeleteManyArgs} args - Arguments to filter Facilitators to delete.
     * @example
     * // Delete a few Facilitators
     * const { count } = await prisma.facilitator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilitatorDeleteManyArgs>(args?: SelectSubset<T, FacilitatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilitators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilitatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilitators
     * const facilitator = await prisma.facilitator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilitatorUpdateManyArgs>(args: SelectSubset<T, FacilitatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilitators and returns the data updated in the database.
     * @param {FacilitatorUpdateManyAndReturnArgs} args - Arguments to update many Facilitators.
     * @example
     * // Update many Facilitators
     * const facilitator = await prisma.facilitator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Facilitators and only return the `id_facilitator`
     * const facilitatorWithId_facilitatorOnly = await prisma.facilitator.updateManyAndReturn({
     *   select: { id_facilitator: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacilitatorUpdateManyAndReturnArgs>(args: SelectSubset<T, FacilitatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Facilitator.
     * @param {FacilitatorUpsertArgs} args - Arguments to update or create a Facilitator.
     * @example
     * // Update or create a Facilitator
     * const facilitator = await prisma.facilitator.upsert({
     *   create: {
     *     // ... data to create a Facilitator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facilitator we want to update
     *   }
     * })
     */
    upsert<T extends FacilitatorUpsertArgs>(args: SelectSubset<T, FacilitatorUpsertArgs<ExtArgs>>): Prisma__FacilitatorClient<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Facilitators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilitatorCountArgs} args - Arguments to filter Facilitators to count.
     * @example
     * // Count the number of Facilitators
     * const count = await prisma.facilitator.count({
     *   where: {
     *     // ... the filter for the Facilitators we want to count
     *   }
     * })
    **/
    count<T extends FacilitatorCountArgs>(
      args?: Subset<T, FacilitatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilitatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facilitator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilitatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilitatorAggregateArgs>(args: Subset<T, FacilitatorAggregateArgs>): Prisma.PrismaPromise<GetFacilitatorAggregateType<T>>

    /**
     * Group by Facilitator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilitatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilitatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilitatorGroupByArgs['orderBy'] }
        : { orderBy?: FacilitatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilitatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilitatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facilitator model
   */
  readonly fields: FacilitatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facilitator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilitatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kabupaten<T extends KabupatenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KabupatenDefaultArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workshops<T extends Facilitator$workshopsArgs<ExtArgs> = {}>(args?: Subset<T, Facilitator$workshopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Facilitator model
   */
  interface FacilitatorFieldRefs {
    readonly id_facilitator: FieldRef<"Facilitator", 'String'>
    readonly nama_facilitator: FieldRef<"Facilitator", 'String'>
    readonly email_facilitator: FieldRef<"Facilitator", 'String'>
    readonly nomor_telepon_facilitator: FieldRef<"Facilitator", 'String'>
    readonly password_facilitator: FieldRef<"Facilitator", 'String'>
    readonly tanggal_pembuatan_akun: FieldRef<"Facilitator", 'DateTime'>
    readonly alamat_lengkap_facilitator: FieldRef<"Facilitator", 'String'>
    readonly avatar: FieldRef<"Facilitator", 'String'>
    readonly status_aktif: FieldRef<"Facilitator", 'Boolean'>
    readonly id_kabupaten: FieldRef<"Facilitator", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Facilitator findUnique
   */
  export type FacilitatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    /**
     * Filter, which Facilitator to fetch.
     */
    where: FacilitatorWhereUniqueInput
  }

  /**
   * Facilitator findUniqueOrThrow
   */
  export type FacilitatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    /**
     * Filter, which Facilitator to fetch.
     */
    where: FacilitatorWhereUniqueInput
  }

  /**
   * Facilitator findFirst
   */
  export type FacilitatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    /**
     * Filter, which Facilitator to fetch.
     */
    where?: FacilitatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilitators to fetch.
     */
    orderBy?: FacilitatorOrderByWithRelationInput | FacilitatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilitators.
     */
    cursor?: FacilitatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilitators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilitators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilitators.
     */
    distinct?: FacilitatorScalarFieldEnum | FacilitatorScalarFieldEnum[]
  }

  /**
   * Facilitator findFirstOrThrow
   */
  export type FacilitatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    /**
     * Filter, which Facilitator to fetch.
     */
    where?: FacilitatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilitators to fetch.
     */
    orderBy?: FacilitatorOrderByWithRelationInput | FacilitatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilitators.
     */
    cursor?: FacilitatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilitators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilitators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilitators.
     */
    distinct?: FacilitatorScalarFieldEnum | FacilitatorScalarFieldEnum[]
  }

  /**
   * Facilitator findMany
   */
  export type FacilitatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    /**
     * Filter, which Facilitators to fetch.
     */
    where?: FacilitatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilitators to fetch.
     */
    orderBy?: FacilitatorOrderByWithRelationInput | FacilitatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilitators.
     */
    cursor?: FacilitatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilitators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilitators.
     */
    skip?: number
    distinct?: FacilitatorScalarFieldEnum | FacilitatorScalarFieldEnum[]
  }

  /**
   * Facilitator create
   */
  export type FacilitatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    /**
     * The data needed to create a Facilitator.
     */
    data: XOR<FacilitatorCreateInput, FacilitatorUncheckedCreateInput>
  }

  /**
   * Facilitator createMany
   */
  export type FacilitatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facilitators.
     */
    data: FacilitatorCreateManyInput | FacilitatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facilitator createManyAndReturn
   */
  export type FacilitatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * The data used to create many Facilitators.
     */
    data: FacilitatorCreateManyInput | FacilitatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Facilitator update
   */
  export type FacilitatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    /**
     * The data needed to update a Facilitator.
     */
    data: XOR<FacilitatorUpdateInput, FacilitatorUncheckedUpdateInput>
    /**
     * Choose, which Facilitator to update.
     */
    where: FacilitatorWhereUniqueInput
  }

  /**
   * Facilitator updateMany
   */
  export type FacilitatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facilitators.
     */
    data: XOR<FacilitatorUpdateManyMutationInput, FacilitatorUncheckedUpdateManyInput>
    /**
     * Filter which Facilitators to update
     */
    where?: FacilitatorWhereInput
    /**
     * Limit how many Facilitators to update.
     */
    limit?: number
  }

  /**
   * Facilitator updateManyAndReturn
   */
  export type FacilitatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * The data used to update Facilitators.
     */
    data: XOR<FacilitatorUpdateManyMutationInput, FacilitatorUncheckedUpdateManyInput>
    /**
     * Filter which Facilitators to update
     */
    where?: FacilitatorWhereInput
    /**
     * Limit how many Facilitators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Facilitator upsert
   */
  export type FacilitatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    /**
     * The filter to search for the Facilitator to update in case it exists.
     */
    where: FacilitatorWhereUniqueInput
    /**
     * In case the Facilitator found by the `where` argument doesn't exist, create a new Facilitator with this data.
     */
    create: XOR<FacilitatorCreateInput, FacilitatorUncheckedCreateInput>
    /**
     * In case the Facilitator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilitatorUpdateInput, FacilitatorUncheckedUpdateInput>
  }

  /**
   * Facilitator delete
   */
  export type FacilitatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
    /**
     * Filter which Facilitator to delete.
     */
    where: FacilitatorWhereUniqueInput
  }

  /**
   * Facilitator deleteMany
   */
  export type FacilitatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilitators to delete
     */
    where?: FacilitatorWhereInput
    /**
     * Limit how many Facilitators to delete.
     */
    limit?: number
  }

  /**
   * Facilitator.workshops
   */
  export type Facilitator$workshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    where?: WorkshopWhereInput
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    cursor?: WorkshopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Facilitator without action
   */
  export type FacilitatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facilitator
     */
    select?: FacilitatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facilitator
     */
    omit?: FacilitatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilitatorInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id_admin: string | null
    nama_depan_admin: string | null
    nama_belakang_admin: string | null
    email_admin: string | null
    password_admin: string | null
    tanggal_pembuatan_akun: Date | null
    avatar: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id_admin: string | null
    nama_depan_admin: string | null
    nama_belakang_admin: string | null
    email_admin: string | null
    password_admin: string | null
    tanggal_pembuatan_akun: Date | null
    avatar: string | null
  }

  export type AdminCountAggregateOutputType = {
    id_admin: number
    nama_depan_admin: number
    nama_belakang_admin: number
    email_admin: number
    password_admin: number
    tanggal_pembuatan_akun: number
    avatar: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id_admin?: true
    nama_depan_admin?: true
    nama_belakang_admin?: true
    email_admin?: true
    password_admin?: true
    tanggal_pembuatan_akun?: true
    avatar?: true
  }

  export type AdminMaxAggregateInputType = {
    id_admin?: true
    nama_depan_admin?: true
    nama_belakang_admin?: true
    email_admin?: true
    password_admin?: true
    tanggal_pembuatan_akun?: true
    avatar?: true
  }

  export type AdminCountAggregateInputType = {
    id_admin?: true
    nama_depan_admin?: true
    nama_belakang_admin?: true
    email_admin?: true
    password_admin?: true
    tanggal_pembuatan_akun?: true
    avatar?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id_admin: string
    nama_depan_admin: string
    nama_belakang_admin: string
    email_admin: string
    password_admin: string
    tanggal_pembuatan_akun: Date
    avatar: string | null
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_admin?: boolean
    nama_depan_admin?: boolean
    nama_belakang_admin?: boolean
    email_admin?: boolean
    password_admin?: boolean
    tanggal_pembuatan_akun?: boolean
    avatar?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_admin?: boolean
    nama_depan_admin?: boolean
    nama_belakang_admin?: boolean
    email_admin?: boolean
    password_admin?: boolean
    tanggal_pembuatan_akun?: boolean
    avatar?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_admin?: boolean
    nama_depan_admin?: boolean
    nama_belakang_admin?: boolean
    email_admin?: boolean
    password_admin?: boolean
    tanggal_pembuatan_akun?: boolean
    avatar?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id_admin?: boolean
    nama_depan_admin?: boolean
    nama_belakang_admin?: boolean
    email_admin?: boolean
    password_admin?: boolean
    tanggal_pembuatan_akun?: boolean
    avatar?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_admin" | "nama_depan_admin" | "nama_belakang_admin" | "email_admin" | "password_admin" | "tanggal_pembuatan_akun" | "avatar", ExtArgs["result"]["admin"]>

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_admin: string
      nama_depan_admin: string
      nama_belakang_admin: string
      email_admin: string
      password_admin: string
      tanggal_pembuatan_akun: Date
      avatar: string | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id_admin`
     * const adminWithId_adminOnly = await prisma.admin.findMany({ select: { id_admin: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id_admin`
     * const adminWithId_adminOnly = await prisma.admin.createManyAndReturn({
     *   select: { id_admin: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id_admin`
     * const adminWithId_adminOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id_admin: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id_admin: FieldRef<"Admin", 'String'>
    readonly nama_depan_admin: FieldRef<"Admin", 'String'>
    readonly nama_belakang_admin: FieldRef<"Admin", 'String'>
    readonly email_admin: FieldRef<"Admin", 'String'>
    readonly password_admin: FieldRef<"Admin", 'String'>
    readonly tanggal_pembuatan_akun: FieldRef<"Admin", 'DateTime'>
    readonly avatar: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
  }


  /**
   * Model Artikel
   */

  export type AggregateArtikel = {
    _count: ArtikelCountAggregateOutputType | null
    _avg: ArtikelAvgAggregateOutputType | null
    _sum: ArtikelSumAggregateOutputType | null
    _min: ArtikelMinAggregateOutputType | null
    _max: ArtikelMaxAggregateOutputType | null
  }

  export type ArtikelAvgAggregateOutputType = {
    id_kategori_artikel: number | null
  }

  export type ArtikelSumAggregateOutputType = {
    id_kategori_artikel: number | null
  }

  export type ArtikelMinAggregateOutputType = {
    id_artikel: string | null
    judul_artikel: string | null
    tanggal_artikel: Date | null
    deskripsi_artikel: string | null
    isi_artikel: string | null
    status_artikel: $Enums.StatusArtikel | null
    status_verifikasi: boolean | null
    gambar_artikel: string | null
    status_aktif: boolean | null
    id_kategori_artikel: number | null
    id_pengguna: string | null
  }

  export type ArtikelMaxAggregateOutputType = {
    id_artikel: string | null
    judul_artikel: string | null
    tanggal_artikel: Date | null
    deskripsi_artikel: string | null
    isi_artikel: string | null
    status_artikel: $Enums.StatusArtikel | null
    status_verifikasi: boolean | null
    gambar_artikel: string | null
    status_aktif: boolean | null
    id_kategori_artikel: number | null
    id_pengguna: string | null
  }

  export type ArtikelCountAggregateOutputType = {
    id_artikel: number
    judul_artikel: number
    tanggal_artikel: number
    deskripsi_artikel: number
    isi_artikel: number
    status_artikel: number
    status_verifikasi: number
    gambar_artikel: number
    status_aktif: number
    id_kategori_artikel: number
    id_pengguna: number
    _all: number
  }


  export type ArtikelAvgAggregateInputType = {
    id_kategori_artikel?: true
  }

  export type ArtikelSumAggregateInputType = {
    id_kategori_artikel?: true
  }

  export type ArtikelMinAggregateInputType = {
    id_artikel?: true
    judul_artikel?: true
    tanggal_artikel?: true
    deskripsi_artikel?: true
    isi_artikel?: true
    status_artikel?: true
    status_verifikasi?: true
    gambar_artikel?: true
    status_aktif?: true
    id_kategori_artikel?: true
    id_pengguna?: true
  }

  export type ArtikelMaxAggregateInputType = {
    id_artikel?: true
    judul_artikel?: true
    tanggal_artikel?: true
    deskripsi_artikel?: true
    isi_artikel?: true
    status_artikel?: true
    status_verifikasi?: true
    gambar_artikel?: true
    status_aktif?: true
    id_kategori_artikel?: true
    id_pengguna?: true
  }

  export type ArtikelCountAggregateInputType = {
    id_artikel?: true
    judul_artikel?: true
    tanggal_artikel?: true
    deskripsi_artikel?: true
    isi_artikel?: true
    status_artikel?: true
    status_verifikasi?: true
    gambar_artikel?: true
    status_aktif?: true
    id_kategori_artikel?: true
    id_pengguna?: true
    _all?: true
  }

  export type ArtikelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artikel to aggregate.
     */
    where?: ArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artikels to fetch.
     */
    orderBy?: ArtikelOrderByWithRelationInput | ArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artikels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Artikels
    **/
    _count?: true | ArtikelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtikelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtikelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtikelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtikelMaxAggregateInputType
  }

  export type GetArtikelAggregateType<T extends ArtikelAggregateArgs> = {
        [P in keyof T & keyof AggregateArtikel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtikel[P]>
      : GetScalarType<T[P], AggregateArtikel[P]>
  }




  export type ArtikelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtikelWhereInput
    orderBy?: ArtikelOrderByWithAggregationInput | ArtikelOrderByWithAggregationInput[]
    by: ArtikelScalarFieldEnum[] | ArtikelScalarFieldEnum
    having?: ArtikelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtikelCountAggregateInputType | true
    _avg?: ArtikelAvgAggregateInputType
    _sum?: ArtikelSumAggregateInputType
    _min?: ArtikelMinAggregateInputType
    _max?: ArtikelMaxAggregateInputType
  }

  export type ArtikelGroupByOutputType = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel: Date
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi: boolean
    gambar_artikel: string
    status_aktif: boolean
    id_kategori_artikel: number
    id_pengguna: string
    _count: ArtikelCountAggregateOutputType | null
    _avg: ArtikelAvgAggregateOutputType | null
    _sum: ArtikelSumAggregateOutputType | null
    _min: ArtikelMinAggregateOutputType | null
    _max: ArtikelMaxAggregateOutputType | null
  }

  type GetArtikelGroupByPayload<T extends ArtikelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtikelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtikelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtikelGroupByOutputType[P]>
            : GetScalarType<T[P], ArtikelGroupByOutputType[P]>
        }
      >
    >


  export type ArtikelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_artikel?: boolean
    judul_artikel?: boolean
    tanggal_artikel?: boolean
    deskripsi_artikel?: boolean
    isi_artikel?: boolean
    status_artikel?: boolean
    status_verifikasi?: boolean
    gambar_artikel?: boolean
    status_aktif?: boolean
    id_kategori_artikel?: boolean
    id_pengguna?: boolean
    kategori?: boolean | KategoriArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    artikel_disimpan?: boolean | Artikel$artikel_disimpanArgs<ExtArgs>
    artikel_disukai?: boolean | Artikel$artikel_disukaiArgs<ExtArgs>
    komentar_artikel?: boolean | Artikel$komentar_artikelArgs<ExtArgs>
    _count?: boolean | ArtikelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artikel"]>

  export type ArtikelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_artikel?: boolean
    judul_artikel?: boolean
    tanggal_artikel?: boolean
    deskripsi_artikel?: boolean
    isi_artikel?: boolean
    status_artikel?: boolean
    status_verifikasi?: boolean
    gambar_artikel?: boolean
    status_aktif?: boolean
    id_kategori_artikel?: boolean
    id_pengguna?: boolean
    kategori?: boolean | KategoriArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artikel"]>

  export type ArtikelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_artikel?: boolean
    judul_artikel?: boolean
    tanggal_artikel?: boolean
    deskripsi_artikel?: boolean
    isi_artikel?: boolean
    status_artikel?: boolean
    status_verifikasi?: boolean
    gambar_artikel?: boolean
    status_aktif?: boolean
    id_kategori_artikel?: boolean
    id_pengguna?: boolean
    kategori?: boolean | KategoriArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artikel"]>

  export type ArtikelSelectScalar = {
    id_artikel?: boolean
    judul_artikel?: boolean
    tanggal_artikel?: boolean
    deskripsi_artikel?: boolean
    isi_artikel?: boolean
    status_artikel?: boolean
    status_verifikasi?: boolean
    gambar_artikel?: boolean
    status_aktif?: boolean
    id_kategori_artikel?: boolean
    id_pengguna?: boolean
  }

  export type ArtikelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_artikel" | "judul_artikel" | "tanggal_artikel" | "deskripsi_artikel" | "isi_artikel" | "status_artikel" | "status_verifikasi" | "gambar_artikel" | "status_aktif" | "id_kategori_artikel" | "id_pengguna", ExtArgs["result"]["artikel"]>
  export type ArtikelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kategori?: boolean | KategoriArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    artikel_disimpan?: boolean | Artikel$artikel_disimpanArgs<ExtArgs>
    artikel_disukai?: boolean | Artikel$artikel_disukaiArgs<ExtArgs>
    komentar_artikel?: boolean | Artikel$komentar_artikelArgs<ExtArgs>
    _count?: boolean | ArtikelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArtikelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kategori?: boolean | KategoriArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }
  export type ArtikelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kategori?: boolean | KategoriArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }

  export type $ArtikelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Artikel"
    objects: {
      kategori: Prisma.$KategoriArtikelPayload<ExtArgs>
      pengguna: Prisma.$PenggunaPayload<ExtArgs>
      artikel_disimpan: Prisma.$ArtikelDisimpanPayload<ExtArgs>[]
      artikel_disukai: Prisma.$ArtikelDisukaiPayload<ExtArgs>[]
      komentar_artikel: Prisma.$KomentarArtikelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_artikel: string
      judul_artikel: string
      tanggal_artikel: Date
      deskripsi_artikel: string
      isi_artikel: string
      status_artikel: $Enums.StatusArtikel
      status_verifikasi: boolean
      gambar_artikel: string
      status_aktif: boolean
      id_kategori_artikel: number
      id_pengguna: string
    }, ExtArgs["result"]["artikel"]>
    composites: {}
  }

  type ArtikelGetPayload<S extends boolean | null | undefined | ArtikelDefaultArgs> = $Result.GetResult<Prisma.$ArtikelPayload, S>

  type ArtikelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtikelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtikelCountAggregateInputType | true
    }

  export interface ArtikelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artikel'], meta: { name: 'Artikel' } }
    /**
     * Find zero or one Artikel that matches the filter.
     * @param {ArtikelFindUniqueArgs} args - Arguments to find a Artikel
     * @example
     * // Get one Artikel
     * const artikel = await prisma.artikel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtikelFindUniqueArgs>(args: SelectSubset<T, ArtikelFindUniqueArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artikel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtikelFindUniqueOrThrowArgs} args - Arguments to find a Artikel
     * @example
     * // Get one Artikel
     * const artikel = await prisma.artikel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtikelFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtikelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artikel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelFindFirstArgs} args - Arguments to find a Artikel
     * @example
     * // Get one Artikel
     * const artikel = await prisma.artikel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtikelFindFirstArgs>(args?: SelectSubset<T, ArtikelFindFirstArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artikel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelFindFirstOrThrowArgs} args - Arguments to find a Artikel
     * @example
     * // Get one Artikel
     * const artikel = await prisma.artikel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtikelFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtikelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artikels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artikels
     * const artikels = await prisma.artikel.findMany()
     * 
     * // Get first 10 Artikels
     * const artikels = await prisma.artikel.findMany({ take: 10 })
     * 
     * // Only select the `id_artikel`
     * const artikelWithId_artikelOnly = await prisma.artikel.findMany({ select: { id_artikel: true } })
     * 
     */
    findMany<T extends ArtikelFindManyArgs>(args?: SelectSubset<T, ArtikelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artikel.
     * @param {ArtikelCreateArgs} args - Arguments to create a Artikel.
     * @example
     * // Create one Artikel
     * const Artikel = await prisma.artikel.create({
     *   data: {
     *     // ... data to create a Artikel
     *   }
     * })
     * 
     */
    create<T extends ArtikelCreateArgs>(args: SelectSubset<T, ArtikelCreateArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artikels.
     * @param {ArtikelCreateManyArgs} args - Arguments to create many Artikels.
     * @example
     * // Create many Artikels
     * const artikel = await prisma.artikel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtikelCreateManyArgs>(args?: SelectSubset<T, ArtikelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artikels and returns the data saved in the database.
     * @param {ArtikelCreateManyAndReturnArgs} args - Arguments to create many Artikels.
     * @example
     * // Create many Artikels
     * const artikel = await prisma.artikel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artikels and only return the `id_artikel`
     * const artikelWithId_artikelOnly = await prisma.artikel.createManyAndReturn({
     *   select: { id_artikel: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtikelCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtikelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artikel.
     * @param {ArtikelDeleteArgs} args - Arguments to delete one Artikel.
     * @example
     * // Delete one Artikel
     * const Artikel = await prisma.artikel.delete({
     *   where: {
     *     // ... filter to delete one Artikel
     *   }
     * })
     * 
     */
    delete<T extends ArtikelDeleteArgs>(args: SelectSubset<T, ArtikelDeleteArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artikel.
     * @param {ArtikelUpdateArgs} args - Arguments to update one Artikel.
     * @example
     * // Update one Artikel
     * const artikel = await prisma.artikel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtikelUpdateArgs>(args: SelectSubset<T, ArtikelUpdateArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artikels.
     * @param {ArtikelDeleteManyArgs} args - Arguments to filter Artikels to delete.
     * @example
     * // Delete a few Artikels
     * const { count } = await prisma.artikel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtikelDeleteManyArgs>(args?: SelectSubset<T, ArtikelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artikels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artikels
     * const artikel = await prisma.artikel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtikelUpdateManyArgs>(args: SelectSubset<T, ArtikelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artikels and returns the data updated in the database.
     * @param {ArtikelUpdateManyAndReturnArgs} args - Arguments to update many Artikels.
     * @example
     * // Update many Artikels
     * const artikel = await prisma.artikel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Artikels and only return the `id_artikel`
     * const artikelWithId_artikelOnly = await prisma.artikel.updateManyAndReturn({
     *   select: { id_artikel: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtikelUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtikelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artikel.
     * @param {ArtikelUpsertArgs} args - Arguments to update or create a Artikel.
     * @example
     * // Update or create a Artikel
     * const artikel = await prisma.artikel.upsert({
     *   create: {
     *     // ... data to create a Artikel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artikel we want to update
     *   }
     * })
     */
    upsert<T extends ArtikelUpsertArgs>(args: SelectSubset<T, ArtikelUpsertArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Artikels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelCountArgs} args - Arguments to filter Artikels to count.
     * @example
     * // Count the number of Artikels
     * const count = await prisma.artikel.count({
     *   where: {
     *     // ... the filter for the Artikels we want to count
     *   }
     * })
    **/
    count<T extends ArtikelCountArgs>(
      args?: Subset<T, ArtikelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtikelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artikel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtikelAggregateArgs>(args: Subset<T, ArtikelAggregateArgs>): Prisma.PrismaPromise<GetArtikelAggregateType<T>>

    /**
     * Group by Artikel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtikelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtikelGroupByArgs['orderBy'] }
        : { orderBy?: ArtikelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtikelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtikelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Artikel model
   */
  readonly fields: ArtikelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artikel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtikelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kategori<T extends KategoriArtikelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KategoriArtikelDefaultArgs<ExtArgs>>): Prisma__KategoriArtikelClient<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pengguna<T extends PenggunaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PenggunaDefaultArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artikel_disimpan<T extends Artikel$artikel_disimpanArgs<ExtArgs> = {}>(args?: Subset<T, Artikel$artikel_disimpanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artikel_disukai<T extends Artikel$artikel_disukaiArgs<ExtArgs> = {}>(args?: Subset<T, Artikel$artikel_disukaiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    komentar_artikel<T extends Artikel$komentar_artikelArgs<ExtArgs> = {}>(args?: Subset<T, Artikel$komentar_artikelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Artikel model
   */
  interface ArtikelFieldRefs {
    readonly id_artikel: FieldRef<"Artikel", 'String'>
    readonly judul_artikel: FieldRef<"Artikel", 'String'>
    readonly tanggal_artikel: FieldRef<"Artikel", 'DateTime'>
    readonly deskripsi_artikel: FieldRef<"Artikel", 'String'>
    readonly isi_artikel: FieldRef<"Artikel", 'String'>
    readonly status_artikel: FieldRef<"Artikel", 'StatusArtikel'>
    readonly status_verifikasi: FieldRef<"Artikel", 'Boolean'>
    readonly gambar_artikel: FieldRef<"Artikel", 'String'>
    readonly status_aktif: FieldRef<"Artikel", 'Boolean'>
    readonly id_kategori_artikel: FieldRef<"Artikel", 'Int'>
    readonly id_pengguna: FieldRef<"Artikel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Artikel findUnique
   */
  export type ArtikelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    /**
     * Filter, which Artikel to fetch.
     */
    where: ArtikelWhereUniqueInput
  }

  /**
   * Artikel findUniqueOrThrow
   */
  export type ArtikelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    /**
     * Filter, which Artikel to fetch.
     */
    where: ArtikelWhereUniqueInput
  }

  /**
   * Artikel findFirst
   */
  export type ArtikelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    /**
     * Filter, which Artikel to fetch.
     */
    where?: ArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artikels to fetch.
     */
    orderBy?: ArtikelOrderByWithRelationInput | ArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artikels.
     */
    cursor?: ArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artikels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artikels.
     */
    distinct?: ArtikelScalarFieldEnum | ArtikelScalarFieldEnum[]
  }

  /**
   * Artikel findFirstOrThrow
   */
  export type ArtikelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    /**
     * Filter, which Artikel to fetch.
     */
    where?: ArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artikels to fetch.
     */
    orderBy?: ArtikelOrderByWithRelationInput | ArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artikels.
     */
    cursor?: ArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artikels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artikels.
     */
    distinct?: ArtikelScalarFieldEnum | ArtikelScalarFieldEnum[]
  }

  /**
   * Artikel findMany
   */
  export type ArtikelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    /**
     * Filter, which Artikels to fetch.
     */
    where?: ArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artikels to fetch.
     */
    orderBy?: ArtikelOrderByWithRelationInput | ArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Artikels.
     */
    cursor?: ArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artikels.
     */
    skip?: number
    distinct?: ArtikelScalarFieldEnum | ArtikelScalarFieldEnum[]
  }

  /**
   * Artikel create
   */
  export type ArtikelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    /**
     * The data needed to create a Artikel.
     */
    data: XOR<ArtikelCreateInput, ArtikelUncheckedCreateInput>
  }

  /**
   * Artikel createMany
   */
  export type ArtikelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artikels.
     */
    data: ArtikelCreateManyInput | ArtikelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Artikel createManyAndReturn
   */
  export type ArtikelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * The data used to create many Artikels.
     */
    data: ArtikelCreateManyInput | ArtikelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artikel update
   */
  export type ArtikelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    /**
     * The data needed to update a Artikel.
     */
    data: XOR<ArtikelUpdateInput, ArtikelUncheckedUpdateInput>
    /**
     * Choose, which Artikel to update.
     */
    where: ArtikelWhereUniqueInput
  }

  /**
   * Artikel updateMany
   */
  export type ArtikelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Artikels.
     */
    data: XOR<ArtikelUpdateManyMutationInput, ArtikelUncheckedUpdateManyInput>
    /**
     * Filter which Artikels to update
     */
    where?: ArtikelWhereInput
    /**
     * Limit how many Artikels to update.
     */
    limit?: number
  }

  /**
   * Artikel updateManyAndReturn
   */
  export type ArtikelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * The data used to update Artikels.
     */
    data: XOR<ArtikelUpdateManyMutationInput, ArtikelUncheckedUpdateManyInput>
    /**
     * Filter which Artikels to update
     */
    where?: ArtikelWhereInput
    /**
     * Limit how many Artikels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artikel upsert
   */
  export type ArtikelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    /**
     * The filter to search for the Artikel to update in case it exists.
     */
    where: ArtikelWhereUniqueInput
    /**
     * In case the Artikel found by the `where` argument doesn't exist, create a new Artikel with this data.
     */
    create: XOR<ArtikelCreateInput, ArtikelUncheckedCreateInput>
    /**
     * In case the Artikel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtikelUpdateInput, ArtikelUncheckedUpdateInput>
  }

  /**
   * Artikel delete
   */
  export type ArtikelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    /**
     * Filter which Artikel to delete.
     */
    where: ArtikelWhereUniqueInput
  }

  /**
   * Artikel deleteMany
   */
  export type ArtikelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artikels to delete
     */
    where?: ArtikelWhereInput
    /**
     * Limit how many Artikels to delete.
     */
    limit?: number
  }

  /**
   * Artikel.artikel_disimpan
   */
  export type Artikel$artikel_disimpanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    where?: ArtikelDisimpanWhereInput
    orderBy?: ArtikelDisimpanOrderByWithRelationInput | ArtikelDisimpanOrderByWithRelationInput[]
    cursor?: ArtikelDisimpanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtikelDisimpanScalarFieldEnum | ArtikelDisimpanScalarFieldEnum[]
  }

  /**
   * Artikel.artikel_disukai
   */
  export type Artikel$artikel_disukaiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    where?: ArtikelDisukaiWhereInput
    orderBy?: ArtikelDisukaiOrderByWithRelationInput | ArtikelDisukaiOrderByWithRelationInput[]
    cursor?: ArtikelDisukaiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtikelDisukaiScalarFieldEnum | ArtikelDisukaiScalarFieldEnum[]
  }

  /**
   * Artikel.komentar_artikel
   */
  export type Artikel$komentar_artikelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    where?: KomentarArtikelWhereInput
    orderBy?: KomentarArtikelOrderByWithRelationInput | KomentarArtikelOrderByWithRelationInput[]
    cursor?: KomentarArtikelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KomentarArtikelScalarFieldEnum | KomentarArtikelScalarFieldEnum[]
  }

  /**
   * Artikel without action
   */
  export type ArtikelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
  }


  /**
   * Model KategoriArtikel
   */

  export type AggregateKategoriArtikel = {
    _count: KategoriArtikelCountAggregateOutputType | null
    _avg: KategoriArtikelAvgAggregateOutputType | null
    _sum: KategoriArtikelSumAggregateOutputType | null
    _min: KategoriArtikelMinAggregateOutputType | null
    _max: KategoriArtikelMaxAggregateOutputType | null
  }

  export type KategoriArtikelAvgAggregateOutputType = {
    id_kategori_artikel: number | null
  }

  export type KategoriArtikelSumAggregateOutputType = {
    id_kategori_artikel: number | null
  }

  export type KategoriArtikelMinAggregateOutputType = {
    id_kategori_artikel: number | null
    nama_kategori_artikel: string | null
  }

  export type KategoriArtikelMaxAggregateOutputType = {
    id_kategori_artikel: number | null
    nama_kategori_artikel: string | null
  }

  export type KategoriArtikelCountAggregateOutputType = {
    id_kategori_artikel: number
    nama_kategori_artikel: number
    _all: number
  }


  export type KategoriArtikelAvgAggregateInputType = {
    id_kategori_artikel?: true
  }

  export type KategoriArtikelSumAggregateInputType = {
    id_kategori_artikel?: true
  }

  export type KategoriArtikelMinAggregateInputType = {
    id_kategori_artikel?: true
    nama_kategori_artikel?: true
  }

  export type KategoriArtikelMaxAggregateInputType = {
    id_kategori_artikel?: true
    nama_kategori_artikel?: true
  }

  export type KategoriArtikelCountAggregateInputType = {
    id_kategori_artikel?: true
    nama_kategori_artikel?: true
    _all?: true
  }

  export type KategoriArtikelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KategoriArtikel to aggregate.
     */
    where?: KategoriArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KategoriArtikels to fetch.
     */
    orderBy?: KategoriArtikelOrderByWithRelationInput | KategoriArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KategoriArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KategoriArtikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KategoriArtikels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KategoriArtikels
    **/
    _count?: true | KategoriArtikelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KategoriArtikelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KategoriArtikelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KategoriArtikelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KategoriArtikelMaxAggregateInputType
  }

  export type GetKategoriArtikelAggregateType<T extends KategoriArtikelAggregateArgs> = {
        [P in keyof T & keyof AggregateKategoriArtikel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKategoriArtikel[P]>
      : GetScalarType<T[P], AggregateKategoriArtikel[P]>
  }




  export type KategoriArtikelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KategoriArtikelWhereInput
    orderBy?: KategoriArtikelOrderByWithAggregationInput | KategoriArtikelOrderByWithAggregationInput[]
    by: KategoriArtikelScalarFieldEnum[] | KategoriArtikelScalarFieldEnum
    having?: KategoriArtikelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KategoriArtikelCountAggregateInputType | true
    _avg?: KategoriArtikelAvgAggregateInputType
    _sum?: KategoriArtikelSumAggregateInputType
    _min?: KategoriArtikelMinAggregateInputType
    _max?: KategoriArtikelMaxAggregateInputType
  }

  export type KategoriArtikelGroupByOutputType = {
    id_kategori_artikel: number
    nama_kategori_artikel: string
    _count: KategoriArtikelCountAggregateOutputType | null
    _avg: KategoriArtikelAvgAggregateOutputType | null
    _sum: KategoriArtikelSumAggregateOutputType | null
    _min: KategoriArtikelMinAggregateOutputType | null
    _max: KategoriArtikelMaxAggregateOutputType | null
  }

  type GetKategoriArtikelGroupByPayload<T extends KategoriArtikelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KategoriArtikelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KategoriArtikelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KategoriArtikelGroupByOutputType[P]>
            : GetScalarType<T[P], KategoriArtikelGroupByOutputType[P]>
        }
      >
    >


  export type KategoriArtikelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kategori_artikel?: boolean
    nama_kategori_artikel?: boolean
    artikel?: boolean | KategoriArtikel$artikelArgs<ExtArgs>
    _count?: boolean | KategoriArtikelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kategoriArtikel"]>

  export type KategoriArtikelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kategori_artikel?: boolean
    nama_kategori_artikel?: boolean
  }, ExtArgs["result"]["kategoriArtikel"]>

  export type KategoriArtikelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kategori_artikel?: boolean
    nama_kategori_artikel?: boolean
  }, ExtArgs["result"]["kategoriArtikel"]>

  export type KategoriArtikelSelectScalar = {
    id_kategori_artikel?: boolean
    nama_kategori_artikel?: boolean
  }

  export type KategoriArtikelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_kategori_artikel" | "nama_kategori_artikel", ExtArgs["result"]["kategoriArtikel"]>
  export type KategoriArtikelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | KategoriArtikel$artikelArgs<ExtArgs>
    _count?: boolean | KategoriArtikelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KategoriArtikelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type KategoriArtikelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KategoriArtikelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KategoriArtikel"
    objects: {
      artikel: Prisma.$ArtikelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_kategori_artikel: number
      nama_kategori_artikel: string
    }, ExtArgs["result"]["kategoriArtikel"]>
    composites: {}
  }

  type KategoriArtikelGetPayload<S extends boolean | null | undefined | KategoriArtikelDefaultArgs> = $Result.GetResult<Prisma.$KategoriArtikelPayload, S>

  type KategoriArtikelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KategoriArtikelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KategoriArtikelCountAggregateInputType | true
    }

  export interface KategoriArtikelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KategoriArtikel'], meta: { name: 'KategoriArtikel' } }
    /**
     * Find zero or one KategoriArtikel that matches the filter.
     * @param {KategoriArtikelFindUniqueArgs} args - Arguments to find a KategoriArtikel
     * @example
     * // Get one KategoriArtikel
     * const kategoriArtikel = await prisma.kategoriArtikel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KategoriArtikelFindUniqueArgs>(args: SelectSubset<T, KategoriArtikelFindUniqueArgs<ExtArgs>>): Prisma__KategoriArtikelClient<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KategoriArtikel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KategoriArtikelFindUniqueOrThrowArgs} args - Arguments to find a KategoriArtikel
     * @example
     * // Get one KategoriArtikel
     * const kategoriArtikel = await prisma.kategoriArtikel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KategoriArtikelFindUniqueOrThrowArgs>(args: SelectSubset<T, KategoriArtikelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KategoriArtikelClient<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KategoriArtikel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategoriArtikelFindFirstArgs} args - Arguments to find a KategoriArtikel
     * @example
     * // Get one KategoriArtikel
     * const kategoriArtikel = await prisma.kategoriArtikel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KategoriArtikelFindFirstArgs>(args?: SelectSubset<T, KategoriArtikelFindFirstArgs<ExtArgs>>): Prisma__KategoriArtikelClient<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KategoriArtikel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategoriArtikelFindFirstOrThrowArgs} args - Arguments to find a KategoriArtikel
     * @example
     * // Get one KategoriArtikel
     * const kategoriArtikel = await prisma.kategoriArtikel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KategoriArtikelFindFirstOrThrowArgs>(args?: SelectSubset<T, KategoriArtikelFindFirstOrThrowArgs<ExtArgs>>): Prisma__KategoriArtikelClient<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KategoriArtikels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategoriArtikelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KategoriArtikels
     * const kategoriArtikels = await prisma.kategoriArtikel.findMany()
     * 
     * // Get first 10 KategoriArtikels
     * const kategoriArtikels = await prisma.kategoriArtikel.findMany({ take: 10 })
     * 
     * // Only select the `id_kategori_artikel`
     * const kategoriArtikelWithId_kategori_artikelOnly = await prisma.kategoriArtikel.findMany({ select: { id_kategori_artikel: true } })
     * 
     */
    findMany<T extends KategoriArtikelFindManyArgs>(args?: SelectSubset<T, KategoriArtikelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KategoriArtikel.
     * @param {KategoriArtikelCreateArgs} args - Arguments to create a KategoriArtikel.
     * @example
     * // Create one KategoriArtikel
     * const KategoriArtikel = await prisma.kategoriArtikel.create({
     *   data: {
     *     // ... data to create a KategoriArtikel
     *   }
     * })
     * 
     */
    create<T extends KategoriArtikelCreateArgs>(args: SelectSubset<T, KategoriArtikelCreateArgs<ExtArgs>>): Prisma__KategoriArtikelClient<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KategoriArtikels.
     * @param {KategoriArtikelCreateManyArgs} args - Arguments to create many KategoriArtikels.
     * @example
     * // Create many KategoriArtikels
     * const kategoriArtikel = await prisma.kategoriArtikel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KategoriArtikelCreateManyArgs>(args?: SelectSubset<T, KategoriArtikelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KategoriArtikels and returns the data saved in the database.
     * @param {KategoriArtikelCreateManyAndReturnArgs} args - Arguments to create many KategoriArtikels.
     * @example
     * // Create many KategoriArtikels
     * const kategoriArtikel = await prisma.kategoriArtikel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KategoriArtikels and only return the `id_kategori_artikel`
     * const kategoriArtikelWithId_kategori_artikelOnly = await prisma.kategoriArtikel.createManyAndReturn({
     *   select: { id_kategori_artikel: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KategoriArtikelCreateManyAndReturnArgs>(args?: SelectSubset<T, KategoriArtikelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KategoriArtikel.
     * @param {KategoriArtikelDeleteArgs} args - Arguments to delete one KategoriArtikel.
     * @example
     * // Delete one KategoriArtikel
     * const KategoriArtikel = await prisma.kategoriArtikel.delete({
     *   where: {
     *     // ... filter to delete one KategoriArtikel
     *   }
     * })
     * 
     */
    delete<T extends KategoriArtikelDeleteArgs>(args: SelectSubset<T, KategoriArtikelDeleteArgs<ExtArgs>>): Prisma__KategoriArtikelClient<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KategoriArtikel.
     * @param {KategoriArtikelUpdateArgs} args - Arguments to update one KategoriArtikel.
     * @example
     * // Update one KategoriArtikel
     * const kategoriArtikel = await prisma.kategoriArtikel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KategoriArtikelUpdateArgs>(args: SelectSubset<T, KategoriArtikelUpdateArgs<ExtArgs>>): Prisma__KategoriArtikelClient<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KategoriArtikels.
     * @param {KategoriArtikelDeleteManyArgs} args - Arguments to filter KategoriArtikels to delete.
     * @example
     * // Delete a few KategoriArtikels
     * const { count } = await prisma.kategoriArtikel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KategoriArtikelDeleteManyArgs>(args?: SelectSubset<T, KategoriArtikelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KategoriArtikels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategoriArtikelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KategoriArtikels
     * const kategoriArtikel = await prisma.kategoriArtikel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KategoriArtikelUpdateManyArgs>(args: SelectSubset<T, KategoriArtikelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KategoriArtikels and returns the data updated in the database.
     * @param {KategoriArtikelUpdateManyAndReturnArgs} args - Arguments to update many KategoriArtikels.
     * @example
     * // Update many KategoriArtikels
     * const kategoriArtikel = await prisma.kategoriArtikel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KategoriArtikels and only return the `id_kategori_artikel`
     * const kategoriArtikelWithId_kategori_artikelOnly = await prisma.kategoriArtikel.updateManyAndReturn({
     *   select: { id_kategori_artikel: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KategoriArtikelUpdateManyAndReturnArgs>(args: SelectSubset<T, KategoriArtikelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KategoriArtikel.
     * @param {KategoriArtikelUpsertArgs} args - Arguments to update or create a KategoriArtikel.
     * @example
     * // Update or create a KategoriArtikel
     * const kategoriArtikel = await prisma.kategoriArtikel.upsert({
     *   create: {
     *     // ... data to create a KategoriArtikel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KategoriArtikel we want to update
     *   }
     * })
     */
    upsert<T extends KategoriArtikelUpsertArgs>(args: SelectSubset<T, KategoriArtikelUpsertArgs<ExtArgs>>): Prisma__KategoriArtikelClient<$Result.GetResult<Prisma.$KategoriArtikelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KategoriArtikels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategoriArtikelCountArgs} args - Arguments to filter KategoriArtikels to count.
     * @example
     * // Count the number of KategoriArtikels
     * const count = await prisma.kategoriArtikel.count({
     *   where: {
     *     // ... the filter for the KategoriArtikels we want to count
     *   }
     * })
    **/
    count<T extends KategoriArtikelCountArgs>(
      args?: Subset<T, KategoriArtikelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KategoriArtikelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KategoriArtikel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategoriArtikelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KategoriArtikelAggregateArgs>(args: Subset<T, KategoriArtikelAggregateArgs>): Prisma.PrismaPromise<GetKategoriArtikelAggregateType<T>>

    /**
     * Group by KategoriArtikel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategoriArtikelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KategoriArtikelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KategoriArtikelGroupByArgs['orderBy'] }
        : { orderBy?: KategoriArtikelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KategoriArtikelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKategoriArtikelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KategoriArtikel model
   */
  readonly fields: KategoriArtikelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KategoriArtikel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KategoriArtikelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artikel<T extends KategoriArtikel$artikelArgs<ExtArgs> = {}>(args?: Subset<T, KategoriArtikel$artikelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KategoriArtikel model
   */
  interface KategoriArtikelFieldRefs {
    readonly id_kategori_artikel: FieldRef<"KategoriArtikel", 'Int'>
    readonly nama_kategori_artikel: FieldRef<"KategoriArtikel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KategoriArtikel findUnique
   */
  export type KategoriArtikelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KategoriArtikel to fetch.
     */
    where: KategoriArtikelWhereUniqueInput
  }

  /**
   * KategoriArtikel findUniqueOrThrow
   */
  export type KategoriArtikelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KategoriArtikel to fetch.
     */
    where: KategoriArtikelWhereUniqueInput
  }

  /**
   * KategoriArtikel findFirst
   */
  export type KategoriArtikelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KategoriArtikel to fetch.
     */
    where?: KategoriArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KategoriArtikels to fetch.
     */
    orderBy?: KategoriArtikelOrderByWithRelationInput | KategoriArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KategoriArtikels.
     */
    cursor?: KategoriArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KategoriArtikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KategoriArtikels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KategoriArtikels.
     */
    distinct?: KategoriArtikelScalarFieldEnum | KategoriArtikelScalarFieldEnum[]
  }

  /**
   * KategoriArtikel findFirstOrThrow
   */
  export type KategoriArtikelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KategoriArtikel to fetch.
     */
    where?: KategoriArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KategoriArtikels to fetch.
     */
    orderBy?: KategoriArtikelOrderByWithRelationInput | KategoriArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KategoriArtikels.
     */
    cursor?: KategoriArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KategoriArtikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KategoriArtikels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KategoriArtikels.
     */
    distinct?: KategoriArtikelScalarFieldEnum | KategoriArtikelScalarFieldEnum[]
  }

  /**
   * KategoriArtikel findMany
   */
  export type KategoriArtikelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KategoriArtikels to fetch.
     */
    where?: KategoriArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KategoriArtikels to fetch.
     */
    orderBy?: KategoriArtikelOrderByWithRelationInput | KategoriArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KategoriArtikels.
     */
    cursor?: KategoriArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KategoriArtikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KategoriArtikels.
     */
    skip?: number
    distinct?: KategoriArtikelScalarFieldEnum | KategoriArtikelScalarFieldEnum[]
  }

  /**
   * KategoriArtikel create
   */
  export type KategoriArtikelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
    /**
     * The data needed to create a KategoriArtikel.
     */
    data: XOR<KategoriArtikelCreateInput, KategoriArtikelUncheckedCreateInput>
  }

  /**
   * KategoriArtikel createMany
   */
  export type KategoriArtikelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KategoriArtikels.
     */
    data: KategoriArtikelCreateManyInput | KategoriArtikelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KategoriArtikel createManyAndReturn
   */
  export type KategoriArtikelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * The data used to create many KategoriArtikels.
     */
    data: KategoriArtikelCreateManyInput | KategoriArtikelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KategoriArtikel update
   */
  export type KategoriArtikelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
    /**
     * The data needed to update a KategoriArtikel.
     */
    data: XOR<KategoriArtikelUpdateInput, KategoriArtikelUncheckedUpdateInput>
    /**
     * Choose, which KategoriArtikel to update.
     */
    where: KategoriArtikelWhereUniqueInput
  }

  /**
   * KategoriArtikel updateMany
   */
  export type KategoriArtikelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KategoriArtikels.
     */
    data: XOR<KategoriArtikelUpdateManyMutationInput, KategoriArtikelUncheckedUpdateManyInput>
    /**
     * Filter which KategoriArtikels to update
     */
    where?: KategoriArtikelWhereInput
    /**
     * Limit how many KategoriArtikels to update.
     */
    limit?: number
  }

  /**
   * KategoriArtikel updateManyAndReturn
   */
  export type KategoriArtikelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * The data used to update KategoriArtikels.
     */
    data: XOR<KategoriArtikelUpdateManyMutationInput, KategoriArtikelUncheckedUpdateManyInput>
    /**
     * Filter which KategoriArtikels to update
     */
    where?: KategoriArtikelWhereInput
    /**
     * Limit how many KategoriArtikels to update.
     */
    limit?: number
  }

  /**
   * KategoriArtikel upsert
   */
  export type KategoriArtikelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
    /**
     * The filter to search for the KategoriArtikel to update in case it exists.
     */
    where: KategoriArtikelWhereUniqueInput
    /**
     * In case the KategoriArtikel found by the `where` argument doesn't exist, create a new KategoriArtikel with this data.
     */
    create: XOR<KategoriArtikelCreateInput, KategoriArtikelUncheckedCreateInput>
    /**
     * In case the KategoriArtikel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KategoriArtikelUpdateInput, KategoriArtikelUncheckedUpdateInput>
  }

  /**
   * KategoriArtikel delete
   */
  export type KategoriArtikelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
    /**
     * Filter which KategoriArtikel to delete.
     */
    where: KategoriArtikelWhereUniqueInput
  }

  /**
   * KategoriArtikel deleteMany
   */
  export type KategoriArtikelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KategoriArtikels to delete
     */
    where?: KategoriArtikelWhereInput
    /**
     * Limit how many KategoriArtikels to delete.
     */
    limit?: number
  }

  /**
   * KategoriArtikel.artikel
   */
  export type KategoriArtikel$artikelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artikel
     */
    select?: ArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artikel
     */
    omit?: ArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelInclude<ExtArgs> | null
    where?: ArtikelWhereInput
    orderBy?: ArtikelOrderByWithRelationInput | ArtikelOrderByWithRelationInput[]
    cursor?: ArtikelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtikelScalarFieldEnum | ArtikelScalarFieldEnum[]
  }

  /**
   * KategoriArtikel without action
   */
  export type KategoriArtikelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KategoriArtikel
     */
    select?: KategoriArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KategoriArtikel
     */
    omit?: KategoriArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KategoriArtikelInclude<ExtArgs> | null
  }


  /**
   * Model ArtikelDisimpan
   */

  export type AggregateArtikelDisimpan = {
    _count: ArtikelDisimpanCountAggregateOutputType | null
    _avg: ArtikelDisimpanAvgAggregateOutputType | null
    _sum: ArtikelDisimpanSumAggregateOutputType | null
    _min: ArtikelDisimpanMinAggregateOutputType | null
    _max: ArtikelDisimpanMaxAggregateOutputType | null
  }

  export type ArtikelDisimpanAvgAggregateOutputType = {
    id_penyimpanan: number | null
  }

  export type ArtikelDisimpanSumAggregateOutputType = {
    id_penyimpanan: number | null
  }

  export type ArtikelDisimpanMinAggregateOutputType = {
    id_penyimpanan: number | null
    id_artikel: string | null
    id_pengguna: string | null
  }

  export type ArtikelDisimpanMaxAggregateOutputType = {
    id_penyimpanan: number | null
    id_artikel: string | null
    id_pengguna: string | null
  }

  export type ArtikelDisimpanCountAggregateOutputType = {
    id_penyimpanan: number
    id_artikel: number
    id_pengguna: number
    _all: number
  }


  export type ArtikelDisimpanAvgAggregateInputType = {
    id_penyimpanan?: true
  }

  export type ArtikelDisimpanSumAggregateInputType = {
    id_penyimpanan?: true
  }

  export type ArtikelDisimpanMinAggregateInputType = {
    id_penyimpanan?: true
    id_artikel?: true
    id_pengguna?: true
  }

  export type ArtikelDisimpanMaxAggregateInputType = {
    id_penyimpanan?: true
    id_artikel?: true
    id_pengguna?: true
  }

  export type ArtikelDisimpanCountAggregateInputType = {
    id_penyimpanan?: true
    id_artikel?: true
    id_pengguna?: true
    _all?: true
  }

  export type ArtikelDisimpanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtikelDisimpan to aggregate.
     */
    where?: ArtikelDisimpanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtikelDisimpans to fetch.
     */
    orderBy?: ArtikelDisimpanOrderByWithRelationInput | ArtikelDisimpanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtikelDisimpanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtikelDisimpans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtikelDisimpans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArtikelDisimpans
    **/
    _count?: true | ArtikelDisimpanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtikelDisimpanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtikelDisimpanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtikelDisimpanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtikelDisimpanMaxAggregateInputType
  }

  export type GetArtikelDisimpanAggregateType<T extends ArtikelDisimpanAggregateArgs> = {
        [P in keyof T & keyof AggregateArtikelDisimpan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtikelDisimpan[P]>
      : GetScalarType<T[P], AggregateArtikelDisimpan[P]>
  }




  export type ArtikelDisimpanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtikelDisimpanWhereInput
    orderBy?: ArtikelDisimpanOrderByWithAggregationInput | ArtikelDisimpanOrderByWithAggregationInput[]
    by: ArtikelDisimpanScalarFieldEnum[] | ArtikelDisimpanScalarFieldEnum
    having?: ArtikelDisimpanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtikelDisimpanCountAggregateInputType | true
    _avg?: ArtikelDisimpanAvgAggregateInputType
    _sum?: ArtikelDisimpanSumAggregateInputType
    _min?: ArtikelDisimpanMinAggregateInputType
    _max?: ArtikelDisimpanMaxAggregateInputType
  }

  export type ArtikelDisimpanGroupByOutputType = {
    id_penyimpanan: number
    id_artikel: string
    id_pengguna: string
    _count: ArtikelDisimpanCountAggregateOutputType | null
    _avg: ArtikelDisimpanAvgAggregateOutputType | null
    _sum: ArtikelDisimpanSumAggregateOutputType | null
    _min: ArtikelDisimpanMinAggregateOutputType | null
    _max: ArtikelDisimpanMaxAggregateOutputType | null
  }

  type GetArtikelDisimpanGroupByPayload<T extends ArtikelDisimpanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtikelDisimpanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtikelDisimpanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtikelDisimpanGroupByOutputType[P]>
            : GetScalarType<T[P], ArtikelDisimpanGroupByOutputType[P]>
        }
      >
    >


  export type ArtikelDisimpanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_penyimpanan?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artikelDisimpan"]>

  export type ArtikelDisimpanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_penyimpanan?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artikelDisimpan"]>

  export type ArtikelDisimpanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_penyimpanan?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artikelDisimpan"]>

  export type ArtikelDisimpanSelectScalar = {
    id_penyimpanan?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
  }

  export type ArtikelDisimpanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_penyimpanan" | "id_artikel" | "id_pengguna", ExtArgs["result"]["artikelDisimpan"]>
  export type ArtikelDisimpanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }
  export type ArtikelDisimpanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }
  export type ArtikelDisimpanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }

  export type $ArtikelDisimpanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArtikelDisimpan"
    objects: {
      artikel: Prisma.$ArtikelPayload<ExtArgs>
      pengguna: Prisma.$PenggunaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_penyimpanan: number
      id_artikel: string
      id_pengguna: string
    }, ExtArgs["result"]["artikelDisimpan"]>
    composites: {}
  }

  type ArtikelDisimpanGetPayload<S extends boolean | null | undefined | ArtikelDisimpanDefaultArgs> = $Result.GetResult<Prisma.$ArtikelDisimpanPayload, S>

  type ArtikelDisimpanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtikelDisimpanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtikelDisimpanCountAggregateInputType | true
    }

  export interface ArtikelDisimpanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArtikelDisimpan'], meta: { name: 'ArtikelDisimpan' } }
    /**
     * Find zero or one ArtikelDisimpan that matches the filter.
     * @param {ArtikelDisimpanFindUniqueArgs} args - Arguments to find a ArtikelDisimpan
     * @example
     * // Get one ArtikelDisimpan
     * const artikelDisimpan = await prisma.artikelDisimpan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtikelDisimpanFindUniqueArgs>(args: SelectSubset<T, ArtikelDisimpanFindUniqueArgs<ExtArgs>>): Prisma__ArtikelDisimpanClient<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArtikelDisimpan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtikelDisimpanFindUniqueOrThrowArgs} args - Arguments to find a ArtikelDisimpan
     * @example
     * // Get one ArtikelDisimpan
     * const artikelDisimpan = await prisma.artikelDisimpan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtikelDisimpanFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtikelDisimpanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtikelDisimpanClient<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtikelDisimpan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisimpanFindFirstArgs} args - Arguments to find a ArtikelDisimpan
     * @example
     * // Get one ArtikelDisimpan
     * const artikelDisimpan = await prisma.artikelDisimpan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtikelDisimpanFindFirstArgs>(args?: SelectSubset<T, ArtikelDisimpanFindFirstArgs<ExtArgs>>): Prisma__ArtikelDisimpanClient<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtikelDisimpan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisimpanFindFirstOrThrowArgs} args - Arguments to find a ArtikelDisimpan
     * @example
     * // Get one ArtikelDisimpan
     * const artikelDisimpan = await prisma.artikelDisimpan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtikelDisimpanFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtikelDisimpanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtikelDisimpanClient<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArtikelDisimpans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisimpanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArtikelDisimpans
     * const artikelDisimpans = await prisma.artikelDisimpan.findMany()
     * 
     * // Get first 10 ArtikelDisimpans
     * const artikelDisimpans = await prisma.artikelDisimpan.findMany({ take: 10 })
     * 
     * // Only select the `id_penyimpanan`
     * const artikelDisimpanWithId_penyimpananOnly = await prisma.artikelDisimpan.findMany({ select: { id_penyimpanan: true } })
     * 
     */
    findMany<T extends ArtikelDisimpanFindManyArgs>(args?: SelectSubset<T, ArtikelDisimpanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArtikelDisimpan.
     * @param {ArtikelDisimpanCreateArgs} args - Arguments to create a ArtikelDisimpan.
     * @example
     * // Create one ArtikelDisimpan
     * const ArtikelDisimpan = await prisma.artikelDisimpan.create({
     *   data: {
     *     // ... data to create a ArtikelDisimpan
     *   }
     * })
     * 
     */
    create<T extends ArtikelDisimpanCreateArgs>(args: SelectSubset<T, ArtikelDisimpanCreateArgs<ExtArgs>>): Prisma__ArtikelDisimpanClient<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArtikelDisimpans.
     * @param {ArtikelDisimpanCreateManyArgs} args - Arguments to create many ArtikelDisimpans.
     * @example
     * // Create many ArtikelDisimpans
     * const artikelDisimpan = await prisma.artikelDisimpan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtikelDisimpanCreateManyArgs>(args?: SelectSubset<T, ArtikelDisimpanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArtikelDisimpans and returns the data saved in the database.
     * @param {ArtikelDisimpanCreateManyAndReturnArgs} args - Arguments to create many ArtikelDisimpans.
     * @example
     * // Create many ArtikelDisimpans
     * const artikelDisimpan = await prisma.artikelDisimpan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArtikelDisimpans and only return the `id_penyimpanan`
     * const artikelDisimpanWithId_penyimpananOnly = await prisma.artikelDisimpan.createManyAndReturn({
     *   select: { id_penyimpanan: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtikelDisimpanCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtikelDisimpanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArtikelDisimpan.
     * @param {ArtikelDisimpanDeleteArgs} args - Arguments to delete one ArtikelDisimpan.
     * @example
     * // Delete one ArtikelDisimpan
     * const ArtikelDisimpan = await prisma.artikelDisimpan.delete({
     *   where: {
     *     // ... filter to delete one ArtikelDisimpan
     *   }
     * })
     * 
     */
    delete<T extends ArtikelDisimpanDeleteArgs>(args: SelectSubset<T, ArtikelDisimpanDeleteArgs<ExtArgs>>): Prisma__ArtikelDisimpanClient<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArtikelDisimpan.
     * @param {ArtikelDisimpanUpdateArgs} args - Arguments to update one ArtikelDisimpan.
     * @example
     * // Update one ArtikelDisimpan
     * const artikelDisimpan = await prisma.artikelDisimpan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtikelDisimpanUpdateArgs>(args: SelectSubset<T, ArtikelDisimpanUpdateArgs<ExtArgs>>): Prisma__ArtikelDisimpanClient<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArtikelDisimpans.
     * @param {ArtikelDisimpanDeleteManyArgs} args - Arguments to filter ArtikelDisimpans to delete.
     * @example
     * // Delete a few ArtikelDisimpans
     * const { count } = await prisma.artikelDisimpan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtikelDisimpanDeleteManyArgs>(args?: SelectSubset<T, ArtikelDisimpanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtikelDisimpans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisimpanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArtikelDisimpans
     * const artikelDisimpan = await prisma.artikelDisimpan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtikelDisimpanUpdateManyArgs>(args: SelectSubset<T, ArtikelDisimpanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtikelDisimpans and returns the data updated in the database.
     * @param {ArtikelDisimpanUpdateManyAndReturnArgs} args - Arguments to update many ArtikelDisimpans.
     * @example
     * // Update many ArtikelDisimpans
     * const artikelDisimpan = await prisma.artikelDisimpan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArtikelDisimpans and only return the `id_penyimpanan`
     * const artikelDisimpanWithId_penyimpananOnly = await prisma.artikelDisimpan.updateManyAndReturn({
     *   select: { id_penyimpanan: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtikelDisimpanUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtikelDisimpanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArtikelDisimpan.
     * @param {ArtikelDisimpanUpsertArgs} args - Arguments to update or create a ArtikelDisimpan.
     * @example
     * // Update or create a ArtikelDisimpan
     * const artikelDisimpan = await prisma.artikelDisimpan.upsert({
     *   create: {
     *     // ... data to create a ArtikelDisimpan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArtikelDisimpan we want to update
     *   }
     * })
     */
    upsert<T extends ArtikelDisimpanUpsertArgs>(args: SelectSubset<T, ArtikelDisimpanUpsertArgs<ExtArgs>>): Prisma__ArtikelDisimpanClient<$Result.GetResult<Prisma.$ArtikelDisimpanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArtikelDisimpans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisimpanCountArgs} args - Arguments to filter ArtikelDisimpans to count.
     * @example
     * // Count the number of ArtikelDisimpans
     * const count = await prisma.artikelDisimpan.count({
     *   where: {
     *     // ... the filter for the ArtikelDisimpans we want to count
     *   }
     * })
    **/
    count<T extends ArtikelDisimpanCountArgs>(
      args?: Subset<T, ArtikelDisimpanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtikelDisimpanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArtikelDisimpan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisimpanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtikelDisimpanAggregateArgs>(args: Subset<T, ArtikelDisimpanAggregateArgs>): Prisma.PrismaPromise<GetArtikelDisimpanAggregateType<T>>

    /**
     * Group by ArtikelDisimpan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisimpanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtikelDisimpanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtikelDisimpanGroupByArgs['orderBy'] }
        : { orderBy?: ArtikelDisimpanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtikelDisimpanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtikelDisimpanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArtikelDisimpan model
   */
  readonly fields: ArtikelDisimpanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArtikelDisimpan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtikelDisimpanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artikel<T extends ArtikelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtikelDefaultArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pengguna<T extends PenggunaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PenggunaDefaultArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArtikelDisimpan model
   */
  interface ArtikelDisimpanFieldRefs {
    readonly id_penyimpanan: FieldRef<"ArtikelDisimpan", 'Int'>
    readonly id_artikel: FieldRef<"ArtikelDisimpan", 'String'>
    readonly id_pengguna: FieldRef<"ArtikelDisimpan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ArtikelDisimpan findUnique
   */
  export type ArtikelDisimpanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisimpan to fetch.
     */
    where: ArtikelDisimpanWhereUniqueInput
  }

  /**
   * ArtikelDisimpan findUniqueOrThrow
   */
  export type ArtikelDisimpanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisimpan to fetch.
     */
    where: ArtikelDisimpanWhereUniqueInput
  }

  /**
   * ArtikelDisimpan findFirst
   */
  export type ArtikelDisimpanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisimpan to fetch.
     */
    where?: ArtikelDisimpanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtikelDisimpans to fetch.
     */
    orderBy?: ArtikelDisimpanOrderByWithRelationInput | ArtikelDisimpanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtikelDisimpans.
     */
    cursor?: ArtikelDisimpanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtikelDisimpans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtikelDisimpans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtikelDisimpans.
     */
    distinct?: ArtikelDisimpanScalarFieldEnum | ArtikelDisimpanScalarFieldEnum[]
  }

  /**
   * ArtikelDisimpan findFirstOrThrow
   */
  export type ArtikelDisimpanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisimpan to fetch.
     */
    where?: ArtikelDisimpanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtikelDisimpans to fetch.
     */
    orderBy?: ArtikelDisimpanOrderByWithRelationInput | ArtikelDisimpanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtikelDisimpans.
     */
    cursor?: ArtikelDisimpanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtikelDisimpans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtikelDisimpans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtikelDisimpans.
     */
    distinct?: ArtikelDisimpanScalarFieldEnum | ArtikelDisimpanScalarFieldEnum[]
  }

  /**
   * ArtikelDisimpan findMany
   */
  export type ArtikelDisimpanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisimpans to fetch.
     */
    where?: ArtikelDisimpanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtikelDisimpans to fetch.
     */
    orderBy?: ArtikelDisimpanOrderByWithRelationInput | ArtikelDisimpanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArtikelDisimpans.
     */
    cursor?: ArtikelDisimpanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtikelDisimpans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtikelDisimpans.
     */
    skip?: number
    distinct?: ArtikelDisimpanScalarFieldEnum | ArtikelDisimpanScalarFieldEnum[]
  }

  /**
   * ArtikelDisimpan create
   */
  export type ArtikelDisimpanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    /**
     * The data needed to create a ArtikelDisimpan.
     */
    data: XOR<ArtikelDisimpanCreateInput, ArtikelDisimpanUncheckedCreateInput>
  }

  /**
   * ArtikelDisimpan createMany
   */
  export type ArtikelDisimpanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArtikelDisimpans.
     */
    data: ArtikelDisimpanCreateManyInput | ArtikelDisimpanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtikelDisimpan createManyAndReturn
   */
  export type ArtikelDisimpanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * The data used to create many ArtikelDisimpans.
     */
    data: ArtikelDisimpanCreateManyInput | ArtikelDisimpanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtikelDisimpan update
   */
  export type ArtikelDisimpanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    /**
     * The data needed to update a ArtikelDisimpan.
     */
    data: XOR<ArtikelDisimpanUpdateInput, ArtikelDisimpanUncheckedUpdateInput>
    /**
     * Choose, which ArtikelDisimpan to update.
     */
    where: ArtikelDisimpanWhereUniqueInput
  }

  /**
   * ArtikelDisimpan updateMany
   */
  export type ArtikelDisimpanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArtikelDisimpans.
     */
    data: XOR<ArtikelDisimpanUpdateManyMutationInput, ArtikelDisimpanUncheckedUpdateManyInput>
    /**
     * Filter which ArtikelDisimpans to update
     */
    where?: ArtikelDisimpanWhereInput
    /**
     * Limit how many ArtikelDisimpans to update.
     */
    limit?: number
  }

  /**
   * ArtikelDisimpan updateManyAndReturn
   */
  export type ArtikelDisimpanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * The data used to update ArtikelDisimpans.
     */
    data: XOR<ArtikelDisimpanUpdateManyMutationInput, ArtikelDisimpanUncheckedUpdateManyInput>
    /**
     * Filter which ArtikelDisimpans to update
     */
    where?: ArtikelDisimpanWhereInput
    /**
     * Limit how many ArtikelDisimpans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtikelDisimpan upsert
   */
  export type ArtikelDisimpanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    /**
     * The filter to search for the ArtikelDisimpan to update in case it exists.
     */
    where: ArtikelDisimpanWhereUniqueInput
    /**
     * In case the ArtikelDisimpan found by the `where` argument doesn't exist, create a new ArtikelDisimpan with this data.
     */
    create: XOR<ArtikelDisimpanCreateInput, ArtikelDisimpanUncheckedCreateInput>
    /**
     * In case the ArtikelDisimpan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtikelDisimpanUpdateInput, ArtikelDisimpanUncheckedUpdateInput>
  }

  /**
   * ArtikelDisimpan delete
   */
  export type ArtikelDisimpanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
    /**
     * Filter which ArtikelDisimpan to delete.
     */
    where: ArtikelDisimpanWhereUniqueInput
  }

  /**
   * ArtikelDisimpan deleteMany
   */
  export type ArtikelDisimpanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtikelDisimpans to delete
     */
    where?: ArtikelDisimpanWhereInput
    /**
     * Limit how many ArtikelDisimpans to delete.
     */
    limit?: number
  }

  /**
   * ArtikelDisimpan without action
   */
  export type ArtikelDisimpanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisimpan
     */
    select?: ArtikelDisimpanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisimpan
     */
    omit?: ArtikelDisimpanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisimpanInclude<ExtArgs> | null
  }


  /**
   * Model ArtikelDisukai
   */

  export type AggregateArtikelDisukai = {
    _count: ArtikelDisukaiCountAggregateOutputType | null
    _avg: ArtikelDisukaiAvgAggregateOutputType | null
    _sum: ArtikelDisukaiSumAggregateOutputType | null
    _min: ArtikelDisukaiMinAggregateOutputType | null
    _max: ArtikelDisukaiMaxAggregateOutputType | null
  }

  export type ArtikelDisukaiAvgAggregateOutputType = {
    id_disukai: number | null
    rating: number | null
  }

  export type ArtikelDisukaiSumAggregateOutputType = {
    id_disukai: number | null
    rating: number | null
  }

  export type ArtikelDisukaiMinAggregateOutputType = {
    id_disukai: number | null
    id_artikel: string | null
    id_pengguna: string | null
    rating: number | null
  }

  export type ArtikelDisukaiMaxAggregateOutputType = {
    id_disukai: number | null
    id_artikel: string | null
    id_pengguna: string | null
    rating: number | null
  }

  export type ArtikelDisukaiCountAggregateOutputType = {
    id_disukai: number
    id_artikel: number
    id_pengguna: number
    rating: number
    _all: number
  }


  export type ArtikelDisukaiAvgAggregateInputType = {
    id_disukai?: true
    rating?: true
  }

  export type ArtikelDisukaiSumAggregateInputType = {
    id_disukai?: true
    rating?: true
  }

  export type ArtikelDisukaiMinAggregateInputType = {
    id_disukai?: true
    id_artikel?: true
    id_pengguna?: true
    rating?: true
  }

  export type ArtikelDisukaiMaxAggregateInputType = {
    id_disukai?: true
    id_artikel?: true
    id_pengguna?: true
    rating?: true
  }

  export type ArtikelDisukaiCountAggregateInputType = {
    id_disukai?: true
    id_artikel?: true
    id_pengguna?: true
    rating?: true
    _all?: true
  }

  export type ArtikelDisukaiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtikelDisukai to aggregate.
     */
    where?: ArtikelDisukaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtikelDisukais to fetch.
     */
    orderBy?: ArtikelDisukaiOrderByWithRelationInput | ArtikelDisukaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtikelDisukaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtikelDisukais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtikelDisukais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArtikelDisukais
    **/
    _count?: true | ArtikelDisukaiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtikelDisukaiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtikelDisukaiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtikelDisukaiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtikelDisukaiMaxAggregateInputType
  }

  export type GetArtikelDisukaiAggregateType<T extends ArtikelDisukaiAggregateArgs> = {
        [P in keyof T & keyof AggregateArtikelDisukai]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtikelDisukai[P]>
      : GetScalarType<T[P], AggregateArtikelDisukai[P]>
  }




  export type ArtikelDisukaiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtikelDisukaiWhereInput
    orderBy?: ArtikelDisukaiOrderByWithAggregationInput | ArtikelDisukaiOrderByWithAggregationInput[]
    by: ArtikelDisukaiScalarFieldEnum[] | ArtikelDisukaiScalarFieldEnum
    having?: ArtikelDisukaiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtikelDisukaiCountAggregateInputType | true
    _avg?: ArtikelDisukaiAvgAggregateInputType
    _sum?: ArtikelDisukaiSumAggregateInputType
    _min?: ArtikelDisukaiMinAggregateInputType
    _max?: ArtikelDisukaiMaxAggregateInputType
  }

  export type ArtikelDisukaiGroupByOutputType = {
    id_disukai: number
    id_artikel: string
    id_pengguna: string
    rating: number
    _count: ArtikelDisukaiCountAggregateOutputType | null
    _avg: ArtikelDisukaiAvgAggregateOutputType | null
    _sum: ArtikelDisukaiSumAggregateOutputType | null
    _min: ArtikelDisukaiMinAggregateOutputType | null
    _max: ArtikelDisukaiMaxAggregateOutputType | null
  }

  type GetArtikelDisukaiGroupByPayload<T extends ArtikelDisukaiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtikelDisukaiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtikelDisukaiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtikelDisukaiGroupByOutputType[P]>
            : GetScalarType<T[P], ArtikelDisukaiGroupByOutputType[P]>
        }
      >
    >


  export type ArtikelDisukaiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_disukai?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    rating?: boolean
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artikelDisukai"]>

  export type ArtikelDisukaiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_disukai?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    rating?: boolean
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artikelDisukai"]>

  export type ArtikelDisukaiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_disukai?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    rating?: boolean
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artikelDisukai"]>

  export type ArtikelDisukaiSelectScalar = {
    id_disukai?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    rating?: boolean
  }

  export type ArtikelDisukaiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_disukai" | "id_artikel" | "id_pengguna" | "rating", ExtArgs["result"]["artikelDisukai"]>
  export type ArtikelDisukaiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }
  export type ArtikelDisukaiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }
  export type ArtikelDisukaiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }

  export type $ArtikelDisukaiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArtikelDisukai"
    objects: {
      artikel: Prisma.$ArtikelPayload<ExtArgs>
      pengguna: Prisma.$PenggunaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_disukai: number
      id_artikel: string
      id_pengguna: string
      rating: number
    }, ExtArgs["result"]["artikelDisukai"]>
    composites: {}
  }

  type ArtikelDisukaiGetPayload<S extends boolean | null | undefined | ArtikelDisukaiDefaultArgs> = $Result.GetResult<Prisma.$ArtikelDisukaiPayload, S>

  type ArtikelDisukaiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtikelDisukaiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtikelDisukaiCountAggregateInputType | true
    }

  export interface ArtikelDisukaiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArtikelDisukai'], meta: { name: 'ArtikelDisukai' } }
    /**
     * Find zero or one ArtikelDisukai that matches the filter.
     * @param {ArtikelDisukaiFindUniqueArgs} args - Arguments to find a ArtikelDisukai
     * @example
     * // Get one ArtikelDisukai
     * const artikelDisukai = await prisma.artikelDisukai.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtikelDisukaiFindUniqueArgs>(args: SelectSubset<T, ArtikelDisukaiFindUniqueArgs<ExtArgs>>): Prisma__ArtikelDisukaiClient<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArtikelDisukai that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtikelDisukaiFindUniqueOrThrowArgs} args - Arguments to find a ArtikelDisukai
     * @example
     * // Get one ArtikelDisukai
     * const artikelDisukai = await prisma.artikelDisukai.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtikelDisukaiFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtikelDisukaiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtikelDisukaiClient<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtikelDisukai that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisukaiFindFirstArgs} args - Arguments to find a ArtikelDisukai
     * @example
     * // Get one ArtikelDisukai
     * const artikelDisukai = await prisma.artikelDisukai.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtikelDisukaiFindFirstArgs>(args?: SelectSubset<T, ArtikelDisukaiFindFirstArgs<ExtArgs>>): Prisma__ArtikelDisukaiClient<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtikelDisukai that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisukaiFindFirstOrThrowArgs} args - Arguments to find a ArtikelDisukai
     * @example
     * // Get one ArtikelDisukai
     * const artikelDisukai = await prisma.artikelDisukai.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtikelDisukaiFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtikelDisukaiFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtikelDisukaiClient<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArtikelDisukais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisukaiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArtikelDisukais
     * const artikelDisukais = await prisma.artikelDisukai.findMany()
     * 
     * // Get first 10 ArtikelDisukais
     * const artikelDisukais = await prisma.artikelDisukai.findMany({ take: 10 })
     * 
     * // Only select the `id_disukai`
     * const artikelDisukaiWithId_disukaiOnly = await prisma.artikelDisukai.findMany({ select: { id_disukai: true } })
     * 
     */
    findMany<T extends ArtikelDisukaiFindManyArgs>(args?: SelectSubset<T, ArtikelDisukaiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArtikelDisukai.
     * @param {ArtikelDisukaiCreateArgs} args - Arguments to create a ArtikelDisukai.
     * @example
     * // Create one ArtikelDisukai
     * const ArtikelDisukai = await prisma.artikelDisukai.create({
     *   data: {
     *     // ... data to create a ArtikelDisukai
     *   }
     * })
     * 
     */
    create<T extends ArtikelDisukaiCreateArgs>(args: SelectSubset<T, ArtikelDisukaiCreateArgs<ExtArgs>>): Prisma__ArtikelDisukaiClient<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArtikelDisukais.
     * @param {ArtikelDisukaiCreateManyArgs} args - Arguments to create many ArtikelDisukais.
     * @example
     * // Create many ArtikelDisukais
     * const artikelDisukai = await prisma.artikelDisukai.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtikelDisukaiCreateManyArgs>(args?: SelectSubset<T, ArtikelDisukaiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArtikelDisukais and returns the data saved in the database.
     * @param {ArtikelDisukaiCreateManyAndReturnArgs} args - Arguments to create many ArtikelDisukais.
     * @example
     * // Create many ArtikelDisukais
     * const artikelDisukai = await prisma.artikelDisukai.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArtikelDisukais and only return the `id_disukai`
     * const artikelDisukaiWithId_disukaiOnly = await prisma.artikelDisukai.createManyAndReturn({
     *   select: { id_disukai: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtikelDisukaiCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtikelDisukaiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArtikelDisukai.
     * @param {ArtikelDisukaiDeleteArgs} args - Arguments to delete one ArtikelDisukai.
     * @example
     * // Delete one ArtikelDisukai
     * const ArtikelDisukai = await prisma.artikelDisukai.delete({
     *   where: {
     *     // ... filter to delete one ArtikelDisukai
     *   }
     * })
     * 
     */
    delete<T extends ArtikelDisukaiDeleteArgs>(args: SelectSubset<T, ArtikelDisukaiDeleteArgs<ExtArgs>>): Prisma__ArtikelDisukaiClient<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArtikelDisukai.
     * @param {ArtikelDisukaiUpdateArgs} args - Arguments to update one ArtikelDisukai.
     * @example
     * // Update one ArtikelDisukai
     * const artikelDisukai = await prisma.artikelDisukai.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtikelDisukaiUpdateArgs>(args: SelectSubset<T, ArtikelDisukaiUpdateArgs<ExtArgs>>): Prisma__ArtikelDisukaiClient<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArtikelDisukais.
     * @param {ArtikelDisukaiDeleteManyArgs} args - Arguments to filter ArtikelDisukais to delete.
     * @example
     * // Delete a few ArtikelDisukais
     * const { count } = await prisma.artikelDisukai.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtikelDisukaiDeleteManyArgs>(args?: SelectSubset<T, ArtikelDisukaiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtikelDisukais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisukaiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArtikelDisukais
     * const artikelDisukai = await prisma.artikelDisukai.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtikelDisukaiUpdateManyArgs>(args: SelectSubset<T, ArtikelDisukaiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtikelDisukais and returns the data updated in the database.
     * @param {ArtikelDisukaiUpdateManyAndReturnArgs} args - Arguments to update many ArtikelDisukais.
     * @example
     * // Update many ArtikelDisukais
     * const artikelDisukai = await prisma.artikelDisukai.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArtikelDisukais and only return the `id_disukai`
     * const artikelDisukaiWithId_disukaiOnly = await prisma.artikelDisukai.updateManyAndReturn({
     *   select: { id_disukai: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtikelDisukaiUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtikelDisukaiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArtikelDisukai.
     * @param {ArtikelDisukaiUpsertArgs} args - Arguments to update or create a ArtikelDisukai.
     * @example
     * // Update or create a ArtikelDisukai
     * const artikelDisukai = await prisma.artikelDisukai.upsert({
     *   create: {
     *     // ... data to create a ArtikelDisukai
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArtikelDisukai we want to update
     *   }
     * })
     */
    upsert<T extends ArtikelDisukaiUpsertArgs>(args: SelectSubset<T, ArtikelDisukaiUpsertArgs<ExtArgs>>): Prisma__ArtikelDisukaiClient<$Result.GetResult<Prisma.$ArtikelDisukaiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArtikelDisukais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisukaiCountArgs} args - Arguments to filter ArtikelDisukais to count.
     * @example
     * // Count the number of ArtikelDisukais
     * const count = await prisma.artikelDisukai.count({
     *   where: {
     *     // ... the filter for the ArtikelDisukais we want to count
     *   }
     * })
    **/
    count<T extends ArtikelDisukaiCountArgs>(
      args?: Subset<T, ArtikelDisukaiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtikelDisukaiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArtikelDisukai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisukaiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtikelDisukaiAggregateArgs>(args: Subset<T, ArtikelDisukaiAggregateArgs>): Prisma.PrismaPromise<GetArtikelDisukaiAggregateType<T>>

    /**
     * Group by ArtikelDisukai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtikelDisukaiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtikelDisukaiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtikelDisukaiGroupByArgs['orderBy'] }
        : { orderBy?: ArtikelDisukaiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtikelDisukaiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtikelDisukaiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArtikelDisukai model
   */
  readonly fields: ArtikelDisukaiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArtikelDisukai.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtikelDisukaiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artikel<T extends ArtikelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtikelDefaultArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pengguna<T extends PenggunaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PenggunaDefaultArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArtikelDisukai model
   */
  interface ArtikelDisukaiFieldRefs {
    readonly id_disukai: FieldRef<"ArtikelDisukai", 'Int'>
    readonly id_artikel: FieldRef<"ArtikelDisukai", 'String'>
    readonly id_pengguna: FieldRef<"ArtikelDisukai", 'String'>
    readonly rating: FieldRef<"ArtikelDisukai", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ArtikelDisukai findUnique
   */
  export type ArtikelDisukaiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisukai to fetch.
     */
    where: ArtikelDisukaiWhereUniqueInput
  }

  /**
   * ArtikelDisukai findUniqueOrThrow
   */
  export type ArtikelDisukaiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisukai to fetch.
     */
    where: ArtikelDisukaiWhereUniqueInput
  }

  /**
   * ArtikelDisukai findFirst
   */
  export type ArtikelDisukaiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisukai to fetch.
     */
    where?: ArtikelDisukaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtikelDisukais to fetch.
     */
    orderBy?: ArtikelDisukaiOrderByWithRelationInput | ArtikelDisukaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtikelDisukais.
     */
    cursor?: ArtikelDisukaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtikelDisukais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtikelDisukais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtikelDisukais.
     */
    distinct?: ArtikelDisukaiScalarFieldEnum | ArtikelDisukaiScalarFieldEnum[]
  }

  /**
   * ArtikelDisukai findFirstOrThrow
   */
  export type ArtikelDisukaiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisukai to fetch.
     */
    where?: ArtikelDisukaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtikelDisukais to fetch.
     */
    orderBy?: ArtikelDisukaiOrderByWithRelationInput | ArtikelDisukaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtikelDisukais.
     */
    cursor?: ArtikelDisukaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtikelDisukais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtikelDisukais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtikelDisukais.
     */
    distinct?: ArtikelDisukaiScalarFieldEnum | ArtikelDisukaiScalarFieldEnum[]
  }

  /**
   * ArtikelDisukai findMany
   */
  export type ArtikelDisukaiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    /**
     * Filter, which ArtikelDisukais to fetch.
     */
    where?: ArtikelDisukaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtikelDisukais to fetch.
     */
    orderBy?: ArtikelDisukaiOrderByWithRelationInput | ArtikelDisukaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArtikelDisukais.
     */
    cursor?: ArtikelDisukaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtikelDisukais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtikelDisukais.
     */
    skip?: number
    distinct?: ArtikelDisukaiScalarFieldEnum | ArtikelDisukaiScalarFieldEnum[]
  }

  /**
   * ArtikelDisukai create
   */
  export type ArtikelDisukaiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    /**
     * The data needed to create a ArtikelDisukai.
     */
    data: XOR<ArtikelDisukaiCreateInput, ArtikelDisukaiUncheckedCreateInput>
  }

  /**
   * ArtikelDisukai createMany
   */
  export type ArtikelDisukaiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArtikelDisukais.
     */
    data: ArtikelDisukaiCreateManyInput | ArtikelDisukaiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtikelDisukai createManyAndReturn
   */
  export type ArtikelDisukaiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * The data used to create many ArtikelDisukais.
     */
    data: ArtikelDisukaiCreateManyInput | ArtikelDisukaiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtikelDisukai update
   */
  export type ArtikelDisukaiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    /**
     * The data needed to update a ArtikelDisukai.
     */
    data: XOR<ArtikelDisukaiUpdateInput, ArtikelDisukaiUncheckedUpdateInput>
    /**
     * Choose, which ArtikelDisukai to update.
     */
    where: ArtikelDisukaiWhereUniqueInput
  }

  /**
   * ArtikelDisukai updateMany
   */
  export type ArtikelDisukaiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArtikelDisukais.
     */
    data: XOR<ArtikelDisukaiUpdateManyMutationInput, ArtikelDisukaiUncheckedUpdateManyInput>
    /**
     * Filter which ArtikelDisukais to update
     */
    where?: ArtikelDisukaiWhereInput
    /**
     * Limit how many ArtikelDisukais to update.
     */
    limit?: number
  }

  /**
   * ArtikelDisukai updateManyAndReturn
   */
  export type ArtikelDisukaiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * The data used to update ArtikelDisukais.
     */
    data: XOR<ArtikelDisukaiUpdateManyMutationInput, ArtikelDisukaiUncheckedUpdateManyInput>
    /**
     * Filter which ArtikelDisukais to update
     */
    where?: ArtikelDisukaiWhereInput
    /**
     * Limit how many ArtikelDisukais to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtikelDisukai upsert
   */
  export type ArtikelDisukaiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    /**
     * The filter to search for the ArtikelDisukai to update in case it exists.
     */
    where: ArtikelDisukaiWhereUniqueInput
    /**
     * In case the ArtikelDisukai found by the `where` argument doesn't exist, create a new ArtikelDisukai with this data.
     */
    create: XOR<ArtikelDisukaiCreateInput, ArtikelDisukaiUncheckedCreateInput>
    /**
     * In case the ArtikelDisukai was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtikelDisukaiUpdateInput, ArtikelDisukaiUncheckedUpdateInput>
  }

  /**
   * ArtikelDisukai delete
   */
  export type ArtikelDisukaiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
    /**
     * Filter which ArtikelDisukai to delete.
     */
    where: ArtikelDisukaiWhereUniqueInput
  }

  /**
   * ArtikelDisukai deleteMany
   */
  export type ArtikelDisukaiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtikelDisukais to delete
     */
    where?: ArtikelDisukaiWhereInput
    /**
     * Limit how many ArtikelDisukais to delete.
     */
    limit?: number
  }

  /**
   * ArtikelDisukai without action
   */
  export type ArtikelDisukaiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtikelDisukai
     */
    select?: ArtikelDisukaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtikelDisukai
     */
    omit?: ArtikelDisukaiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtikelDisukaiInclude<ExtArgs> | null
  }


  /**
   * Model KomentarArtikel
   */

  export type AggregateKomentarArtikel = {
    _count: KomentarArtikelCountAggregateOutputType | null
    _avg: KomentarArtikelAvgAggregateOutputType | null
    _sum: KomentarArtikelSumAggregateOutputType | null
    _min: KomentarArtikelMinAggregateOutputType | null
    _max: KomentarArtikelMaxAggregateOutputType | null
  }

  export type KomentarArtikelAvgAggregateOutputType = {
    id_komentar: number | null
  }

  export type KomentarArtikelSumAggregateOutputType = {
    id_komentar: number | null
  }

  export type KomentarArtikelMinAggregateOutputType = {
    id_komentar: number | null
    id_artikel: string | null
    id_pengguna: string | null
    komentar: string | null
  }

  export type KomentarArtikelMaxAggregateOutputType = {
    id_komentar: number | null
    id_artikel: string | null
    id_pengguna: string | null
    komentar: string | null
  }

  export type KomentarArtikelCountAggregateOutputType = {
    id_komentar: number
    id_artikel: number
    id_pengguna: number
    komentar: number
    _all: number
  }


  export type KomentarArtikelAvgAggregateInputType = {
    id_komentar?: true
  }

  export type KomentarArtikelSumAggregateInputType = {
    id_komentar?: true
  }

  export type KomentarArtikelMinAggregateInputType = {
    id_komentar?: true
    id_artikel?: true
    id_pengguna?: true
    komentar?: true
  }

  export type KomentarArtikelMaxAggregateInputType = {
    id_komentar?: true
    id_artikel?: true
    id_pengguna?: true
    komentar?: true
  }

  export type KomentarArtikelCountAggregateInputType = {
    id_komentar?: true
    id_artikel?: true
    id_pengguna?: true
    komentar?: true
    _all?: true
  }

  export type KomentarArtikelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KomentarArtikel to aggregate.
     */
    where?: KomentarArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KomentarArtikels to fetch.
     */
    orderBy?: KomentarArtikelOrderByWithRelationInput | KomentarArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KomentarArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KomentarArtikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KomentarArtikels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KomentarArtikels
    **/
    _count?: true | KomentarArtikelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KomentarArtikelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KomentarArtikelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KomentarArtikelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KomentarArtikelMaxAggregateInputType
  }

  export type GetKomentarArtikelAggregateType<T extends KomentarArtikelAggregateArgs> = {
        [P in keyof T & keyof AggregateKomentarArtikel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKomentarArtikel[P]>
      : GetScalarType<T[P], AggregateKomentarArtikel[P]>
  }




  export type KomentarArtikelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KomentarArtikelWhereInput
    orderBy?: KomentarArtikelOrderByWithAggregationInput | KomentarArtikelOrderByWithAggregationInput[]
    by: KomentarArtikelScalarFieldEnum[] | KomentarArtikelScalarFieldEnum
    having?: KomentarArtikelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KomentarArtikelCountAggregateInputType | true
    _avg?: KomentarArtikelAvgAggregateInputType
    _sum?: KomentarArtikelSumAggregateInputType
    _min?: KomentarArtikelMinAggregateInputType
    _max?: KomentarArtikelMaxAggregateInputType
  }

  export type KomentarArtikelGroupByOutputType = {
    id_komentar: number
    id_artikel: string
    id_pengguna: string
    komentar: string
    _count: KomentarArtikelCountAggregateOutputType | null
    _avg: KomentarArtikelAvgAggregateOutputType | null
    _sum: KomentarArtikelSumAggregateOutputType | null
    _min: KomentarArtikelMinAggregateOutputType | null
    _max: KomentarArtikelMaxAggregateOutputType | null
  }

  type GetKomentarArtikelGroupByPayload<T extends KomentarArtikelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KomentarArtikelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KomentarArtikelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KomentarArtikelGroupByOutputType[P]>
            : GetScalarType<T[P], KomentarArtikelGroupByOutputType[P]>
        }
      >
    >


  export type KomentarArtikelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_komentar?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    komentar?: boolean
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["komentarArtikel"]>

  export type KomentarArtikelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_komentar?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    komentar?: boolean
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["komentarArtikel"]>

  export type KomentarArtikelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_komentar?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    komentar?: boolean
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["komentarArtikel"]>

  export type KomentarArtikelSelectScalar = {
    id_komentar?: boolean
    id_artikel?: boolean
    id_pengguna?: boolean
    komentar?: boolean
  }

  export type KomentarArtikelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_komentar" | "id_artikel" | "id_pengguna" | "komentar", ExtArgs["result"]["komentarArtikel"]>
  export type KomentarArtikelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }
  export type KomentarArtikelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }
  export type KomentarArtikelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artikel?: boolean | ArtikelDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }

  export type $KomentarArtikelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KomentarArtikel"
    objects: {
      artikel: Prisma.$ArtikelPayload<ExtArgs>
      pengguna: Prisma.$PenggunaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_komentar: number
      id_artikel: string
      id_pengguna: string
      komentar: string
    }, ExtArgs["result"]["komentarArtikel"]>
    composites: {}
  }

  type KomentarArtikelGetPayload<S extends boolean | null | undefined | KomentarArtikelDefaultArgs> = $Result.GetResult<Prisma.$KomentarArtikelPayload, S>

  type KomentarArtikelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KomentarArtikelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KomentarArtikelCountAggregateInputType | true
    }

  export interface KomentarArtikelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KomentarArtikel'], meta: { name: 'KomentarArtikel' } }
    /**
     * Find zero or one KomentarArtikel that matches the filter.
     * @param {KomentarArtikelFindUniqueArgs} args - Arguments to find a KomentarArtikel
     * @example
     * // Get one KomentarArtikel
     * const komentarArtikel = await prisma.komentarArtikel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KomentarArtikelFindUniqueArgs>(args: SelectSubset<T, KomentarArtikelFindUniqueArgs<ExtArgs>>): Prisma__KomentarArtikelClient<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KomentarArtikel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KomentarArtikelFindUniqueOrThrowArgs} args - Arguments to find a KomentarArtikel
     * @example
     * // Get one KomentarArtikel
     * const komentarArtikel = await prisma.komentarArtikel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KomentarArtikelFindUniqueOrThrowArgs>(args: SelectSubset<T, KomentarArtikelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KomentarArtikelClient<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KomentarArtikel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomentarArtikelFindFirstArgs} args - Arguments to find a KomentarArtikel
     * @example
     * // Get one KomentarArtikel
     * const komentarArtikel = await prisma.komentarArtikel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KomentarArtikelFindFirstArgs>(args?: SelectSubset<T, KomentarArtikelFindFirstArgs<ExtArgs>>): Prisma__KomentarArtikelClient<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KomentarArtikel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomentarArtikelFindFirstOrThrowArgs} args - Arguments to find a KomentarArtikel
     * @example
     * // Get one KomentarArtikel
     * const komentarArtikel = await prisma.komentarArtikel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KomentarArtikelFindFirstOrThrowArgs>(args?: SelectSubset<T, KomentarArtikelFindFirstOrThrowArgs<ExtArgs>>): Prisma__KomentarArtikelClient<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KomentarArtikels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomentarArtikelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KomentarArtikels
     * const komentarArtikels = await prisma.komentarArtikel.findMany()
     * 
     * // Get first 10 KomentarArtikels
     * const komentarArtikels = await prisma.komentarArtikel.findMany({ take: 10 })
     * 
     * // Only select the `id_komentar`
     * const komentarArtikelWithId_komentarOnly = await prisma.komentarArtikel.findMany({ select: { id_komentar: true } })
     * 
     */
    findMany<T extends KomentarArtikelFindManyArgs>(args?: SelectSubset<T, KomentarArtikelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KomentarArtikel.
     * @param {KomentarArtikelCreateArgs} args - Arguments to create a KomentarArtikel.
     * @example
     * // Create one KomentarArtikel
     * const KomentarArtikel = await prisma.komentarArtikel.create({
     *   data: {
     *     // ... data to create a KomentarArtikel
     *   }
     * })
     * 
     */
    create<T extends KomentarArtikelCreateArgs>(args: SelectSubset<T, KomentarArtikelCreateArgs<ExtArgs>>): Prisma__KomentarArtikelClient<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KomentarArtikels.
     * @param {KomentarArtikelCreateManyArgs} args - Arguments to create many KomentarArtikels.
     * @example
     * // Create many KomentarArtikels
     * const komentarArtikel = await prisma.komentarArtikel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KomentarArtikelCreateManyArgs>(args?: SelectSubset<T, KomentarArtikelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KomentarArtikels and returns the data saved in the database.
     * @param {KomentarArtikelCreateManyAndReturnArgs} args - Arguments to create many KomentarArtikels.
     * @example
     * // Create many KomentarArtikels
     * const komentarArtikel = await prisma.komentarArtikel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KomentarArtikels and only return the `id_komentar`
     * const komentarArtikelWithId_komentarOnly = await prisma.komentarArtikel.createManyAndReturn({
     *   select: { id_komentar: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KomentarArtikelCreateManyAndReturnArgs>(args?: SelectSubset<T, KomentarArtikelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KomentarArtikel.
     * @param {KomentarArtikelDeleteArgs} args - Arguments to delete one KomentarArtikel.
     * @example
     * // Delete one KomentarArtikel
     * const KomentarArtikel = await prisma.komentarArtikel.delete({
     *   where: {
     *     // ... filter to delete one KomentarArtikel
     *   }
     * })
     * 
     */
    delete<T extends KomentarArtikelDeleteArgs>(args: SelectSubset<T, KomentarArtikelDeleteArgs<ExtArgs>>): Prisma__KomentarArtikelClient<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KomentarArtikel.
     * @param {KomentarArtikelUpdateArgs} args - Arguments to update one KomentarArtikel.
     * @example
     * // Update one KomentarArtikel
     * const komentarArtikel = await prisma.komentarArtikel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KomentarArtikelUpdateArgs>(args: SelectSubset<T, KomentarArtikelUpdateArgs<ExtArgs>>): Prisma__KomentarArtikelClient<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KomentarArtikels.
     * @param {KomentarArtikelDeleteManyArgs} args - Arguments to filter KomentarArtikels to delete.
     * @example
     * // Delete a few KomentarArtikels
     * const { count } = await prisma.komentarArtikel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KomentarArtikelDeleteManyArgs>(args?: SelectSubset<T, KomentarArtikelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KomentarArtikels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomentarArtikelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KomentarArtikels
     * const komentarArtikel = await prisma.komentarArtikel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KomentarArtikelUpdateManyArgs>(args: SelectSubset<T, KomentarArtikelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KomentarArtikels and returns the data updated in the database.
     * @param {KomentarArtikelUpdateManyAndReturnArgs} args - Arguments to update many KomentarArtikels.
     * @example
     * // Update many KomentarArtikels
     * const komentarArtikel = await prisma.komentarArtikel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KomentarArtikels and only return the `id_komentar`
     * const komentarArtikelWithId_komentarOnly = await prisma.komentarArtikel.updateManyAndReturn({
     *   select: { id_komentar: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KomentarArtikelUpdateManyAndReturnArgs>(args: SelectSubset<T, KomentarArtikelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KomentarArtikel.
     * @param {KomentarArtikelUpsertArgs} args - Arguments to update or create a KomentarArtikel.
     * @example
     * // Update or create a KomentarArtikel
     * const komentarArtikel = await prisma.komentarArtikel.upsert({
     *   create: {
     *     // ... data to create a KomentarArtikel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KomentarArtikel we want to update
     *   }
     * })
     */
    upsert<T extends KomentarArtikelUpsertArgs>(args: SelectSubset<T, KomentarArtikelUpsertArgs<ExtArgs>>): Prisma__KomentarArtikelClient<$Result.GetResult<Prisma.$KomentarArtikelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KomentarArtikels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomentarArtikelCountArgs} args - Arguments to filter KomentarArtikels to count.
     * @example
     * // Count the number of KomentarArtikels
     * const count = await prisma.komentarArtikel.count({
     *   where: {
     *     // ... the filter for the KomentarArtikels we want to count
     *   }
     * })
    **/
    count<T extends KomentarArtikelCountArgs>(
      args?: Subset<T, KomentarArtikelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KomentarArtikelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KomentarArtikel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomentarArtikelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KomentarArtikelAggregateArgs>(args: Subset<T, KomentarArtikelAggregateArgs>): Prisma.PrismaPromise<GetKomentarArtikelAggregateType<T>>

    /**
     * Group by KomentarArtikel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KomentarArtikelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KomentarArtikelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KomentarArtikelGroupByArgs['orderBy'] }
        : { orderBy?: KomentarArtikelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KomentarArtikelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKomentarArtikelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KomentarArtikel model
   */
  readonly fields: KomentarArtikelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KomentarArtikel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KomentarArtikelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artikel<T extends ArtikelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtikelDefaultArgs<ExtArgs>>): Prisma__ArtikelClient<$Result.GetResult<Prisma.$ArtikelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pengguna<T extends PenggunaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PenggunaDefaultArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KomentarArtikel model
   */
  interface KomentarArtikelFieldRefs {
    readonly id_komentar: FieldRef<"KomentarArtikel", 'Int'>
    readonly id_artikel: FieldRef<"KomentarArtikel", 'String'>
    readonly id_pengguna: FieldRef<"KomentarArtikel", 'String'>
    readonly komentar: FieldRef<"KomentarArtikel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KomentarArtikel findUnique
   */
  export type KomentarArtikelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KomentarArtikel to fetch.
     */
    where: KomentarArtikelWhereUniqueInput
  }

  /**
   * KomentarArtikel findUniqueOrThrow
   */
  export type KomentarArtikelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KomentarArtikel to fetch.
     */
    where: KomentarArtikelWhereUniqueInput
  }

  /**
   * KomentarArtikel findFirst
   */
  export type KomentarArtikelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KomentarArtikel to fetch.
     */
    where?: KomentarArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KomentarArtikels to fetch.
     */
    orderBy?: KomentarArtikelOrderByWithRelationInput | KomentarArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KomentarArtikels.
     */
    cursor?: KomentarArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KomentarArtikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KomentarArtikels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KomentarArtikels.
     */
    distinct?: KomentarArtikelScalarFieldEnum | KomentarArtikelScalarFieldEnum[]
  }

  /**
   * KomentarArtikel findFirstOrThrow
   */
  export type KomentarArtikelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KomentarArtikel to fetch.
     */
    where?: KomentarArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KomentarArtikels to fetch.
     */
    orderBy?: KomentarArtikelOrderByWithRelationInput | KomentarArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KomentarArtikels.
     */
    cursor?: KomentarArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KomentarArtikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KomentarArtikels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KomentarArtikels.
     */
    distinct?: KomentarArtikelScalarFieldEnum | KomentarArtikelScalarFieldEnum[]
  }

  /**
   * KomentarArtikel findMany
   */
  export type KomentarArtikelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    /**
     * Filter, which KomentarArtikels to fetch.
     */
    where?: KomentarArtikelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KomentarArtikels to fetch.
     */
    orderBy?: KomentarArtikelOrderByWithRelationInput | KomentarArtikelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KomentarArtikels.
     */
    cursor?: KomentarArtikelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KomentarArtikels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KomentarArtikels.
     */
    skip?: number
    distinct?: KomentarArtikelScalarFieldEnum | KomentarArtikelScalarFieldEnum[]
  }

  /**
   * KomentarArtikel create
   */
  export type KomentarArtikelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    /**
     * The data needed to create a KomentarArtikel.
     */
    data: XOR<KomentarArtikelCreateInput, KomentarArtikelUncheckedCreateInput>
  }

  /**
   * KomentarArtikel createMany
   */
  export type KomentarArtikelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KomentarArtikels.
     */
    data: KomentarArtikelCreateManyInput | KomentarArtikelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KomentarArtikel createManyAndReturn
   */
  export type KomentarArtikelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * The data used to create many KomentarArtikels.
     */
    data: KomentarArtikelCreateManyInput | KomentarArtikelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KomentarArtikel update
   */
  export type KomentarArtikelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    /**
     * The data needed to update a KomentarArtikel.
     */
    data: XOR<KomentarArtikelUpdateInput, KomentarArtikelUncheckedUpdateInput>
    /**
     * Choose, which KomentarArtikel to update.
     */
    where: KomentarArtikelWhereUniqueInput
  }

  /**
   * KomentarArtikel updateMany
   */
  export type KomentarArtikelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KomentarArtikels.
     */
    data: XOR<KomentarArtikelUpdateManyMutationInput, KomentarArtikelUncheckedUpdateManyInput>
    /**
     * Filter which KomentarArtikels to update
     */
    where?: KomentarArtikelWhereInput
    /**
     * Limit how many KomentarArtikels to update.
     */
    limit?: number
  }

  /**
   * KomentarArtikel updateManyAndReturn
   */
  export type KomentarArtikelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * The data used to update KomentarArtikels.
     */
    data: XOR<KomentarArtikelUpdateManyMutationInput, KomentarArtikelUncheckedUpdateManyInput>
    /**
     * Filter which KomentarArtikels to update
     */
    where?: KomentarArtikelWhereInput
    /**
     * Limit how many KomentarArtikels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KomentarArtikel upsert
   */
  export type KomentarArtikelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    /**
     * The filter to search for the KomentarArtikel to update in case it exists.
     */
    where: KomentarArtikelWhereUniqueInput
    /**
     * In case the KomentarArtikel found by the `where` argument doesn't exist, create a new KomentarArtikel with this data.
     */
    create: XOR<KomentarArtikelCreateInput, KomentarArtikelUncheckedCreateInput>
    /**
     * In case the KomentarArtikel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KomentarArtikelUpdateInput, KomentarArtikelUncheckedUpdateInput>
  }

  /**
   * KomentarArtikel delete
   */
  export type KomentarArtikelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
    /**
     * Filter which KomentarArtikel to delete.
     */
    where: KomentarArtikelWhereUniqueInput
  }

  /**
   * KomentarArtikel deleteMany
   */
  export type KomentarArtikelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KomentarArtikels to delete
     */
    where?: KomentarArtikelWhereInput
    /**
     * Limit how many KomentarArtikels to delete.
     */
    limit?: number
  }

  /**
   * KomentarArtikel without action
   */
  export type KomentarArtikelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KomentarArtikel
     */
    select?: KomentarArtikelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KomentarArtikel
     */
    omit?: KomentarArtikelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KomentarArtikelInclude<ExtArgs> | null
  }


  /**
   * Model Workshop
   */

  export type AggregateWorkshop = {
    _count: WorkshopCountAggregateOutputType | null
    _avg: WorkshopAvgAggregateOutputType | null
    _sum: WorkshopSumAggregateOutputType | null
    _min: WorkshopMinAggregateOutputType | null
    _max: WorkshopMaxAggregateOutputType | null
  }

  export type WorkshopAvgAggregateOutputType = {
    harga_workshop: Decimal | null
    kapasitas: number | null
    lat_lokasi: number | null
    long_lokasi: number | null
    id_kabupaten: number | null
  }

  export type WorkshopSumAggregateOutputType = {
    harga_workshop: Decimal | null
    kapasitas: number | null
    lat_lokasi: number | null
    long_lokasi: number | null
    id_kabupaten: number | null
  }

  export type WorkshopMinAggregateOutputType = {
    id_workshop: string | null
    judul_workshop: string | null
    tanggal_workshop: Date | null
    alaamt_lengkap_workshop: string | null
    deskripsi_workshop: string | null
    harga_workshop: Decimal | null
    kapasitas: number | null
    status_verifikasi: boolean | null
    lat_lokasi: number | null
    long_lokasi: number | null
    gambar_workshop: string | null
    status_aktif: boolean | null
    id_facilitator: string | null
    id_kabupaten: number | null
  }

  export type WorkshopMaxAggregateOutputType = {
    id_workshop: string | null
    judul_workshop: string | null
    tanggal_workshop: Date | null
    alaamt_lengkap_workshop: string | null
    deskripsi_workshop: string | null
    harga_workshop: Decimal | null
    kapasitas: number | null
    status_verifikasi: boolean | null
    lat_lokasi: number | null
    long_lokasi: number | null
    gambar_workshop: string | null
    status_aktif: boolean | null
    id_facilitator: string | null
    id_kabupaten: number | null
  }

  export type WorkshopCountAggregateOutputType = {
    id_workshop: number
    judul_workshop: number
    tanggal_workshop: number
    alaamt_lengkap_workshop: number
    deskripsi_workshop: number
    harga_workshop: number
    kapasitas: number
    status_verifikasi: number
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: number
    status_aktif: number
    id_facilitator: number
    id_kabupaten: number
    _all: number
  }


  export type WorkshopAvgAggregateInputType = {
    harga_workshop?: true
    kapasitas?: true
    lat_lokasi?: true
    long_lokasi?: true
    id_kabupaten?: true
  }

  export type WorkshopSumAggregateInputType = {
    harga_workshop?: true
    kapasitas?: true
    lat_lokasi?: true
    long_lokasi?: true
    id_kabupaten?: true
  }

  export type WorkshopMinAggregateInputType = {
    id_workshop?: true
    judul_workshop?: true
    tanggal_workshop?: true
    alaamt_lengkap_workshop?: true
    deskripsi_workshop?: true
    harga_workshop?: true
    kapasitas?: true
    status_verifikasi?: true
    lat_lokasi?: true
    long_lokasi?: true
    gambar_workshop?: true
    status_aktif?: true
    id_facilitator?: true
    id_kabupaten?: true
  }

  export type WorkshopMaxAggregateInputType = {
    id_workshop?: true
    judul_workshop?: true
    tanggal_workshop?: true
    alaamt_lengkap_workshop?: true
    deskripsi_workshop?: true
    harga_workshop?: true
    kapasitas?: true
    status_verifikasi?: true
    lat_lokasi?: true
    long_lokasi?: true
    gambar_workshop?: true
    status_aktif?: true
    id_facilitator?: true
    id_kabupaten?: true
  }

  export type WorkshopCountAggregateInputType = {
    id_workshop?: true
    judul_workshop?: true
    tanggal_workshop?: true
    alaamt_lengkap_workshop?: true
    deskripsi_workshop?: true
    harga_workshop?: true
    kapasitas?: true
    status_verifikasi?: true
    lat_lokasi?: true
    long_lokasi?: true
    gambar_workshop?: true
    status_aktif?: true
    id_facilitator?: true
    id_kabupaten?: true
    _all?: true
  }

  export type WorkshopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workshop to aggregate.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workshops
    **/
    _count?: true | WorkshopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkshopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkshopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopMaxAggregateInputType
  }

  export type GetWorkshopAggregateType<T extends WorkshopAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshop[P]>
      : GetScalarType<T[P], AggregateWorkshop[P]>
  }




  export type WorkshopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopWhereInput
    orderBy?: WorkshopOrderByWithAggregationInput | WorkshopOrderByWithAggregationInput[]
    by: WorkshopScalarFieldEnum[] | WorkshopScalarFieldEnum
    having?: WorkshopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopCountAggregateInputType | true
    _avg?: WorkshopAvgAggregateInputType
    _sum?: WorkshopSumAggregateInputType
    _min?: WorkshopMinAggregateInputType
    _max?: WorkshopMaxAggregateInputType
  }

  export type WorkshopGroupByOutputType = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal
    kapasitas: number
    status_verifikasi: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif: boolean
    id_facilitator: string
    id_kabupaten: number
    _count: WorkshopCountAggregateOutputType | null
    _avg: WorkshopAvgAggregateOutputType | null
    _sum: WorkshopSumAggregateOutputType | null
    _min: WorkshopMinAggregateOutputType | null
    _max: WorkshopMaxAggregateOutputType | null
  }

  type GetWorkshopGroupByPayload<T extends WorkshopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_workshop?: boolean
    judul_workshop?: boolean
    tanggal_workshop?: boolean
    alaamt_lengkap_workshop?: boolean
    deskripsi_workshop?: boolean
    harga_workshop?: boolean
    kapasitas?: boolean
    status_verifikasi?: boolean
    lat_lokasi?: boolean
    long_lokasi?: boolean
    gambar_workshop?: boolean
    status_aktif?: boolean
    id_facilitator?: boolean
    id_kabupaten?: boolean
    facilitator?: boolean | FacilitatorDefaultArgs<ExtArgs>
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
    pendaftaran?: boolean | Workshop$pendaftaranArgs<ExtArgs>
    _count?: boolean | WorkshopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshop"]>

  export type WorkshopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_workshop?: boolean
    judul_workshop?: boolean
    tanggal_workshop?: boolean
    alaamt_lengkap_workshop?: boolean
    deskripsi_workshop?: boolean
    harga_workshop?: boolean
    kapasitas?: boolean
    status_verifikasi?: boolean
    lat_lokasi?: boolean
    long_lokasi?: boolean
    gambar_workshop?: boolean
    status_aktif?: boolean
    id_facilitator?: boolean
    id_kabupaten?: boolean
    facilitator?: boolean | FacilitatorDefaultArgs<ExtArgs>
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshop"]>

  export type WorkshopSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_workshop?: boolean
    judul_workshop?: boolean
    tanggal_workshop?: boolean
    alaamt_lengkap_workshop?: boolean
    deskripsi_workshop?: boolean
    harga_workshop?: boolean
    kapasitas?: boolean
    status_verifikasi?: boolean
    lat_lokasi?: boolean
    long_lokasi?: boolean
    gambar_workshop?: boolean
    status_aktif?: boolean
    id_facilitator?: boolean
    id_kabupaten?: boolean
    facilitator?: boolean | FacilitatorDefaultArgs<ExtArgs>
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshop"]>

  export type WorkshopSelectScalar = {
    id_workshop?: boolean
    judul_workshop?: boolean
    tanggal_workshop?: boolean
    alaamt_lengkap_workshop?: boolean
    deskripsi_workshop?: boolean
    harga_workshop?: boolean
    kapasitas?: boolean
    status_verifikasi?: boolean
    lat_lokasi?: boolean
    long_lokasi?: boolean
    gambar_workshop?: boolean
    status_aktif?: boolean
    id_facilitator?: boolean
    id_kabupaten?: boolean
  }

  export type WorkshopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_workshop" | "judul_workshop" | "tanggal_workshop" | "alaamt_lengkap_workshop" | "deskripsi_workshop" | "harga_workshop" | "kapasitas" | "status_verifikasi" | "lat_lokasi" | "long_lokasi" | "gambar_workshop" | "status_aktif" | "id_facilitator" | "id_kabupaten", ExtArgs["result"]["workshop"]>
  export type WorkshopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilitator?: boolean | FacilitatorDefaultArgs<ExtArgs>
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
    pendaftaran?: boolean | Workshop$pendaftaranArgs<ExtArgs>
    _count?: boolean | WorkshopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkshopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilitator?: boolean | FacilitatorDefaultArgs<ExtArgs>
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
  }
  export type WorkshopIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facilitator?: boolean | FacilitatorDefaultArgs<ExtArgs>
    kabupaten?: boolean | KabupatenDefaultArgs<ExtArgs>
  }

  export type $WorkshopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workshop"
    objects: {
      facilitator: Prisma.$FacilitatorPayload<ExtArgs>
      kabupaten: Prisma.$KabupatenPayload<ExtArgs>
      pendaftaran: Prisma.$WorkshopTerdaftarPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_workshop: string
      judul_workshop: string
      tanggal_workshop: Date
      alaamt_lengkap_workshop: string
      deskripsi_workshop: string
      harga_workshop: Prisma.Decimal
      kapasitas: number
      status_verifikasi: boolean
      lat_lokasi: number
      long_lokasi: number
      gambar_workshop: string
      status_aktif: boolean
      id_facilitator: string
      id_kabupaten: number
    }, ExtArgs["result"]["workshop"]>
    composites: {}
  }

  type WorkshopGetPayload<S extends boolean | null | undefined | WorkshopDefaultArgs> = $Result.GetResult<Prisma.$WorkshopPayload, S>

  type WorkshopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopCountAggregateInputType | true
    }

  export interface WorkshopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workshop'], meta: { name: 'Workshop' } }
    /**
     * Find zero or one Workshop that matches the filter.
     * @param {WorkshopFindUniqueArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopFindUniqueArgs>(args: SelectSubset<T, WorkshopFindUniqueArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workshop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopFindUniqueOrThrowArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workshop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopFindFirstArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopFindFirstArgs>(args?: SelectSubset<T, WorkshopFindFirstArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workshop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopFindFirstOrThrowArgs} args - Arguments to find a Workshop
     * @example
     * // Get one Workshop
     * const workshop = await prisma.workshop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workshops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workshops
     * const workshops = await prisma.workshop.findMany()
     * 
     * // Get first 10 Workshops
     * const workshops = await prisma.workshop.findMany({ take: 10 })
     * 
     * // Only select the `id_workshop`
     * const workshopWithId_workshopOnly = await prisma.workshop.findMany({ select: { id_workshop: true } })
     * 
     */
    findMany<T extends WorkshopFindManyArgs>(args?: SelectSubset<T, WorkshopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workshop.
     * @param {WorkshopCreateArgs} args - Arguments to create a Workshop.
     * @example
     * // Create one Workshop
     * const Workshop = await prisma.workshop.create({
     *   data: {
     *     // ... data to create a Workshop
     *   }
     * })
     * 
     */
    create<T extends WorkshopCreateArgs>(args: SelectSubset<T, WorkshopCreateArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workshops.
     * @param {WorkshopCreateManyArgs} args - Arguments to create many Workshops.
     * @example
     * // Create many Workshops
     * const workshop = await prisma.workshop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopCreateManyArgs>(args?: SelectSubset<T, WorkshopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workshops and returns the data saved in the database.
     * @param {WorkshopCreateManyAndReturnArgs} args - Arguments to create many Workshops.
     * @example
     * // Create many Workshops
     * const workshop = await prisma.workshop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workshops and only return the `id_workshop`
     * const workshopWithId_workshopOnly = await prisma.workshop.createManyAndReturn({
     *   select: { id_workshop: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workshop.
     * @param {WorkshopDeleteArgs} args - Arguments to delete one Workshop.
     * @example
     * // Delete one Workshop
     * const Workshop = await prisma.workshop.delete({
     *   where: {
     *     // ... filter to delete one Workshop
     *   }
     * })
     * 
     */
    delete<T extends WorkshopDeleteArgs>(args: SelectSubset<T, WorkshopDeleteArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workshop.
     * @param {WorkshopUpdateArgs} args - Arguments to update one Workshop.
     * @example
     * // Update one Workshop
     * const workshop = await prisma.workshop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopUpdateArgs>(args: SelectSubset<T, WorkshopUpdateArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workshops.
     * @param {WorkshopDeleteManyArgs} args - Arguments to filter Workshops to delete.
     * @example
     * // Delete a few Workshops
     * const { count } = await prisma.workshop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopDeleteManyArgs>(args?: SelectSubset<T, WorkshopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workshops
     * const workshop = await prisma.workshop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopUpdateManyArgs>(args: SelectSubset<T, WorkshopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workshops and returns the data updated in the database.
     * @param {WorkshopUpdateManyAndReturnArgs} args - Arguments to update many Workshops.
     * @example
     * // Update many Workshops
     * const workshop = await prisma.workshop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workshops and only return the `id_workshop`
     * const workshopWithId_workshopOnly = await prisma.workshop.updateManyAndReturn({
     *   select: { id_workshop: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workshop.
     * @param {WorkshopUpsertArgs} args - Arguments to update or create a Workshop.
     * @example
     * // Update or create a Workshop
     * const workshop = await prisma.workshop.upsert({
     *   create: {
     *     // ... data to create a Workshop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workshop we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopUpsertArgs>(args: SelectSubset<T, WorkshopUpsertArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopCountArgs} args - Arguments to filter Workshops to count.
     * @example
     * // Count the number of Workshops
     * const count = await prisma.workshop.count({
     *   where: {
     *     // ... the filter for the Workshops we want to count
     *   }
     * })
    **/
    count<T extends WorkshopCountArgs>(
      args?: Subset<T, WorkshopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workshop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopAggregateArgs>(args: Subset<T, WorkshopAggregateArgs>): Prisma.PrismaPromise<GetWorkshopAggregateType<T>>

    /**
     * Group by Workshop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workshop model
   */
  readonly fields: WorkshopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workshop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facilitator<T extends FacilitatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacilitatorDefaultArgs<ExtArgs>>): Prisma__FacilitatorClient<$Result.GetResult<Prisma.$FacilitatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kabupaten<T extends KabupatenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KabupatenDefaultArgs<ExtArgs>>): Prisma__KabupatenClient<$Result.GetResult<Prisma.$KabupatenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pendaftaran<T extends Workshop$pendaftaranArgs<ExtArgs> = {}>(args?: Subset<T, Workshop$pendaftaranArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workshop model
   */
  interface WorkshopFieldRefs {
    readonly id_workshop: FieldRef<"Workshop", 'String'>
    readonly judul_workshop: FieldRef<"Workshop", 'String'>
    readonly tanggal_workshop: FieldRef<"Workshop", 'DateTime'>
    readonly alaamt_lengkap_workshop: FieldRef<"Workshop", 'String'>
    readonly deskripsi_workshop: FieldRef<"Workshop", 'String'>
    readonly harga_workshop: FieldRef<"Workshop", 'Decimal'>
    readonly kapasitas: FieldRef<"Workshop", 'Int'>
    readonly status_verifikasi: FieldRef<"Workshop", 'Boolean'>
    readonly lat_lokasi: FieldRef<"Workshop", 'Float'>
    readonly long_lokasi: FieldRef<"Workshop", 'Float'>
    readonly gambar_workshop: FieldRef<"Workshop", 'String'>
    readonly status_aktif: FieldRef<"Workshop", 'Boolean'>
    readonly id_facilitator: FieldRef<"Workshop", 'String'>
    readonly id_kabupaten: FieldRef<"Workshop", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Workshop findUnique
   */
  export type WorkshopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop findUniqueOrThrow
   */
  export type WorkshopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop findFirst
   */
  export type WorkshopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workshops.
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workshops.
     */
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Workshop findFirstOrThrow
   */
  export type WorkshopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshop to fetch.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workshops.
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workshops.
     */
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Workshop findMany
   */
  export type WorkshopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter, which Workshops to fetch.
     */
    where?: WorkshopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workshops to fetch.
     */
    orderBy?: WorkshopOrderByWithRelationInput | WorkshopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workshops.
     */
    cursor?: WorkshopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workshops.
     */
    skip?: number
    distinct?: WorkshopScalarFieldEnum | WorkshopScalarFieldEnum[]
  }

  /**
   * Workshop create
   */
  export type WorkshopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * The data needed to create a Workshop.
     */
    data: XOR<WorkshopCreateInput, WorkshopUncheckedCreateInput>
  }

  /**
   * Workshop createMany
   */
  export type WorkshopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workshops.
     */
    data: WorkshopCreateManyInput | WorkshopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workshop createManyAndReturn
   */
  export type WorkshopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * The data used to create many Workshops.
     */
    data: WorkshopCreateManyInput | WorkshopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workshop update
   */
  export type WorkshopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * The data needed to update a Workshop.
     */
    data: XOR<WorkshopUpdateInput, WorkshopUncheckedUpdateInput>
    /**
     * Choose, which Workshop to update.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop updateMany
   */
  export type WorkshopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workshops.
     */
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyInput>
    /**
     * Filter which Workshops to update
     */
    where?: WorkshopWhereInput
    /**
     * Limit how many Workshops to update.
     */
    limit?: number
  }

  /**
   * Workshop updateManyAndReturn
   */
  export type WorkshopUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * The data used to update Workshops.
     */
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyInput>
    /**
     * Filter which Workshops to update
     */
    where?: WorkshopWhereInput
    /**
     * Limit how many Workshops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workshop upsert
   */
  export type WorkshopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * The filter to search for the Workshop to update in case it exists.
     */
    where: WorkshopWhereUniqueInput
    /**
     * In case the Workshop found by the `where` argument doesn't exist, create a new Workshop with this data.
     */
    create: XOR<WorkshopCreateInput, WorkshopUncheckedCreateInput>
    /**
     * In case the Workshop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopUpdateInput, WorkshopUncheckedUpdateInput>
  }

  /**
   * Workshop delete
   */
  export type WorkshopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
    /**
     * Filter which Workshop to delete.
     */
    where: WorkshopWhereUniqueInput
  }

  /**
   * Workshop deleteMany
   */
  export type WorkshopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workshops to delete
     */
    where?: WorkshopWhereInput
    /**
     * Limit how many Workshops to delete.
     */
    limit?: number
  }

  /**
   * Workshop.pendaftaran
   */
  export type Workshop$pendaftaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    where?: WorkshopTerdaftarWhereInput
    orderBy?: WorkshopTerdaftarOrderByWithRelationInput | WorkshopTerdaftarOrderByWithRelationInput[]
    cursor?: WorkshopTerdaftarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkshopTerdaftarScalarFieldEnum | WorkshopTerdaftarScalarFieldEnum[]
  }

  /**
   * Workshop without action
   */
  export type WorkshopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workshop
     */
    select?: WorkshopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workshop
     */
    omit?: WorkshopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopInclude<ExtArgs> | null
  }


  /**
   * Model WorkshopTerdaftar
   */

  export type AggregateWorkshopTerdaftar = {
    _count: WorkshopTerdaftarCountAggregateOutputType | null
    _avg: WorkshopTerdaftarAvgAggregateOutputType | null
    _sum: WorkshopTerdaftarSumAggregateOutputType | null
    _min: WorkshopTerdaftarMinAggregateOutputType | null
    _max: WorkshopTerdaftarMaxAggregateOutputType | null
  }

  export type WorkshopTerdaftarAvgAggregateOutputType = {
    id_pendaftaran: number | null
  }

  export type WorkshopTerdaftarSumAggregateOutputType = {
    id_pendaftaran: number | null
  }

  export type WorkshopTerdaftarMinAggregateOutputType = {
    id_pendaftaran: number | null
    nama_peserta: string | null
    email_peserta: string | null
    nomor_telepon_peserta: string | null
    tanggal_pendaftaran: Date | null
    status_pembayaran: string | null
    nomor_tiket: string | null
    id_pengguna: string | null
    id_workshop: string | null
  }

  export type WorkshopTerdaftarMaxAggregateOutputType = {
    id_pendaftaran: number | null
    nama_peserta: string | null
    email_peserta: string | null
    nomor_telepon_peserta: string | null
    tanggal_pendaftaran: Date | null
    status_pembayaran: string | null
    nomor_tiket: string | null
    id_pengguna: string | null
    id_workshop: string | null
  }

  export type WorkshopTerdaftarCountAggregateOutputType = {
    id_pendaftaran: number
    nama_peserta: number
    email_peserta: number
    nomor_telepon_peserta: number
    tanggal_pendaftaran: number
    status_pembayaran: number
    nomor_tiket: number
    id_pengguna: number
    id_workshop: number
    _all: number
  }


  export type WorkshopTerdaftarAvgAggregateInputType = {
    id_pendaftaran?: true
  }

  export type WorkshopTerdaftarSumAggregateInputType = {
    id_pendaftaran?: true
  }

  export type WorkshopTerdaftarMinAggregateInputType = {
    id_pendaftaran?: true
    nama_peserta?: true
    email_peserta?: true
    nomor_telepon_peserta?: true
    tanggal_pendaftaran?: true
    status_pembayaran?: true
    nomor_tiket?: true
    id_pengguna?: true
    id_workshop?: true
  }

  export type WorkshopTerdaftarMaxAggregateInputType = {
    id_pendaftaran?: true
    nama_peserta?: true
    email_peserta?: true
    nomor_telepon_peserta?: true
    tanggal_pendaftaran?: true
    status_pembayaran?: true
    nomor_tiket?: true
    id_pengguna?: true
    id_workshop?: true
  }

  export type WorkshopTerdaftarCountAggregateInputType = {
    id_pendaftaran?: true
    nama_peserta?: true
    email_peserta?: true
    nomor_telepon_peserta?: true
    tanggal_pendaftaran?: true
    status_pembayaran?: true
    nomor_tiket?: true
    id_pengguna?: true
    id_workshop?: true
    _all?: true
  }

  export type WorkshopTerdaftarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopTerdaftar to aggregate.
     */
    where?: WorkshopTerdaftarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopTerdaftars to fetch.
     */
    orderBy?: WorkshopTerdaftarOrderByWithRelationInput | WorkshopTerdaftarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkshopTerdaftarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopTerdaftars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopTerdaftars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkshopTerdaftars
    **/
    _count?: true | WorkshopTerdaftarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkshopTerdaftarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkshopTerdaftarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopTerdaftarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopTerdaftarMaxAggregateInputType
  }

  export type GetWorkshopTerdaftarAggregateType<T extends WorkshopTerdaftarAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshopTerdaftar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshopTerdaftar[P]>
      : GetScalarType<T[P], AggregateWorkshopTerdaftar[P]>
  }




  export type WorkshopTerdaftarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkshopTerdaftarWhereInput
    orderBy?: WorkshopTerdaftarOrderByWithAggregationInput | WorkshopTerdaftarOrderByWithAggregationInput[]
    by: WorkshopTerdaftarScalarFieldEnum[] | WorkshopTerdaftarScalarFieldEnum
    having?: WorkshopTerdaftarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopTerdaftarCountAggregateInputType | true
    _avg?: WorkshopTerdaftarAvgAggregateInputType
    _sum?: WorkshopTerdaftarSumAggregateInputType
    _min?: WorkshopTerdaftarMinAggregateInputType
    _max?: WorkshopTerdaftarMaxAggregateInputType
  }

  export type WorkshopTerdaftarGroupByOutputType = {
    id_pendaftaran: number
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran: Date
    status_pembayaran: string
    nomor_tiket: string | null
    id_pengguna: string
    id_workshop: string
    _count: WorkshopTerdaftarCountAggregateOutputType | null
    _avg: WorkshopTerdaftarAvgAggregateOutputType | null
    _sum: WorkshopTerdaftarSumAggregateOutputType | null
    _min: WorkshopTerdaftarMinAggregateOutputType | null
    _max: WorkshopTerdaftarMaxAggregateOutputType | null
  }

  type GetWorkshopTerdaftarGroupByPayload<T extends WorkshopTerdaftarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopTerdaftarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopTerdaftarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopTerdaftarGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopTerdaftarGroupByOutputType[P]>
        }
      >
    >


  export type WorkshopTerdaftarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pendaftaran?: boolean
    nama_peserta?: boolean
    email_peserta?: boolean
    nomor_telepon_peserta?: boolean
    tanggal_pendaftaran?: boolean
    status_pembayaran?: boolean
    nomor_tiket?: boolean
    id_pengguna?: boolean
    id_workshop?: boolean
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopTerdaftar"]>

  export type WorkshopTerdaftarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pendaftaran?: boolean
    nama_peserta?: boolean
    email_peserta?: boolean
    nomor_telepon_peserta?: boolean
    tanggal_pendaftaran?: boolean
    status_pembayaran?: boolean
    nomor_tiket?: boolean
    id_pengguna?: boolean
    id_workshop?: boolean
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopTerdaftar"]>

  export type WorkshopTerdaftarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pendaftaran?: boolean
    nama_peserta?: boolean
    email_peserta?: boolean
    nomor_telepon_peserta?: boolean
    tanggal_pendaftaran?: boolean
    status_pembayaran?: boolean
    nomor_tiket?: boolean
    id_pengguna?: boolean
    id_workshop?: boolean
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshopTerdaftar"]>

  export type WorkshopTerdaftarSelectScalar = {
    id_pendaftaran?: boolean
    nama_peserta?: boolean
    email_peserta?: boolean
    nomor_telepon_peserta?: boolean
    tanggal_pendaftaran?: boolean
    status_pembayaran?: boolean
    nomor_tiket?: boolean
    id_pengguna?: boolean
    id_workshop?: boolean
  }

  export type WorkshopTerdaftarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_pendaftaran" | "nama_peserta" | "email_peserta" | "nomor_telepon_peserta" | "tanggal_pendaftaran" | "status_pembayaran" | "nomor_tiket" | "id_pengguna" | "id_workshop", ExtArgs["result"]["workshopTerdaftar"]>
  export type WorkshopTerdaftarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }
  export type WorkshopTerdaftarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }
  export type WorkshopTerdaftarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    workshop?: boolean | WorkshopDefaultArgs<ExtArgs>
  }

  export type $WorkshopTerdaftarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkshopTerdaftar"
    objects: {
      pengguna: Prisma.$PenggunaPayload<ExtArgs>
      workshop: Prisma.$WorkshopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pendaftaran: number
      nama_peserta: string
      email_peserta: string
      nomor_telepon_peserta: string
      tanggal_pendaftaran: Date
      status_pembayaran: string
      nomor_tiket: string | null
      id_pengguna: string
      id_workshop: string
    }, ExtArgs["result"]["workshopTerdaftar"]>
    composites: {}
  }

  type WorkshopTerdaftarGetPayload<S extends boolean | null | undefined | WorkshopTerdaftarDefaultArgs> = $Result.GetResult<Prisma.$WorkshopTerdaftarPayload, S>

  type WorkshopTerdaftarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkshopTerdaftarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopTerdaftarCountAggregateInputType | true
    }

  export interface WorkshopTerdaftarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkshopTerdaftar'], meta: { name: 'WorkshopTerdaftar' } }
    /**
     * Find zero or one WorkshopTerdaftar that matches the filter.
     * @param {WorkshopTerdaftarFindUniqueArgs} args - Arguments to find a WorkshopTerdaftar
     * @example
     * // Get one WorkshopTerdaftar
     * const workshopTerdaftar = await prisma.workshopTerdaftar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkshopTerdaftarFindUniqueArgs>(args: SelectSubset<T, WorkshopTerdaftarFindUniqueArgs<ExtArgs>>): Prisma__WorkshopTerdaftarClient<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkshopTerdaftar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkshopTerdaftarFindUniqueOrThrowArgs} args - Arguments to find a WorkshopTerdaftar
     * @example
     * // Get one WorkshopTerdaftar
     * const workshopTerdaftar = await prisma.workshopTerdaftar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkshopTerdaftarFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkshopTerdaftarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkshopTerdaftarClient<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopTerdaftar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTerdaftarFindFirstArgs} args - Arguments to find a WorkshopTerdaftar
     * @example
     * // Get one WorkshopTerdaftar
     * const workshopTerdaftar = await prisma.workshopTerdaftar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkshopTerdaftarFindFirstArgs>(args?: SelectSubset<T, WorkshopTerdaftarFindFirstArgs<ExtArgs>>): Prisma__WorkshopTerdaftarClient<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkshopTerdaftar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTerdaftarFindFirstOrThrowArgs} args - Arguments to find a WorkshopTerdaftar
     * @example
     * // Get one WorkshopTerdaftar
     * const workshopTerdaftar = await prisma.workshopTerdaftar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkshopTerdaftarFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkshopTerdaftarFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkshopTerdaftarClient<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkshopTerdaftars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTerdaftarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkshopTerdaftars
     * const workshopTerdaftars = await prisma.workshopTerdaftar.findMany()
     * 
     * // Get first 10 WorkshopTerdaftars
     * const workshopTerdaftars = await prisma.workshopTerdaftar.findMany({ take: 10 })
     * 
     * // Only select the `id_pendaftaran`
     * const workshopTerdaftarWithId_pendaftaranOnly = await prisma.workshopTerdaftar.findMany({ select: { id_pendaftaran: true } })
     * 
     */
    findMany<T extends WorkshopTerdaftarFindManyArgs>(args?: SelectSubset<T, WorkshopTerdaftarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkshopTerdaftar.
     * @param {WorkshopTerdaftarCreateArgs} args - Arguments to create a WorkshopTerdaftar.
     * @example
     * // Create one WorkshopTerdaftar
     * const WorkshopTerdaftar = await prisma.workshopTerdaftar.create({
     *   data: {
     *     // ... data to create a WorkshopTerdaftar
     *   }
     * })
     * 
     */
    create<T extends WorkshopTerdaftarCreateArgs>(args: SelectSubset<T, WorkshopTerdaftarCreateArgs<ExtArgs>>): Prisma__WorkshopTerdaftarClient<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkshopTerdaftars.
     * @param {WorkshopTerdaftarCreateManyArgs} args - Arguments to create many WorkshopTerdaftars.
     * @example
     * // Create many WorkshopTerdaftars
     * const workshopTerdaftar = await prisma.workshopTerdaftar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkshopTerdaftarCreateManyArgs>(args?: SelectSubset<T, WorkshopTerdaftarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkshopTerdaftars and returns the data saved in the database.
     * @param {WorkshopTerdaftarCreateManyAndReturnArgs} args - Arguments to create many WorkshopTerdaftars.
     * @example
     * // Create many WorkshopTerdaftars
     * const workshopTerdaftar = await prisma.workshopTerdaftar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkshopTerdaftars and only return the `id_pendaftaran`
     * const workshopTerdaftarWithId_pendaftaranOnly = await prisma.workshopTerdaftar.createManyAndReturn({
     *   select: { id_pendaftaran: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkshopTerdaftarCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkshopTerdaftarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkshopTerdaftar.
     * @param {WorkshopTerdaftarDeleteArgs} args - Arguments to delete one WorkshopTerdaftar.
     * @example
     * // Delete one WorkshopTerdaftar
     * const WorkshopTerdaftar = await prisma.workshopTerdaftar.delete({
     *   where: {
     *     // ... filter to delete one WorkshopTerdaftar
     *   }
     * })
     * 
     */
    delete<T extends WorkshopTerdaftarDeleteArgs>(args: SelectSubset<T, WorkshopTerdaftarDeleteArgs<ExtArgs>>): Prisma__WorkshopTerdaftarClient<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkshopTerdaftar.
     * @param {WorkshopTerdaftarUpdateArgs} args - Arguments to update one WorkshopTerdaftar.
     * @example
     * // Update one WorkshopTerdaftar
     * const workshopTerdaftar = await prisma.workshopTerdaftar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkshopTerdaftarUpdateArgs>(args: SelectSubset<T, WorkshopTerdaftarUpdateArgs<ExtArgs>>): Prisma__WorkshopTerdaftarClient<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkshopTerdaftars.
     * @param {WorkshopTerdaftarDeleteManyArgs} args - Arguments to filter WorkshopTerdaftars to delete.
     * @example
     * // Delete a few WorkshopTerdaftars
     * const { count } = await prisma.workshopTerdaftar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkshopTerdaftarDeleteManyArgs>(args?: SelectSubset<T, WorkshopTerdaftarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopTerdaftars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTerdaftarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkshopTerdaftars
     * const workshopTerdaftar = await prisma.workshopTerdaftar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkshopTerdaftarUpdateManyArgs>(args: SelectSubset<T, WorkshopTerdaftarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkshopTerdaftars and returns the data updated in the database.
     * @param {WorkshopTerdaftarUpdateManyAndReturnArgs} args - Arguments to update many WorkshopTerdaftars.
     * @example
     * // Update many WorkshopTerdaftars
     * const workshopTerdaftar = await prisma.workshopTerdaftar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkshopTerdaftars and only return the `id_pendaftaran`
     * const workshopTerdaftarWithId_pendaftaranOnly = await prisma.workshopTerdaftar.updateManyAndReturn({
     *   select: { id_pendaftaran: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkshopTerdaftarUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkshopTerdaftarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkshopTerdaftar.
     * @param {WorkshopTerdaftarUpsertArgs} args - Arguments to update or create a WorkshopTerdaftar.
     * @example
     * // Update or create a WorkshopTerdaftar
     * const workshopTerdaftar = await prisma.workshopTerdaftar.upsert({
     *   create: {
     *     // ... data to create a WorkshopTerdaftar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkshopTerdaftar we want to update
     *   }
     * })
     */
    upsert<T extends WorkshopTerdaftarUpsertArgs>(args: SelectSubset<T, WorkshopTerdaftarUpsertArgs<ExtArgs>>): Prisma__WorkshopTerdaftarClient<$Result.GetResult<Prisma.$WorkshopTerdaftarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkshopTerdaftars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTerdaftarCountArgs} args - Arguments to filter WorkshopTerdaftars to count.
     * @example
     * // Count the number of WorkshopTerdaftars
     * const count = await prisma.workshopTerdaftar.count({
     *   where: {
     *     // ... the filter for the WorkshopTerdaftars we want to count
     *   }
     * })
    **/
    count<T extends WorkshopTerdaftarCountArgs>(
      args?: Subset<T, WorkshopTerdaftarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopTerdaftarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkshopTerdaftar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTerdaftarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopTerdaftarAggregateArgs>(args: Subset<T, WorkshopTerdaftarAggregateArgs>): Prisma.PrismaPromise<GetWorkshopTerdaftarAggregateType<T>>

    /**
     * Group by WorkshopTerdaftar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopTerdaftarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkshopTerdaftarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkshopTerdaftarGroupByArgs['orderBy'] }
        : { orderBy?: WorkshopTerdaftarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkshopTerdaftarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopTerdaftarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkshopTerdaftar model
   */
  readonly fields: WorkshopTerdaftarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkshopTerdaftar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkshopTerdaftarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pengguna<T extends PenggunaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PenggunaDefaultArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workshop<T extends WorkshopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkshopDefaultArgs<ExtArgs>>): Prisma__WorkshopClient<$Result.GetResult<Prisma.$WorkshopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkshopTerdaftar model
   */
  interface WorkshopTerdaftarFieldRefs {
    readonly id_pendaftaran: FieldRef<"WorkshopTerdaftar", 'Int'>
    readonly nama_peserta: FieldRef<"WorkshopTerdaftar", 'String'>
    readonly email_peserta: FieldRef<"WorkshopTerdaftar", 'String'>
    readonly nomor_telepon_peserta: FieldRef<"WorkshopTerdaftar", 'String'>
    readonly tanggal_pendaftaran: FieldRef<"WorkshopTerdaftar", 'DateTime'>
    readonly status_pembayaran: FieldRef<"WorkshopTerdaftar", 'String'>
    readonly nomor_tiket: FieldRef<"WorkshopTerdaftar", 'String'>
    readonly id_pengguna: FieldRef<"WorkshopTerdaftar", 'String'>
    readonly id_workshop: FieldRef<"WorkshopTerdaftar", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WorkshopTerdaftar findUnique
   */
  export type WorkshopTerdaftarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTerdaftar to fetch.
     */
    where: WorkshopTerdaftarWhereUniqueInput
  }

  /**
   * WorkshopTerdaftar findUniqueOrThrow
   */
  export type WorkshopTerdaftarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTerdaftar to fetch.
     */
    where: WorkshopTerdaftarWhereUniqueInput
  }

  /**
   * WorkshopTerdaftar findFirst
   */
  export type WorkshopTerdaftarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTerdaftar to fetch.
     */
    where?: WorkshopTerdaftarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopTerdaftars to fetch.
     */
    orderBy?: WorkshopTerdaftarOrderByWithRelationInput | WorkshopTerdaftarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopTerdaftars.
     */
    cursor?: WorkshopTerdaftarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopTerdaftars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopTerdaftars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopTerdaftars.
     */
    distinct?: WorkshopTerdaftarScalarFieldEnum | WorkshopTerdaftarScalarFieldEnum[]
  }

  /**
   * WorkshopTerdaftar findFirstOrThrow
   */
  export type WorkshopTerdaftarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTerdaftar to fetch.
     */
    where?: WorkshopTerdaftarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopTerdaftars to fetch.
     */
    orderBy?: WorkshopTerdaftarOrderByWithRelationInput | WorkshopTerdaftarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkshopTerdaftars.
     */
    cursor?: WorkshopTerdaftarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopTerdaftars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopTerdaftars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkshopTerdaftars.
     */
    distinct?: WorkshopTerdaftarScalarFieldEnum | WorkshopTerdaftarScalarFieldEnum[]
  }

  /**
   * WorkshopTerdaftar findMany
   */
  export type WorkshopTerdaftarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    /**
     * Filter, which WorkshopTerdaftars to fetch.
     */
    where?: WorkshopTerdaftarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkshopTerdaftars to fetch.
     */
    orderBy?: WorkshopTerdaftarOrderByWithRelationInput | WorkshopTerdaftarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkshopTerdaftars.
     */
    cursor?: WorkshopTerdaftarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkshopTerdaftars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkshopTerdaftars.
     */
    skip?: number
    distinct?: WorkshopTerdaftarScalarFieldEnum | WorkshopTerdaftarScalarFieldEnum[]
  }

  /**
   * WorkshopTerdaftar create
   */
  export type WorkshopTerdaftarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkshopTerdaftar.
     */
    data: XOR<WorkshopTerdaftarCreateInput, WorkshopTerdaftarUncheckedCreateInput>
  }

  /**
   * WorkshopTerdaftar createMany
   */
  export type WorkshopTerdaftarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkshopTerdaftars.
     */
    data: WorkshopTerdaftarCreateManyInput | WorkshopTerdaftarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkshopTerdaftar createManyAndReturn
   */
  export type WorkshopTerdaftarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * The data used to create many WorkshopTerdaftars.
     */
    data: WorkshopTerdaftarCreateManyInput | WorkshopTerdaftarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopTerdaftar update
   */
  export type WorkshopTerdaftarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkshopTerdaftar.
     */
    data: XOR<WorkshopTerdaftarUpdateInput, WorkshopTerdaftarUncheckedUpdateInput>
    /**
     * Choose, which WorkshopTerdaftar to update.
     */
    where: WorkshopTerdaftarWhereUniqueInput
  }

  /**
   * WorkshopTerdaftar updateMany
   */
  export type WorkshopTerdaftarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkshopTerdaftars.
     */
    data: XOR<WorkshopTerdaftarUpdateManyMutationInput, WorkshopTerdaftarUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopTerdaftars to update
     */
    where?: WorkshopTerdaftarWhereInput
    /**
     * Limit how many WorkshopTerdaftars to update.
     */
    limit?: number
  }

  /**
   * WorkshopTerdaftar updateManyAndReturn
   */
  export type WorkshopTerdaftarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * The data used to update WorkshopTerdaftars.
     */
    data: XOR<WorkshopTerdaftarUpdateManyMutationInput, WorkshopTerdaftarUncheckedUpdateManyInput>
    /**
     * Filter which WorkshopTerdaftars to update
     */
    where?: WorkshopTerdaftarWhereInput
    /**
     * Limit how many WorkshopTerdaftars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkshopTerdaftar upsert
   */
  export type WorkshopTerdaftarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkshopTerdaftar to update in case it exists.
     */
    where: WorkshopTerdaftarWhereUniqueInput
    /**
     * In case the WorkshopTerdaftar found by the `where` argument doesn't exist, create a new WorkshopTerdaftar with this data.
     */
    create: XOR<WorkshopTerdaftarCreateInput, WorkshopTerdaftarUncheckedCreateInput>
    /**
     * In case the WorkshopTerdaftar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkshopTerdaftarUpdateInput, WorkshopTerdaftarUncheckedUpdateInput>
  }

  /**
   * WorkshopTerdaftar delete
   */
  export type WorkshopTerdaftarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
    /**
     * Filter which WorkshopTerdaftar to delete.
     */
    where: WorkshopTerdaftarWhereUniqueInput
  }

  /**
   * WorkshopTerdaftar deleteMany
   */
  export type WorkshopTerdaftarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkshopTerdaftars to delete
     */
    where?: WorkshopTerdaftarWhereInput
    /**
     * Limit how many WorkshopTerdaftars to delete.
     */
    limit?: number
  }

  /**
   * WorkshopTerdaftar without action
   */
  export type WorkshopTerdaftarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopTerdaftar
     */
    select?: WorkshopTerdaftarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkshopTerdaftar
     */
    omit?: WorkshopTerdaftarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkshopTerdaftarInclude<ExtArgs> | null
  }


  /**
   * Model kategoriTanaman
   */

  export type AggregateKategoriTanaman = {
    _count: KategoriTanamanCountAggregateOutputType | null
    _avg: KategoriTanamanAvgAggregateOutputType | null
    _sum: KategoriTanamanSumAggregateOutputType | null
    _min: KategoriTanamanMinAggregateOutputType | null
    _max: KategoriTanamanMaxAggregateOutputType | null
  }

  export type KategoriTanamanAvgAggregateOutputType = {
    id_kategori_tanaman: number | null
  }

  export type KategoriTanamanSumAggregateOutputType = {
    id_kategori_tanaman: number | null
  }

  export type KategoriTanamanMinAggregateOutputType = {
    id_kategori_tanaman: number | null
    nama_kategori_tanaman: string | null
  }

  export type KategoriTanamanMaxAggregateOutputType = {
    id_kategori_tanaman: number | null
    nama_kategori_tanaman: string | null
  }

  export type KategoriTanamanCountAggregateOutputType = {
    id_kategori_tanaman: number
    nama_kategori_tanaman: number
    _all: number
  }


  export type KategoriTanamanAvgAggregateInputType = {
    id_kategori_tanaman?: true
  }

  export type KategoriTanamanSumAggregateInputType = {
    id_kategori_tanaman?: true
  }

  export type KategoriTanamanMinAggregateInputType = {
    id_kategori_tanaman?: true
    nama_kategori_tanaman?: true
  }

  export type KategoriTanamanMaxAggregateInputType = {
    id_kategori_tanaman?: true
    nama_kategori_tanaman?: true
  }

  export type KategoriTanamanCountAggregateInputType = {
    id_kategori_tanaman?: true
    nama_kategori_tanaman?: true
    _all?: true
  }

  export type KategoriTanamanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategoriTanaman to aggregate.
     */
    where?: kategoriTanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategoriTanamen to fetch.
     */
    orderBy?: kategoriTanamanOrderByWithRelationInput | kategoriTanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kategoriTanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategoriTanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategoriTanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kategoriTanamen
    **/
    _count?: true | KategoriTanamanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KategoriTanamanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KategoriTanamanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KategoriTanamanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KategoriTanamanMaxAggregateInputType
  }

  export type GetKategoriTanamanAggregateType<T extends KategoriTanamanAggregateArgs> = {
        [P in keyof T & keyof AggregateKategoriTanaman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKategoriTanaman[P]>
      : GetScalarType<T[P], AggregateKategoriTanaman[P]>
  }




  export type kategoriTanamanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kategoriTanamanWhereInput
    orderBy?: kategoriTanamanOrderByWithAggregationInput | kategoriTanamanOrderByWithAggregationInput[]
    by: KategoriTanamanScalarFieldEnum[] | KategoriTanamanScalarFieldEnum
    having?: kategoriTanamanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KategoriTanamanCountAggregateInputType | true
    _avg?: KategoriTanamanAvgAggregateInputType
    _sum?: KategoriTanamanSumAggregateInputType
    _min?: KategoriTanamanMinAggregateInputType
    _max?: KategoriTanamanMaxAggregateInputType
  }

  export type KategoriTanamanGroupByOutputType = {
    id_kategori_tanaman: number
    nama_kategori_tanaman: string
    _count: KategoriTanamanCountAggregateOutputType | null
    _avg: KategoriTanamanAvgAggregateOutputType | null
    _sum: KategoriTanamanSumAggregateOutputType | null
    _min: KategoriTanamanMinAggregateOutputType | null
    _max: KategoriTanamanMaxAggregateOutputType | null
  }

  type GetKategoriTanamanGroupByPayload<T extends kategoriTanamanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KategoriTanamanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KategoriTanamanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KategoriTanamanGroupByOutputType[P]>
            : GetScalarType<T[P], KategoriTanamanGroupByOutputType[P]>
        }
      >
    >


  export type kategoriTanamanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kategori_tanaman?: boolean
    nama_kategori_tanaman?: boolean
    tanaman?: boolean | kategoriTanaman$tanamanArgs<ExtArgs>
    _count?: boolean | KategoriTanamanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kategoriTanaman"]>

  export type kategoriTanamanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kategori_tanaman?: boolean
    nama_kategori_tanaman?: boolean
  }, ExtArgs["result"]["kategoriTanaman"]>

  export type kategoriTanamanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_kategori_tanaman?: boolean
    nama_kategori_tanaman?: boolean
  }, ExtArgs["result"]["kategoriTanaman"]>

  export type kategoriTanamanSelectScalar = {
    id_kategori_tanaman?: boolean
    nama_kategori_tanaman?: boolean
  }

  export type kategoriTanamanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_kategori_tanaman" | "nama_kategori_tanaman", ExtArgs["result"]["kategoriTanaman"]>
  export type kategoriTanamanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | kategoriTanaman$tanamanArgs<ExtArgs>
    _count?: boolean | KategoriTanamanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type kategoriTanamanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type kategoriTanamanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $kategoriTanamanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kategoriTanaman"
    objects: {
      tanaman: Prisma.$TanamanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_kategori_tanaman: number
      nama_kategori_tanaman: string
    }, ExtArgs["result"]["kategoriTanaman"]>
    composites: {}
  }

  type kategoriTanamanGetPayload<S extends boolean | null | undefined | kategoriTanamanDefaultArgs> = $Result.GetResult<Prisma.$kategoriTanamanPayload, S>

  type kategoriTanamanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<kategoriTanamanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KategoriTanamanCountAggregateInputType | true
    }

  export interface kategoriTanamanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kategoriTanaman'], meta: { name: 'kategoriTanaman' } }
    /**
     * Find zero or one KategoriTanaman that matches the filter.
     * @param {kategoriTanamanFindUniqueArgs} args - Arguments to find a KategoriTanaman
     * @example
     * // Get one KategoriTanaman
     * const kategoriTanaman = await prisma.kategoriTanaman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kategoriTanamanFindUniqueArgs>(args: SelectSubset<T, kategoriTanamanFindUniqueArgs<ExtArgs>>): Prisma__kategoriTanamanClient<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KategoriTanaman that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {kategoriTanamanFindUniqueOrThrowArgs} args - Arguments to find a KategoriTanaman
     * @example
     * // Get one KategoriTanaman
     * const kategoriTanaman = await prisma.kategoriTanaman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kategoriTanamanFindUniqueOrThrowArgs>(args: SelectSubset<T, kategoriTanamanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kategoriTanamanClient<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KategoriTanaman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategoriTanamanFindFirstArgs} args - Arguments to find a KategoriTanaman
     * @example
     * // Get one KategoriTanaman
     * const kategoriTanaman = await prisma.kategoriTanaman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kategoriTanamanFindFirstArgs>(args?: SelectSubset<T, kategoriTanamanFindFirstArgs<ExtArgs>>): Prisma__kategoriTanamanClient<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KategoriTanaman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategoriTanamanFindFirstOrThrowArgs} args - Arguments to find a KategoriTanaman
     * @example
     * // Get one KategoriTanaman
     * const kategoriTanaman = await prisma.kategoriTanaman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kategoriTanamanFindFirstOrThrowArgs>(args?: SelectSubset<T, kategoriTanamanFindFirstOrThrowArgs<ExtArgs>>): Prisma__kategoriTanamanClient<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KategoriTanamen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategoriTanamanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KategoriTanamen
     * const kategoriTanamen = await prisma.kategoriTanaman.findMany()
     * 
     * // Get first 10 KategoriTanamen
     * const kategoriTanamen = await prisma.kategoriTanaman.findMany({ take: 10 })
     * 
     * // Only select the `id_kategori_tanaman`
     * const kategoriTanamanWithId_kategori_tanamanOnly = await prisma.kategoriTanaman.findMany({ select: { id_kategori_tanaman: true } })
     * 
     */
    findMany<T extends kategoriTanamanFindManyArgs>(args?: SelectSubset<T, kategoriTanamanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KategoriTanaman.
     * @param {kategoriTanamanCreateArgs} args - Arguments to create a KategoriTanaman.
     * @example
     * // Create one KategoriTanaman
     * const KategoriTanaman = await prisma.kategoriTanaman.create({
     *   data: {
     *     // ... data to create a KategoriTanaman
     *   }
     * })
     * 
     */
    create<T extends kategoriTanamanCreateArgs>(args: SelectSubset<T, kategoriTanamanCreateArgs<ExtArgs>>): Prisma__kategoriTanamanClient<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KategoriTanamen.
     * @param {kategoriTanamanCreateManyArgs} args - Arguments to create many KategoriTanamen.
     * @example
     * // Create many KategoriTanamen
     * const kategoriTanaman = await prisma.kategoriTanaman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kategoriTanamanCreateManyArgs>(args?: SelectSubset<T, kategoriTanamanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KategoriTanamen and returns the data saved in the database.
     * @param {kategoriTanamanCreateManyAndReturnArgs} args - Arguments to create many KategoriTanamen.
     * @example
     * // Create many KategoriTanamen
     * const kategoriTanaman = await prisma.kategoriTanaman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KategoriTanamen and only return the `id_kategori_tanaman`
     * const kategoriTanamanWithId_kategori_tanamanOnly = await prisma.kategoriTanaman.createManyAndReturn({
     *   select: { id_kategori_tanaman: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends kategoriTanamanCreateManyAndReturnArgs>(args?: SelectSubset<T, kategoriTanamanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KategoriTanaman.
     * @param {kategoriTanamanDeleteArgs} args - Arguments to delete one KategoriTanaman.
     * @example
     * // Delete one KategoriTanaman
     * const KategoriTanaman = await prisma.kategoriTanaman.delete({
     *   where: {
     *     // ... filter to delete one KategoriTanaman
     *   }
     * })
     * 
     */
    delete<T extends kategoriTanamanDeleteArgs>(args: SelectSubset<T, kategoriTanamanDeleteArgs<ExtArgs>>): Prisma__kategoriTanamanClient<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KategoriTanaman.
     * @param {kategoriTanamanUpdateArgs} args - Arguments to update one KategoriTanaman.
     * @example
     * // Update one KategoriTanaman
     * const kategoriTanaman = await prisma.kategoriTanaman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kategoriTanamanUpdateArgs>(args: SelectSubset<T, kategoriTanamanUpdateArgs<ExtArgs>>): Prisma__kategoriTanamanClient<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KategoriTanamen.
     * @param {kategoriTanamanDeleteManyArgs} args - Arguments to filter KategoriTanamen to delete.
     * @example
     * // Delete a few KategoriTanamen
     * const { count } = await prisma.kategoriTanaman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kategoriTanamanDeleteManyArgs>(args?: SelectSubset<T, kategoriTanamanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KategoriTanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategoriTanamanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KategoriTanamen
     * const kategoriTanaman = await prisma.kategoriTanaman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kategoriTanamanUpdateManyArgs>(args: SelectSubset<T, kategoriTanamanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KategoriTanamen and returns the data updated in the database.
     * @param {kategoriTanamanUpdateManyAndReturnArgs} args - Arguments to update many KategoriTanamen.
     * @example
     * // Update many KategoriTanamen
     * const kategoriTanaman = await prisma.kategoriTanaman.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KategoriTanamen and only return the `id_kategori_tanaman`
     * const kategoriTanamanWithId_kategori_tanamanOnly = await prisma.kategoriTanaman.updateManyAndReturn({
     *   select: { id_kategori_tanaman: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends kategoriTanamanUpdateManyAndReturnArgs>(args: SelectSubset<T, kategoriTanamanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KategoriTanaman.
     * @param {kategoriTanamanUpsertArgs} args - Arguments to update or create a KategoriTanaman.
     * @example
     * // Update or create a KategoriTanaman
     * const kategoriTanaman = await prisma.kategoriTanaman.upsert({
     *   create: {
     *     // ... data to create a KategoriTanaman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KategoriTanaman we want to update
     *   }
     * })
     */
    upsert<T extends kategoriTanamanUpsertArgs>(args: SelectSubset<T, kategoriTanamanUpsertArgs<ExtArgs>>): Prisma__kategoriTanamanClient<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KategoriTanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategoriTanamanCountArgs} args - Arguments to filter KategoriTanamen to count.
     * @example
     * // Count the number of KategoriTanamen
     * const count = await prisma.kategoriTanaman.count({
     *   where: {
     *     // ... the filter for the KategoriTanamen we want to count
     *   }
     * })
    **/
    count<T extends kategoriTanamanCountArgs>(
      args?: Subset<T, kategoriTanamanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KategoriTanamanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KategoriTanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KategoriTanamanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KategoriTanamanAggregateArgs>(args: Subset<T, KategoriTanamanAggregateArgs>): Prisma.PrismaPromise<GetKategoriTanamanAggregateType<T>>

    /**
     * Group by KategoriTanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kategoriTanamanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kategoriTanamanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kategoriTanamanGroupByArgs['orderBy'] }
        : { orderBy?: kategoriTanamanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kategoriTanamanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKategoriTanamanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kategoriTanaman model
   */
  readonly fields: kategoriTanamanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kategoriTanaman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kategoriTanamanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tanaman<T extends kategoriTanaman$tanamanArgs<ExtArgs> = {}>(args?: Subset<T, kategoriTanaman$tanamanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kategoriTanaman model
   */
  interface kategoriTanamanFieldRefs {
    readonly id_kategori_tanaman: FieldRef<"kategoriTanaman", 'Int'>
    readonly nama_kategori_tanaman: FieldRef<"kategoriTanaman", 'String'>
  }
    

  // Custom InputTypes
  /**
   * kategoriTanaman findUnique
   */
  export type kategoriTanamanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
    /**
     * Filter, which kategoriTanaman to fetch.
     */
    where: kategoriTanamanWhereUniqueInput
  }

  /**
   * kategoriTanaman findUniqueOrThrow
   */
  export type kategoriTanamanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
    /**
     * Filter, which kategoriTanaman to fetch.
     */
    where: kategoriTanamanWhereUniqueInput
  }

  /**
   * kategoriTanaman findFirst
   */
  export type kategoriTanamanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
    /**
     * Filter, which kategoriTanaman to fetch.
     */
    where?: kategoriTanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategoriTanamen to fetch.
     */
    orderBy?: kategoriTanamanOrderByWithRelationInput | kategoriTanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategoriTanamen.
     */
    cursor?: kategoriTanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategoriTanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategoriTanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategoriTanamen.
     */
    distinct?: KategoriTanamanScalarFieldEnum | KategoriTanamanScalarFieldEnum[]
  }

  /**
   * kategoriTanaman findFirstOrThrow
   */
  export type kategoriTanamanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
    /**
     * Filter, which kategoriTanaman to fetch.
     */
    where?: kategoriTanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategoriTanamen to fetch.
     */
    orderBy?: kategoriTanamanOrderByWithRelationInput | kategoriTanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kategoriTanamen.
     */
    cursor?: kategoriTanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategoriTanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategoriTanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kategoriTanamen.
     */
    distinct?: KategoriTanamanScalarFieldEnum | KategoriTanamanScalarFieldEnum[]
  }

  /**
   * kategoriTanaman findMany
   */
  export type kategoriTanamanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
    /**
     * Filter, which kategoriTanamen to fetch.
     */
    where?: kategoriTanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kategoriTanamen to fetch.
     */
    orderBy?: kategoriTanamanOrderByWithRelationInput | kategoriTanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kategoriTanamen.
     */
    cursor?: kategoriTanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kategoriTanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kategoriTanamen.
     */
    skip?: number
    distinct?: KategoriTanamanScalarFieldEnum | KategoriTanamanScalarFieldEnum[]
  }

  /**
   * kategoriTanaman create
   */
  export type kategoriTanamanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
    /**
     * The data needed to create a kategoriTanaman.
     */
    data: XOR<kategoriTanamanCreateInput, kategoriTanamanUncheckedCreateInput>
  }

  /**
   * kategoriTanaman createMany
   */
  export type kategoriTanamanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kategoriTanamen.
     */
    data: kategoriTanamanCreateManyInput | kategoriTanamanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kategoriTanaman createManyAndReturn
   */
  export type kategoriTanamanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * The data used to create many kategoriTanamen.
     */
    data: kategoriTanamanCreateManyInput | kategoriTanamanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kategoriTanaman update
   */
  export type kategoriTanamanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
    /**
     * The data needed to update a kategoriTanaman.
     */
    data: XOR<kategoriTanamanUpdateInput, kategoriTanamanUncheckedUpdateInput>
    /**
     * Choose, which kategoriTanaman to update.
     */
    where: kategoriTanamanWhereUniqueInput
  }

  /**
   * kategoriTanaman updateMany
   */
  export type kategoriTanamanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kategoriTanamen.
     */
    data: XOR<kategoriTanamanUpdateManyMutationInput, kategoriTanamanUncheckedUpdateManyInput>
    /**
     * Filter which kategoriTanamen to update
     */
    where?: kategoriTanamanWhereInput
    /**
     * Limit how many kategoriTanamen to update.
     */
    limit?: number
  }

  /**
   * kategoriTanaman updateManyAndReturn
   */
  export type kategoriTanamanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * The data used to update kategoriTanamen.
     */
    data: XOR<kategoriTanamanUpdateManyMutationInput, kategoriTanamanUncheckedUpdateManyInput>
    /**
     * Filter which kategoriTanamen to update
     */
    where?: kategoriTanamanWhereInput
    /**
     * Limit how many kategoriTanamen to update.
     */
    limit?: number
  }

  /**
   * kategoriTanaman upsert
   */
  export type kategoriTanamanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
    /**
     * The filter to search for the kategoriTanaman to update in case it exists.
     */
    where: kategoriTanamanWhereUniqueInput
    /**
     * In case the kategoriTanaman found by the `where` argument doesn't exist, create a new kategoriTanaman with this data.
     */
    create: XOR<kategoriTanamanCreateInput, kategoriTanamanUncheckedCreateInput>
    /**
     * In case the kategoriTanaman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kategoriTanamanUpdateInput, kategoriTanamanUncheckedUpdateInput>
  }

  /**
   * kategoriTanaman delete
   */
  export type kategoriTanamanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
    /**
     * Filter which kategoriTanaman to delete.
     */
    where: kategoriTanamanWhereUniqueInput
  }

  /**
   * kategoriTanaman deleteMany
   */
  export type kategoriTanamanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kategoriTanamen to delete
     */
    where?: kategoriTanamanWhereInput
    /**
     * Limit how many kategoriTanamen to delete.
     */
    limit?: number
  }

  /**
   * kategoriTanaman.tanaman
   */
  export type kategoriTanaman$tanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    where?: TanamanWhereInput
    orderBy?: TanamanOrderByWithRelationInput | TanamanOrderByWithRelationInput[]
    cursor?: TanamanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TanamanScalarFieldEnum | TanamanScalarFieldEnum[]
  }

  /**
   * kategoriTanaman without action
   */
  export type kategoriTanamanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kategoriTanaman
     */
    select?: kategoriTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the kategoriTanaman
     */
    omit?: kategoriTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kategoriTanamanInclude<ExtArgs> | null
  }


  /**
   * Model Tanaman
   */

  export type AggregateTanaman = {
    _count: TanamanCountAggregateOutputType | null
    _avg: TanamanAvgAggregateOutputType | null
    _sum: TanamanSumAggregateOutputType | null
    _min: TanamanMinAggregateOutputType | null
    _max: TanamanMaxAggregateOutputType | null
  }

  export type TanamanAvgAggregateOutputType = {
    durasi_penanaman: number | null
    id_kategori_tanaman: number | null
  }

  export type TanamanSumAggregateOutputType = {
    durasi_penanaman: number | null
    id_kategori_tanaman: number | null
  }

  export type TanamanMinAggregateOutputType = {
    id_tanaman: string | null
    nama_tanaman: string | null
    nama_latin: string | null
    durasi_penanaman: number | null
    deskripsi_tanaman: string | null
    id_kategori_tanaman: number | null
  }

  export type TanamanMaxAggregateOutputType = {
    id_tanaman: string | null
    nama_tanaman: string | null
    nama_latin: string | null
    durasi_penanaman: number | null
    deskripsi_tanaman: string | null
    id_kategori_tanaman: number | null
  }

  export type TanamanCountAggregateOutputType = {
    id_tanaman: number
    nama_tanaman: number
    nama_latin: number
    durasi_penanaman: number
    deskripsi_tanaman: number
    id_kategori_tanaman: number
    _all: number
  }


  export type TanamanAvgAggregateInputType = {
    durasi_penanaman?: true
    id_kategori_tanaman?: true
  }

  export type TanamanSumAggregateInputType = {
    durasi_penanaman?: true
    id_kategori_tanaman?: true
  }

  export type TanamanMinAggregateInputType = {
    id_tanaman?: true
    nama_tanaman?: true
    nama_latin?: true
    durasi_penanaman?: true
    deskripsi_tanaman?: true
    id_kategori_tanaman?: true
  }

  export type TanamanMaxAggregateInputType = {
    id_tanaman?: true
    nama_tanaman?: true
    nama_latin?: true
    durasi_penanaman?: true
    deskripsi_tanaman?: true
    id_kategori_tanaman?: true
  }

  export type TanamanCountAggregateInputType = {
    id_tanaman?: true
    nama_tanaman?: true
    nama_latin?: true
    durasi_penanaman?: true
    deskripsi_tanaman?: true
    id_kategori_tanaman?: true
    _all?: true
  }

  export type TanamanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tanaman to aggregate.
     */
    where?: TanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tanamen to fetch.
     */
    orderBy?: TanamanOrderByWithRelationInput | TanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tanamen
    **/
    _count?: true | TanamanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TanamanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TanamanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TanamanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TanamanMaxAggregateInputType
  }

  export type GetTanamanAggregateType<T extends TanamanAggregateArgs> = {
        [P in keyof T & keyof AggregateTanaman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTanaman[P]>
      : GetScalarType<T[P], AggregateTanaman[P]>
  }




  export type TanamanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TanamanWhereInput
    orderBy?: TanamanOrderByWithAggregationInput | TanamanOrderByWithAggregationInput[]
    by: TanamanScalarFieldEnum[] | TanamanScalarFieldEnum
    having?: TanamanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TanamanCountAggregateInputType | true
    _avg?: TanamanAvgAggregateInputType
    _sum?: TanamanSumAggregateInputType
    _min?: TanamanMinAggregateInputType
    _max?: TanamanMaxAggregateInputType
  }

  export type TanamanGroupByOutputType = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    id_kategori_tanaman: number
    _count: TanamanCountAggregateOutputType | null
    _avg: TanamanAvgAggregateOutputType | null
    _sum: TanamanSumAggregateOutputType | null
    _min: TanamanMinAggregateOutputType | null
    _max: TanamanMaxAggregateOutputType | null
  }

  type GetTanamanGroupByPayload<T extends TanamanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TanamanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TanamanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TanamanGroupByOutputType[P]>
            : GetScalarType<T[P], TanamanGroupByOutputType[P]>
        }
      >
    >


  export type TanamanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tanaman?: boolean
    nama_tanaman?: boolean
    nama_latin?: boolean
    durasi_penanaman?: boolean
    deskripsi_tanaman?: boolean
    id_kategori_tanaman?: boolean
    kategori?: boolean | kategoriTanamanDefaultArgs<ExtArgs>
    instruksi_tanaman?: boolean | Tanaman$instruksi_tanamanArgs<ExtArgs>
    hari_penanaman?: boolean | Tanaman$hari_penanamanArgs<ExtArgs>
    tanaman_pengguna?: boolean | Tanaman$tanaman_penggunaArgs<ExtArgs>
    _count?: boolean | TanamanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tanaman"]>

  export type TanamanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tanaman?: boolean
    nama_tanaman?: boolean
    nama_latin?: boolean
    durasi_penanaman?: boolean
    deskripsi_tanaman?: boolean
    id_kategori_tanaman?: boolean
    kategori?: boolean | kategoriTanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tanaman"]>

  export type TanamanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tanaman?: boolean
    nama_tanaman?: boolean
    nama_latin?: boolean
    durasi_penanaman?: boolean
    deskripsi_tanaman?: boolean
    id_kategori_tanaman?: boolean
    kategori?: boolean | kategoriTanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tanaman"]>

  export type TanamanSelectScalar = {
    id_tanaman?: boolean
    nama_tanaman?: boolean
    nama_latin?: boolean
    durasi_penanaman?: boolean
    deskripsi_tanaman?: boolean
    id_kategori_tanaman?: boolean
  }

  export type TanamanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tanaman" | "nama_tanaman" | "nama_latin" | "durasi_penanaman" | "deskripsi_tanaman" | "id_kategori_tanaman", ExtArgs["result"]["tanaman"]>
  export type TanamanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kategori?: boolean | kategoriTanamanDefaultArgs<ExtArgs>
    instruksi_tanaman?: boolean | Tanaman$instruksi_tanamanArgs<ExtArgs>
    hari_penanaman?: boolean | Tanaman$hari_penanamanArgs<ExtArgs>
    tanaman_pengguna?: boolean | Tanaman$tanaman_penggunaArgs<ExtArgs>
    _count?: boolean | TanamanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TanamanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kategori?: boolean | kategoriTanamanDefaultArgs<ExtArgs>
  }
  export type TanamanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kategori?: boolean | kategoriTanamanDefaultArgs<ExtArgs>
  }

  export type $TanamanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tanaman"
    objects: {
      kategori: Prisma.$kategoriTanamanPayload<ExtArgs>
      instruksi_tanaman: Prisma.$InstruksiTanamanPayload<ExtArgs>[]
      hari_penanaman: Prisma.$HariPenanamanPayload<ExtArgs>[]
      tanaman_pengguna: Prisma.$TanamanPenggunaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tanaman: string
      nama_tanaman: string
      nama_latin: string
      durasi_penanaman: number
      deskripsi_tanaman: string
      id_kategori_tanaman: number
    }, ExtArgs["result"]["tanaman"]>
    composites: {}
  }

  type TanamanGetPayload<S extends boolean | null | undefined | TanamanDefaultArgs> = $Result.GetResult<Prisma.$TanamanPayload, S>

  type TanamanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TanamanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TanamanCountAggregateInputType | true
    }

  export interface TanamanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tanaman'], meta: { name: 'Tanaman' } }
    /**
     * Find zero or one Tanaman that matches the filter.
     * @param {TanamanFindUniqueArgs} args - Arguments to find a Tanaman
     * @example
     * // Get one Tanaman
     * const tanaman = await prisma.tanaman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TanamanFindUniqueArgs>(args: SelectSubset<T, TanamanFindUniqueArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tanaman that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TanamanFindUniqueOrThrowArgs} args - Arguments to find a Tanaman
     * @example
     * // Get one Tanaman
     * const tanaman = await prisma.tanaman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TanamanFindUniqueOrThrowArgs>(args: SelectSubset<T, TanamanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tanaman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanFindFirstArgs} args - Arguments to find a Tanaman
     * @example
     * // Get one Tanaman
     * const tanaman = await prisma.tanaman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TanamanFindFirstArgs>(args?: SelectSubset<T, TanamanFindFirstArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tanaman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanFindFirstOrThrowArgs} args - Arguments to find a Tanaman
     * @example
     * // Get one Tanaman
     * const tanaman = await prisma.tanaman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TanamanFindFirstOrThrowArgs>(args?: SelectSubset<T, TanamanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tanamen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tanamen
     * const tanamen = await prisma.tanaman.findMany()
     * 
     * // Get first 10 Tanamen
     * const tanamen = await prisma.tanaman.findMany({ take: 10 })
     * 
     * // Only select the `id_tanaman`
     * const tanamanWithId_tanamanOnly = await prisma.tanaman.findMany({ select: { id_tanaman: true } })
     * 
     */
    findMany<T extends TanamanFindManyArgs>(args?: SelectSubset<T, TanamanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tanaman.
     * @param {TanamanCreateArgs} args - Arguments to create a Tanaman.
     * @example
     * // Create one Tanaman
     * const Tanaman = await prisma.tanaman.create({
     *   data: {
     *     // ... data to create a Tanaman
     *   }
     * })
     * 
     */
    create<T extends TanamanCreateArgs>(args: SelectSubset<T, TanamanCreateArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tanamen.
     * @param {TanamanCreateManyArgs} args - Arguments to create many Tanamen.
     * @example
     * // Create many Tanamen
     * const tanaman = await prisma.tanaman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TanamanCreateManyArgs>(args?: SelectSubset<T, TanamanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tanamen and returns the data saved in the database.
     * @param {TanamanCreateManyAndReturnArgs} args - Arguments to create many Tanamen.
     * @example
     * // Create many Tanamen
     * const tanaman = await prisma.tanaman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tanamen and only return the `id_tanaman`
     * const tanamanWithId_tanamanOnly = await prisma.tanaman.createManyAndReturn({
     *   select: { id_tanaman: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TanamanCreateManyAndReturnArgs>(args?: SelectSubset<T, TanamanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tanaman.
     * @param {TanamanDeleteArgs} args - Arguments to delete one Tanaman.
     * @example
     * // Delete one Tanaman
     * const Tanaman = await prisma.tanaman.delete({
     *   where: {
     *     // ... filter to delete one Tanaman
     *   }
     * })
     * 
     */
    delete<T extends TanamanDeleteArgs>(args: SelectSubset<T, TanamanDeleteArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tanaman.
     * @param {TanamanUpdateArgs} args - Arguments to update one Tanaman.
     * @example
     * // Update one Tanaman
     * const tanaman = await prisma.tanaman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TanamanUpdateArgs>(args: SelectSubset<T, TanamanUpdateArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tanamen.
     * @param {TanamanDeleteManyArgs} args - Arguments to filter Tanamen to delete.
     * @example
     * // Delete a few Tanamen
     * const { count } = await prisma.tanaman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TanamanDeleteManyArgs>(args?: SelectSubset<T, TanamanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tanamen
     * const tanaman = await prisma.tanaman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TanamanUpdateManyArgs>(args: SelectSubset<T, TanamanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tanamen and returns the data updated in the database.
     * @param {TanamanUpdateManyAndReturnArgs} args - Arguments to update many Tanamen.
     * @example
     * // Update many Tanamen
     * const tanaman = await prisma.tanaman.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tanamen and only return the `id_tanaman`
     * const tanamanWithId_tanamanOnly = await prisma.tanaman.updateManyAndReturn({
     *   select: { id_tanaman: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TanamanUpdateManyAndReturnArgs>(args: SelectSubset<T, TanamanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tanaman.
     * @param {TanamanUpsertArgs} args - Arguments to update or create a Tanaman.
     * @example
     * // Update or create a Tanaman
     * const tanaman = await prisma.tanaman.upsert({
     *   create: {
     *     // ... data to create a Tanaman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tanaman we want to update
     *   }
     * })
     */
    upsert<T extends TanamanUpsertArgs>(args: SelectSubset<T, TanamanUpsertArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanCountArgs} args - Arguments to filter Tanamen to count.
     * @example
     * // Count the number of Tanamen
     * const count = await prisma.tanaman.count({
     *   where: {
     *     // ... the filter for the Tanamen we want to count
     *   }
     * })
    **/
    count<T extends TanamanCountArgs>(
      args?: Subset<T, TanamanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TanamanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TanamanAggregateArgs>(args: Subset<T, TanamanAggregateArgs>): Prisma.PrismaPromise<GetTanamanAggregateType<T>>

    /**
     * Group by Tanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TanamanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TanamanGroupByArgs['orderBy'] }
        : { orderBy?: TanamanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TanamanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTanamanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tanaman model
   */
  readonly fields: TanamanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tanaman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TanamanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kategori<T extends kategoriTanamanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kategoriTanamanDefaultArgs<ExtArgs>>): Prisma__kategoriTanamanClient<$Result.GetResult<Prisma.$kategoriTanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instruksi_tanaman<T extends Tanaman$instruksi_tanamanArgs<ExtArgs> = {}>(args?: Subset<T, Tanaman$instruksi_tanamanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hari_penanaman<T extends Tanaman$hari_penanamanArgs<ExtArgs> = {}>(args?: Subset<T, Tanaman$hari_penanamanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tanaman_pengguna<T extends Tanaman$tanaman_penggunaArgs<ExtArgs> = {}>(args?: Subset<T, Tanaman$tanaman_penggunaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tanaman model
   */
  interface TanamanFieldRefs {
    readonly id_tanaman: FieldRef<"Tanaman", 'String'>
    readonly nama_tanaman: FieldRef<"Tanaman", 'String'>
    readonly nama_latin: FieldRef<"Tanaman", 'String'>
    readonly durasi_penanaman: FieldRef<"Tanaman", 'Int'>
    readonly deskripsi_tanaman: FieldRef<"Tanaman", 'String'>
    readonly id_kategori_tanaman: FieldRef<"Tanaman", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tanaman findUnique
   */
  export type TanamanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    /**
     * Filter, which Tanaman to fetch.
     */
    where: TanamanWhereUniqueInput
  }

  /**
   * Tanaman findUniqueOrThrow
   */
  export type TanamanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    /**
     * Filter, which Tanaman to fetch.
     */
    where: TanamanWhereUniqueInput
  }

  /**
   * Tanaman findFirst
   */
  export type TanamanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    /**
     * Filter, which Tanaman to fetch.
     */
    where?: TanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tanamen to fetch.
     */
    orderBy?: TanamanOrderByWithRelationInput | TanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tanamen.
     */
    cursor?: TanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tanamen.
     */
    distinct?: TanamanScalarFieldEnum | TanamanScalarFieldEnum[]
  }

  /**
   * Tanaman findFirstOrThrow
   */
  export type TanamanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    /**
     * Filter, which Tanaman to fetch.
     */
    where?: TanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tanamen to fetch.
     */
    orderBy?: TanamanOrderByWithRelationInput | TanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tanamen.
     */
    cursor?: TanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tanamen.
     */
    distinct?: TanamanScalarFieldEnum | TanamanScalarFieldEnum[]
  }

  /**
   * Tanaman findMany
   */
  export type TanamanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    /**
     * Filter, which Tanamen to fetch.
     */
    where?: TanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tanamen to fetch.
     */
    orderBy?: TanamanOrderByWithRelationInput | TanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tanamen.
     */
    cursor?: TanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tanamen.
     */
    skip?: number
    distinct?: TanamanScalarFieldEnum | TanamanScalarFieldEnum[]
  }

  /**
   * Tanaman create
   */
  export type TanamanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    /**
     * The data needed to create a Tanaman.
     */
    data: XOR<TanamanCreateInput, TanamanUncheckedCreateInput>
  }

  /**
   * Tanaman createMany
   */
  export type TanamanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tanamen.
     */
    data: TanamanCreateManyInput | TanamanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tanaman createManyAndReturn
   */
  export type TanamanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * The data used to create many Tanamen.
     */
    data: TanamanCreateManyInput | TanamanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tanaman update
   */
  export type TanamanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    /**
     * The data needed to update a Tanaman.
     */
    data: XOR<TanamanUpdateInput, TanamanUncheckedUpdateInput>
    /**
     * Choose, which Tanaman to update.
     */
    where: TanamanWhereUniqueInput
  }

  /**
   * Tanaman updateMany
   */
  export type TanamanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tanamen.
     */
    data: XOR<TanamanUpdateManyMutationInput, TanamanUncheckedUpdateManyInput>
    /**
     * Filter which Tanamen to update
     */
    where?: TanamanWhereInput
    /**
     * Limit how many Tanamen to update.
     */
    limit?: number
  }

  /**
   * Tanaman updateManyAndReturn
   */
  export type TanamanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * The data used to update Tanamen.
     */
    data: XOR<TanamanUpdateManyMutationInput, TanamanUncheckedUpdateManyInput>
    /**
     * Filter which Tanamen to update
     */
    where?: TanamanWhereInput
    /**
     * Limit how many Tanamen to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tanaman upsert
   */
  export type TanamanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    /**
     * The filter to search for the Tanaman to update in case it exists.
     */
    where: TanamanWhereUniqueInput
    /**
     * In case the Tanaman found by the `where` argument doesn't exist, create a new Tanaman with this data.
     */
    create: XOR<TanamanCreateInput, TanamanUncheckedCreateInput>
    /**
     * In case the Tanaman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TanamanUpdateInput, TanamanUncheckedUpdateInput>
  }

  /**
   * Tanaman delete
   */
  export type TanamanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
    /**
     * Filter which Tanaman to delete.
     */
    where: TanamanWhereUniqueInput
  }

  /**
   * Tanaman deleteMany
   */
  export type TanamanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tanamen to delete
     */
    where?: TanamanWhereInput
    /**
     * Limit how many Tanamen to delete.
     */
    limit?: number
  }

  /**
   * Tanaman.instruksi_tanaman
   */
  export type Tanaman$instruksi_tanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    where?: InstruksiTanamanWhereInput
    orderBy?: InstruksiTanamanOrderByWithRelationInput | InstruksiTanamanOrderByWithRelationInput[]
    cursor?: InstruksiTanamanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstruksiTanamanScalarFieldEnum | InstruksiTanamanScalarFieldEnum[]
  }

  /**
   * Tanaman.hari_penanaman
   */
  export type Tanaman$hari_penanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    where?: HariPenanamanWhereInput
    orderBy?: HariPenanamanOrderByWithRelationInput | HariPenanamanOrderByWithRelationInput[]
    cursor?: HariPenanamanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HariPenanamanScalarFieldEnum | HariPenanamanScalarFieldEnum[]
  }

  /**
   * Tanaman.tanaman_pengguna
   */
  export type Tanaman$tanaman_penggunaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    where?: TanamanPenggunaWhereInput
    orderBy?: TanamanPenggunaOrderByWithRelationInput | TanamanPenggunaOrderByWithRelationInput[]
    cursor?: TanamanPenggunaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TanamanPenggunaScalarFieldEnum | TanamanPenggunaScalarFieldEnum[]
  }

  /**
   * Tanaman without action
   */
  export type TanamanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tanaman
     */
    select?: TanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tanaman
     */
    omit?: TanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanInclude<ExtArgs> | null
  }


  /**
   * Model InstruksiTanaman
   */

  export type AggregateInstruksiTanaman = {
    _count: InstruksiTanamanCountAggregateOutputType | null
    _avg: InstruksiTanamanAvgAggregateOutputType | null
    _sum: InstruksiTanamanSumAggregateOutputType | null
    _min: InstruksiTanamanMinAggregateOutputType | null
    _max: InstruksiTanamanMaxAggregateOutputType | null
  }

  export type InstruksiTanamanAvgAggregateOutputType = {
    id_instruksi: number | null
  }

  export type InstruksiTanamanSumAggregateOutputType = {
    id_instruksi: number | null
  }

  export type InstruksiTanamanMinAggregateOutputType = {
    id_instruksi: number | null
    instruksi: string | null
    id_tanaman: string | null
  }

  export type InstruksiTanamanMaxAggregateOutputType = {
    id_instruksi: number | null
    instruksi: string | null
    id_tanaman: string | null
  }

  export type InstruksiTanamanCountAggregateOutputType = {
    id_instruksi: number
    instruksi: number
    id_tanaman: number
    _all: number
  }


  export type InstruksiTanamanAvgAggregateInputType = {
    id_instruksi?: true
  }

  export type InstruksiTanamanSumAggregateInputType = {
    id_instruksi?: true
  }

  export type InstruksiTanamanMinAggregateInputType = {
    id_instruksi?: true
    instruksi?: true
    id_tanaman?: true
  }

  export type InstruksiTanamanMaxAggregateInputType = {
    id_instruksi?: true
    instruksi?: true
    id_tanaman?: true
  }

  export type InstruksiTanamanCountAggregateInputType = {
    id_instruksi?: true
    instruksi?: true
    id_tanaman?: true
    _all?: true
  }

  export type InstruksiTanamanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstruksiTanaman to aggregate.
     */
    where?: InstruksiTanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstruksiTanamen to fetch.
     */
    orderBy?: InstruksiTanamanOrderByWithRelationInput | InstruksiTanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstruksiTanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstruksiTanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstruksiTanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstruksiTanamen
    **/
    _count?: true | InstruksiTanamanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstruksiTanamanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstruksiTanamanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstruksiTanamanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstruksiTanamanMaxAggregateInputType
  }

  export type GetInstruksiTanamanAggregateType<T extends InstruksiTanamanAggregateArgs> = {
        [P in keyof T & keyof AggregateInstruksiTanaman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstruksiTanaman[P]>
      : GetScalarType<T[P], AggregateInstruksiTanaman[P]>
  }




  export type InstruksiTanamanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstruksiTanamanWhereInput
    orderBy?: InstruksiTanamanOrderByWithAggregationInput | InstruksiTanamanOrderByWithAggregationInput[]
    by: InstruksiTanamanScalarFieldEnum[] | InstruksiTanamanScalarFieldEnum
    having?: InstruksiTanamanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstruksiTanamanCountAggregateInputType | true
    _avg?: InstruksiTanamanAvgAggregateInputType
    _sum?: InstruksiTanamanSumAggregateInputType
    _min?: InstruksiTanamanMinAggregateInputType
    _max?: InstruksiTanamanMaxAggregateInputType
  }

  export type InstruksiTanamanGroupByOutputType = {
    id_instruksi: number
    instruksi: string
    id_tanaman: string
    _count: InstruksiTanamanCountAggregateOutputType | null
    _avg: InstruksiTanamanAvgAggregateOutputType | null
    _sum: InstruksiTanamanSumAggregateOutputType | null
    _min: InstruksiTanamanMinAggregateOutputType | null
    _max: InstruksiTanamanMaxAggregateOutputType | null
  }

  type GetInstruksiTanamanGroupByPayload<T extends InstruksiTanamanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstruksiTanamanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstruksiTanamanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstruksiTanamanGroupByOutputType[P]>
            : GetScalarType<T[P], InstruksiTanamanGroupByOutputType[P]>
        }
      >
    >


  export type InstruksiTanamanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_instruksi?: boolean
    instruksi?: boolean
    id_tanaman?: boolean
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instruksiTanaman"]>

  export type InstruksiTanamanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_instruksi?: boolean
    instruksi?: boolean
    id_tanaman?: boolean
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instruksiTanaman"]>

  export type InstruksiTanamanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_instruksi?: boolean
    instruksi?: boolean
    id_tanaman?: boolean
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instruksiTanaman"]>

  export type InstruksiTanamanSelectScalar = {
    id_instruksi?: boolean
    instruksi?: boolean
    id_tanaman?: boolean
  }

  export type InstruksiTanamanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_instruksi" | "instruksi" | "id_tanaman", ExtArgs["result"]["instruksiTanaman"]>
  export type InstruksiTanamanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }
  export type InstruksiTanamanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }
  export type InstruksiTanamanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }

  export type $InstruksiTanamanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstruksiTanaman"
    objects: {
      tanaman: Prisma.$TanamanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_instruksi: number
      instruksi: string
      id_tanaman: string
    }, ExtArgs["result"]["instruksiTanaman"]>
    composites: {}
  }

  type InstruksiTanamanGetPayload<S extends boolean | null | undefined | InstruksiTanamanDefaultArgs> = $Result.GetResult<Prisma.$InstruksiTanamanPayload, S>

  type InstruksiTanamanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstruksiTanamanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstruksiTanamanCountAggregateInputType | true
    }

  export interface InstruksiTanamanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstruksiTanaman'], meta: { name: 'InstruksiTanaman' } }
    /**
     * Find zero or one InstruksiTanaman that matches the filter.
     * @param {InstruksiTanamanFindUniqueArgs} args - Arguments to find a InstruksiTanaman
     * @example
     * // Get one InstruksiTanaman
     * const instruksiTanaman = await prisma.instruksiTanaman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstruksiTanamanFindUniqueArgs>(args: SelectSubset<T, InstruksiTanamanFindUniqueArgs<ExtArgs>>): Prisma__InstruksiTanamanClient<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstruksiTanaman that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstruksiTanamanFindUniqueOrThrowArgs} args - Arguments to find a InstruksiTanaman
     * @example
     * // Get one InstruksiTanaman
     * const instruksiTanaman = await prisma.instruksiTanaman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstruksiTanamanFindUniqueOrThrowArgs>(args: SelectSubset<T, InstruksiTanamanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstruksiTanamanClient<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstruksiTanaman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstruksiTanamanFindFirstArgs} args - Arguments to find a InstruksiTanaman
     * @example
     * // Get one InstruksiTanaman
     * const instruksiTanaman = await prisma.instruksiTanaman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstruksiTanamanFindFirstArgs>(args?: SelectSubset<T, InstruksiTanamanFindFirstArgs<ExtArgs>>): Prisma__InstruksiTanamanClient<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstruksiTanaman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstruksiTanamanFindFirstOrThrowArgs} args - Arguments to find a InstruksiTanaman
     * @example
     * // Get one InstruksiTanaman
     * const instruksiTanaman = await prisma.instruksiTanaman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstruksiTanamanFindFirstOrThrowArgs>(args?: SelectSubset<T, InstruksiTanamanFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstruksiTanamanClient<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstruksiTanamen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstruksiTanamanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstruksiTanamen
     * const instruksiTanamen = await prisma.instruksiTanaman.findMany()
     * 
     * // Get first 10 InstruksiTanamen
     * const instruksiTanamen = await prisma.instruksiTanaman.findMany({ take: 10 })
     * 
     * // Only select the `id_instruksi`
     * const instruksiTanamanWithId_instruksiOnly = await prisma.instruksiTanaman.findMany({ select: { id_instruksi: true } })
     * 
     */
    findMany<T extends InstruksiTanamanFindManyArgs>(args?: SelectSubset<T, InstruksiTanamanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstruksiTanaman.
     * @param {InstruksiTanamanCreateArgs} args - Arguments to create a InstruksiTanaman.
     * @example
     * // Create one InstruksiTanaman
     * const InstruksiTanaman = await prisma.instruksiTanaman.create({
     *   data: {
     *     // ... data to create a InstruksiTanaman
     *   }
     * })
     * 
     */
    create<T extends InstruksiTanamanCreateArgs>(args: SelectSubset<T, InstruksiTanamanCreateArgs<ExtArgs>>): Prisma__InstruksiTanamanClient<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstruksiTanamen.
     * @param {InstruksiTanamanCreateManyArgs} args - Arguments to create many InstruksiTanamen.
     * @example
     * // Create many InstruksiTanamen
     * const instruksiTanaman = await prisma.instruksiTanaman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstruksiTanamanCreateManyArgs>(args?: SelectSubset<T, InstruksiTanamanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstruksiTanamen and returns the data saved in the database.
     * @param {InstruksiTanamanCreateManyAndReturnArgs} args - Arguments to create many InstruksiTanamen.
     * @example
     * // Create many InstruksiTanamen
     * const instruksiTanaman = await prisma.instruksiTanaman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstruksiTanamen and only return the `id_instruksi`
     * const instruksiTanamanWithId_instruksiOnly = await prisma.instruksiTanaman.createManyAndReturn({
     *   select: { id_instruksi: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstruksiTanamanCreateManyAndReturnArgs>(args?: SelectSubset<T, InstruksiTanamanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstruksiTanaman.
     * @param {InstruksiTanamanDeleteArgs} args - Arguments to delete one InstruksiTanaman.
     * @example
     * // Delete one InstruksiTanaman
     * const InstruksiTanaman = await prisma.instruksiTanaman.delete({
     *   where: {
     *     // ... filter to delete one InstruksiTanaman
     *   }
     * })
     * 
     */
    delete<T extends InstruksiTanamanDeleteArgs>(args: SelectSubset<T, InstruksiTanamanDeleteArgs<ExtArgs>>): Prisma__InstruksiTanamanClient<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstruksiTanaman.
     * @param {InstruksiTanamanUpdateArgs} args - Arguments to update one InstruksiTanaman.
     * @example
     * // Update one InstruksiTanaman
     * const instruksiTanaman = await prisma.instruksiTanaman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstruksiTanamanUpdateArgs>(args: SelectSubset<T, InstruksiTanamanUpdateArgs<ExtArgs>>): Prisma__InstruksiTanamanClient<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstruksiTanamen.
     * @param {InstruksiTanamanDeleteManyArgs} args - Arguments to filter InstruksiTanamen to delete.
     * @example
     * // Delete a few InstruksiTanamen
     * const { count } = await prisma.instruksiTanaman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstruksiTanamanDeleteManyArgs>(args?: SelectSubset<T, InstruksiTanamanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstruksiTanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstruksiTanamanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstruksiTanamen
     * const instruksiTanaman = await prisma.instruksiTanaman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstruksiTanamanUpdateManyArgs>(args: SelectSubset<T, InstruksiTanamanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstruksiTanamen and returns the data updated in the database.
     * @param {InstruksiTanamanUpdateManyAndReturnArgs} args - Arguments to update many InstruksiTanamen.
     * @example
     * // Update many InstruksiTanamen
     * const instruksiTanaman = await prisma.instruksiTanaman.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstruksiTanamen and only return the `id_instruksi`
     * const instruksiTanamanWithId_instruksiOnly = await prisma.instruksiTanaman.updateManyAndReturn({
     *   select: { id_instruksi: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstruksiTanamanUpdateManyAndReturnArgs>(args: SelectSubset<T, InstruksiTanamanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstruksiTanaman.
     * @param {InstruksiTanamanUpsertArgs} args - Arguments to update or create a InstruksiTanaman.
     * @example
     * // Update or create a InstruksiTanaman
     * const instruksiTanaman = await prisma.instruksiTanaman.upsert({
     *   create: {
     *     // ... data to create a InstruksiTanaman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstruksiTanaman we want to update
     *   }
     * })
     */
    upsert<T extends InstruksiTanamanUpsertArgs>(args: SelectSubset<T, InstruksiTanamanUpsertArgs<ExtArgs>>): Prisma__InstruksiTanamanClient<$Result.GetResult<Prisma.$InstruksiTanamanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstruksiTanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstruksiTanamanCountArgs} args - Arguments to filter InstruksiTanamen to count.
     * @example
     * // Count the number of InstruksiTanamen
     * const count = await prisma.instruksiTanaman.count({
     *   where: {
     *     // ... the filter for the InstruksiTanamen we want to count
     *   }
     * })
    **/
    count<T extends InstruksiTanamanCountArgs>(
      args?: Subset<T, InstruksiTanamanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstruksiTanamanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstruksiTanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstruksiTanamanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstruksiTanamanAggregateArgs>(args: Subset<T, InstruksiTanamanAggregateArgs>): Prisma.PrismaPromise<GetInstruksiTanamanAggregateType<T>>

    /**
     * Group by InstruksiTanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstruksiTanamanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstruksiTanamanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstruksiTanamanGroupByArgs['orderBy'] }
        : { orderBy?: InstruksiTanamanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstruksiTanamanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstruksiTanamanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstruksiTanaman model
   */
  readonly fields: InstruksiTanamanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstruksiTanaman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstruksiTanamanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tanaman<T extends TanamanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TanamanDefaultArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstruksiTanaman model
   */
  interface InstruksiTanamanFieldRefs {
    readonly id_instruksi: FieldRef<"InstruksiTanaman", 'Int'>
    readonly instruksi: FieldRef<"InstruksiTanaman", 'String'>
    readonly id_tanaman: FieldRef<"InstruksiTanaman", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InstruksiTanaman findUnique
   */
  export type InstruksiTanamanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    /**
     * Filter, which InstruksiTanaman to fetch.
     */
    where: InstruksiTanamanWhereUniqueInput
  }

  /**
   * InstruksiTanaman findUniqueOrThrow
   */
  export type InstruksiTanamanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    /**
     * Filter, which InstruksiTanaman to fetch.
     */
    where: InstruksiTanamanWhereUniqueInput
  }

  /**
   * InstruksiTanaman findFirst
   */
  export type InstruksiTanamanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    /**
     * Filter, which InstruksiTanaman to fetch.
     */
    where?: InstruksiTanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstruksiTanamen to fetch.
     */
    orderBy?: InstruksiTanamanOrderByWithRelationInput | InstruksiTanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstruksiTanamen.
     */
    cursor?: InstruksiTanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstruksiTanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstruksiTanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstruksiTanamen.
     */
    distinct?: InstruksiTanamanScalarFieldEnum | InstruksiTanamanScalarFieldEnum[]
  }

  /**
   * InstruksiTanaman findFirstOrThrow
   */
  export type InstruksiTanamanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    /**
     * Filter, which InstruksiTanaman to fetch.
     */
    where?: InstruksiTanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstruksiTanamen to fetch.
     */
    orderBy?: InstruksiTanamanOrderByWithRelationInput | InstruksiTanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstruksiTanamen.
     */
    cursor?: InstruksiTanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstruksiTanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstruksiTanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstruksiTanamen.
     */
    distinct?: InstruksiTanamanScalarFieldEnum | InstruksiTanamanScalarFieldEnum[]
  }

  /**
   * InstruksiTanaman findMany
   */
  export type InstruksiTanamanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    /**
     * Filter, which InstruksiTanamen to fetch.
     */
    where?: InstruksiTanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstruksiTanamen to fetch.
     */
    orderBy?: InstruksiTanamanOrderByWithRelationInput | InstruksiTanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstruksiTanamen.
     */
    cursor?: InstruksiTanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstruksiTanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstruksiTanamen.
     */
    skip?: number
    distinct?: InstruksiTanamanScalarFieldEnum | InstruksiTanamanScalarFieldEnum[]
  }

  /**
   * InstruksiTanaman create
   */
  export type InstruksiTanamanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    /**
     * The data needed to create a InstruksiTanaman.
     */
    data: XOR<InstruksiTanamanCreateInput, InstruksiTanamanUncheckedCreateInput>
  }

  /**
   * InstruksiTanaman createMany
   */
  export type InstruksiTanamanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstruksiTanamen.
     */
    data: InstruksiTanamanCreateManyInput | InstruksiTanamanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstruksiTanaman createManyAndReturn
   */
  export type InstruksiTanamanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * The data used to create many InstruksiTanamen.
     */
    data: InstruksiTanamanCreateManyInput | InstruksiTanamanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstruksiTanaman update
   */
  export type InstruksiTanamanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    /**
     * The data needed to update a InstruksiTanaman.
     */
    data: XOR<InstruksiTanamanUpdateInput, InstruksiTanamanUncheckedUpdateInput>
    /**
     * Choose, which InstruksiTanaman to update.
     */
    where: InstruksiTanamanWhereUniqueInput
  }

  /**
   * InstruksiTanaman updateMany
   */
  export type InstruksiTanamanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstruksiTanamen.
     */
    data: XOR<InstruksiTanamanUpdateManyMutationInput, InstruksiTanamanUncheckedUpdateManyInput>
    /**
     * Filter which InstruksiTanamen to update
     */
    where?: InstruksiTanamanWhereInput
    /**
     * Limit how many InstruksiTanamen to update.
     */
    limit?: number
  }

  /**
   * InstruksiTanaman updateManyAndReturn
   */
  export type InstruksiTanamanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * The data used to update InstruksiTanamen.
     */
    data: XOR<InstruksiTanamanUpdateManyMutationInput, InstruksiTanamanUncheckedUpdateManyInput>
    /**
     * Filter which InstruksiTanamen to update
     */
    where?: InstruksiTanamanWhereInput
    /**
     * Limit how many InstruksiTanamen to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstruksiTanaman upsert
   */
  export type InstruksiTanamanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    /**
     * The filter to search for the InstruksiTanaman to update in case it exists.
     */
    where: InstruksiTanamanWhereUniqueInput
    /**
     * In case the InstruksiTanaman found by the `where` argument doesn't exist, create a new InstruksiTanaman with this data.
     */
    create: XOR<InstruksiTanamanCreateInput, InstruksiTanamanUncheckedCreateInput>
    /**
     * In case the InstruksiTanaman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstruksiTanamanUpdateInput, InstruksiTanamanUncheckedUpdateInput>
  }

  /**
   * InstruksiTanaman delete
   */
  export type InstruksiTanamanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
    /**
     * Filter which InstruksiTanaman to delete.
     */
    where: InstruksiTanamanWhereUniqueInput
  }

  /**
   * InstruksiTanaman deleteMany
   */
  export type InstruksiTanamanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstruksiTanamen to delete
     */
    where?: InstruksiTanamanWhereInput
    /**
     * Limit how many InstruksiTanamen to delete.
     */
    limit?: number
  }

  /**
   * InstruksiTanaman without action
   */
  export type InstruksiTanamanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstruksiTanaman
     */
    select?: InstruksiTanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstruksiTanaman
     */
    omit?: InstruksiTanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstruksiTanamanInclude<ExtArgs> | null
  }


  /**
   * Model HariPenanaman
   */

  export type AggregateHariPenanaman = {
    _count: HariPenanamanCountAggregateOutputType | null
    _avg: HariPenanamanAvgAggregateOutputType | null
    _sum: HariPenanamanSumAggregateOutputType | null
    _min: HariPenanamanMinAggregateOutputType | null
    _max: HariPenanamanMaxAggregateOutputType | null
  }

  export type HariPenanamanAvgAggregateOutputType = {
    id_hari_penanaman: number | null
    jenis_tugas: number | null
  }

  export type HariPenanamanSumAggregateOutputType = {
    id_hari_penanaman: number | null
    jenis_tugas: number | null
  }

  export type HariPenanamanMinAggregateOutputType = {
    id_hari_penanaman: number | null
    jenis_tugas: number | null
    id_tanaman: string | null
  }

  export type HariPenanamanMaxAggregateOutputType = {
    id_hari_penanaman: number | null
    jenis_tugas: number | null
    id_tanaman: string | null
  }

  export type HariPenanamanCountAggregateOutputType = {
    id_hari_penanaman: number
    jenis_tugas: number
    id_tanaman: number
    _all: number
  }


  export type HariPenanamanAvgAggregateInputType = {
    id_hari_penanaman?: true
    jenis_tugas?: true
  }

  export type HariPenanamanSumAggregateInputType = {
    id_hari_penanaman?: true
    jenis_tugas?: true
  }

  export type HariPenanamanMinAggregateInputType = {
    id_hari_penanaman?: true
    jenis_tugas?: true
    id_tanaman?: true
  }

  export type HariPenanamanMaxAggregateInputType = {
    id_hari_penanaman?: true
    jenis_tugas?: true
    id_tanaman?: true
  }

  export type HariPenanamanCountAggregateInputType = {
    id_hari_penanaman?: true
    jenis_tugas?: true
    id_tanaman?: true
    _all?: true
  }

  export type HariPenanamanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HariPenanaman to aggregate.
     */
    where?: HariPenanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HariPenanamen to fetch.
     */
    orderBy?: HariPenanamanOrderByWithRelationInput | HariPenanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HariPenanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HariPenanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HariPenanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HariPenanamen
    **/
    _count?: true | HariPenanamanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HariPenanamanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HariPenanamanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HariPenanamanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HariPenanamanMaxAggregateInputType
  }

  export type GetHariPenanamanAggregateType<T extends HariPenanamanAggregateArgs> = {
        [P in keyof T & keyof AggregateHariPenanaman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHariPenanaman[P]>
      : GetScalarType<T[P], AggregateHariPenanaman[P]>
  }




  export type HariPenanamanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HariPenanamanWhereInput
    orderBy?: HariPenanamanOrderByWithAggregationInput | HariPenanamanOrderByWithAggregationInput[]
    by: HariPenanamanScalarFieldEnum[] | HariPenanamanScalarFieldEnum
    having?: HariPenanamanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HariPenanamanCountAggregateInputType | true
    _avg?: HariPenanamanAvgAggregateInputType
    _sum?: HariPenanamanSumAggregateInputType
    _min?: HariPenanamanMinAggregateInputType
    _max?: HariPenanamanMaxAggregateInputType
  }

  export type HariPenanamanGroupByOutputType = {
    id_hari_penanaman: number
    jenis_tugas: number
    id_tanaman: string
    _count: HariPenanamanCountAggregateOutputType | null
    _avg: HariPenanamanAvgAggregateOutputType | null
    _sum: HariPenanamanSumAggregateOutputType | null
    _min: HariPenanamanMinAggregateOutputType | null
    _max: HariPenanamanMaxAggregateOutputType | null
  }

  type GetHariPenanamanGroupByPayload<T extends HariPenanamanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HariPenanamanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HariPenanamanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HariPenanamanGroupByOutputType[P]>
            : GetScalarType<T[P], HariPenanamanGroupByOutputType[P]>
        }
      >
    >


  export type HariPenanamanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hari_penanaman?: boolean
    jenis_tugas?: boolean
    id_tanaman?: boolean
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
    tugas_penanaman?: boolean | HariPenanaman$tugas_penanamanArgs<ExtArgs>
    _count?: boolean | HariPenanamanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hariPenanaman"]>

  export type HariPenanamanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hari_penanaman?: boolean
    jenis_tugas?: boolean
    id_tanaman?: boolean
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hariPenanaman"]>

  export type HariPenanamanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hari_penanaman?: boolean
    jenis_tugas?: boolean
    id_tanaman?: boolean
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hariPenanaman"]>

  export type HariPenanamanSelectScalar = {
    id_hari_penanaman?: boolean
    jenis_tugas?: boolean
    id_tanaman?: boolean
  }

  export type HariPenanamanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_hari_penanaman" | "jenis_tugas" | "id_tanaman", ExtArgs["result"]["hariPenanaman"]>
  export type HariPenanamanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
    tugas_penanaman?: boolean | HariPenanaman$tugas_penanamanArgs<ExtArgs>
    _count?: boolean | HariPenanamanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HariPenanamanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }
  export type HariPenanamanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
  }

  export type $HariPenanamanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HariPenanaman"
    objects: {
      tanaman: Prisma.$TanamanPayload<ExtArgs>
      tugas_penanaman: Prisma.$TugasPenanamanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_hari_penanaman: number
      jenis_tugas: number
      id_tanaman: string
    }, ExtArgs["result"]["hariPenanaman"]>
    composites: {}
  }

  type HariPenanamanGetPayload<S extends boolean | null | undefined | HariPenanamanDefaultArgs> = $Result.GetResult<Prisma.$HariPenanamanPayload, S>

  type HariPenanamanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HariPenanamanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HariPenanamanCountAggregateInputType | true
    }

  export interface HariPenanamanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HariPenanaman'], meta: { name: 'HariPenanaman' } }
    /**
     * Find zero or one HariPenanaman that matches the filter.
     * @param {HariPenanamanFindUniqueArgs} args - Arguments to find a HariPenanaman
     * @example
     * // Get one HariPenanaman
     * const hariPenanaman = await prisma.hariPenanaman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HariPenanamanFindUniqueArgs>(args: SelectSubset<T, HariPenanamanFindUniqueArgs<ExtArgs>>): Prisma__HariPenanamanClient<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HariPenanaman that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HariPenanamanFindUniqueOrThrowArgs} args - Arguments to find a HariPenanaman
     * @example
     * // Get one HariPenanaman
     * const hariPenanaman = await prisma.hariPenanaman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HariPenanamanFindUniqueOrThrowArgs>(args: SelectSubset<T, HariPenanamanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HariPenanamanClient<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HariPenanaman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariPenanamanFindFirstArgs} args - Arguments to find a HariPenanaman
     * @example
     * // Get one HariPenanaman
     * const hariPenanaman = await prisma.hariPenanaman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HariPenanamanFindFirstArgs>(args?: SelectSubset<T, HariPenanamanFindFirstArgs<ExtArgs>>): Prisma__HariPenanamanClient<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HariPenanaman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariPenanamanFindFirstOrThrowArgs} args - Arguments to find a HariPenanaman
     * @example
     * // Get one HariPenanaman
     * const hariPenanaman = await prisma.hariPenanaman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HariPenanamanFindFirstOrThrowArgs>(args?: SelectSubset<T, HariPenanamanFindFirstOrThrowArgs<ExtArgs>>): Prisma__HariPenanamanClient<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HariPenanamen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariPenanamanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HariPenanamen
     * const hariPenanamen = await prisma.hariPenanaman.findMany()
     * 
     * // Get first 10 HariPenanamen
     * const hariPenanamen = await prisma.hariPenanaman.findMany({ take: 10 })
     * 
     * // Only select the `id_hari_penanaman`
     * const hariPenanamanWithId_hari_penanamanOnly = await prisma.hariPenanaman.findMany({ select: { id_hari_penanaman: true } })
     * 
     */
    findMany<T extends HariPenanamanFindManyArgs>(args?: SelectSubset<T, HariPenanamanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HariPenanaman.
     * @param {HariPenanamanCreateArgs} args - Arguments to create a HariPenanaman.
     * @example
     * // Create one HariPenanaman
     * const HariPenanaman = await prisma.hariPenanaman.create({
     *   data: {
     *     // ... data to create a HariPenanaman
     *   }
     * })
     * 
     */
    create<T extends HariPenanamanCreateArgs>(args: SelectSubset<T, HariPenanamanCreateArgs<ExtArgs>>): Prisma__HariPenanamanClient<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HariPenanamen.
     * @param {HariPenanamanCreateManyArgs} args - Arguments to create many HariPenanamen.
     * @example
     * // Create many HariPenanamen
     * const hariPenanaman = await prisma.hariPenanaman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HariPenanamanCreateManyArgs>(args?: SelectSubset<T, HariPenanamanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HariPenanamen and returns the data saved in the database.
     * @param {HariPenanamanCreateManyAndReturnArgs} args - Arguments to create many HariPenanamen.
     * @example
     * // Create many HariPenanamen
     * const hariPenanaman = await prisma.hariPenanaman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HariPenanamen and only return the `id_hari_penanaman`
     * const hariPenanamanWithId_hari_penanamanOnly = await prisma.hariPenanaman.createManyAndReturn({
     *   select: { id_hari_penanaman: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HariPenanamanCreateManyAndReturnArgs>(args?: SelectSubset<T, HariPenanamanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HariPenanaman.
     * @param {HariPenanamanDeleteArgs} args - Arguments to delete one HariPenanaman.
     * @example
     * // Delete one HariPenanaman
     * const HariPenanaman = await prisma.hariPenanaman.delete({
     *   where: {
     *     // ... filter to delete one HariPenanaman
     *   }
     * })
     * 
     */
    delete<T extends HariPenanamanDeleteArgs>(args: SelectSubset<T, HariPenanamanDeleteArgs<ExtArgs>>): Prisma__HariPenanamanClient<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HariPenanaman.
     * @param {HariPenanamanUpdateArgs} args - Arguments to update one HariPenanaman.
     * @example
     * // Update one HariPenanaman
     * const hariPenanaman = await prisma.hariPenanaman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HariPenanamanUpdateArgs>(args: SelectSubset<T, HariPenanamanUpdateArgs<ExtArgs>>): Prisma__HariPenanamanClient<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HariPenanamen.
     * @param {HariPenanamanDeleteManyArgs} args - Arguments to filter HariPenanamen to delete.
     * @example
     * // Delete a few HariPenanamen
     * const { count } = await prisma.hariPenanaman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HariPenanamanDeleteManyArgs>(args?: SelectSubset<T, HariPenanamanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HariPenanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariPenanamanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HariPenanamen
     * const hariPenanaman = await prisma.hariPenanaman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HariPenanamanUpdateManyArgs>(args: SelectSubset<T, HariPenanamanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HariPenanamen and returns the data updated in the database.
     * @param {HariPenanamanUpdateManyAndReturnArgs} args - Arguments to update many HariPenanamen.
     * @example
     * // Update many HariPenanamen
     * const hariPenanaman = await prisma.hariPenanaman.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HariPenanamen and only return the `id_hari_penanaman`
     * const hariPenanamanWithId_hari_penanamanOnly = await prisma.hariPenanaman.updateManyAndReturn({
     *   select: { id_hari_penanaman: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HariPenanamanUpdateManyAndReturnArgs>(args: SelectSubset<T, HariPenanamanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HariPenanaman.
     * @param {HariPenanamanUpsertArgs} args - Arguments to update or create a HariPenanaman.
     * @example
     * // Update or create a HariPenanaman
     * const hariPenanaman = await prisma.hariPenanaman.upsert({
     *   create: {
     *     // ... data to create a HariPenanaman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HariPenanaman we want to update
     *   }
     * })
     */
    upsert<T extends HariPenanamanUpsertArgs>(args: SelectSubset<T, HariPenanamanUpsertArgs<ExtArgs>>): Prisma__HariPenanamanClient<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HariPenanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariPenanamanCountArgs} args - Arguments to filter HariPenanamen to count.
     * @example
     * // Count the number of HariPenanamen
     * const count = await prisma.hariPenanaman.count({
     *   where: {
     *     // ... the filter for the HariPenanamen we want to count
     *   }
     * })
    **/
    count<T extends HariPenanamanCountArgs>(
      args?: Subset<T, HariPenanamanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HariPenanamanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HariPenanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariPenanamanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HariPenanamanAggregateArgs>(args: Subset<T, HariPenanamanAggregateArgs>): Prisma.PrismaPromise<GetHariPenanamanAggregateType<T>>

    /**
     * Group by HariPenanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariPenanamanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HariPenanamanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HariPenanamanGroupByArgs['orderBy'] }
        : { orderBy?: HariPenanamanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HariPenanamanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHariPenanamanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HariPenanaman model
   */
  readonly fields: HariPenanamanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HariPenanaman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HariPenanamanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tanaman<T extends TanamanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TanamanDefaultArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tugas_penanaman<T extends HariPenanaman$tugas_penanamanArgs<ExtArgs> = {}>(args?: Subset<T, HariPenanaman$tugas_penanamanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HariPenanaman model
   */
  interface HariPenanamanFieldRefs {
    readonly id_hari_penanaman: FieldRef<"HariPenanaman", 'Int'>
    readonly jenis_tugas: FieldRef<"HariPenanaman", 'Int'>
    readonly id_tanaman: FieldRef<"HariPenanaman", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HariPenanaman findUnique
   */
  export type HariPenanamanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which HariPenanaman to fetch.
     */
    where: HariPenanamanWhereUniqueInput
  }

  /**
   * HariPenanaman findUniqueOrThrow
   */
  export type HariPenanamanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which HariPenanaman to fetch.
     */
    where: HariPenanamanWhereUniqueInput
  }

  /**
   * HariPenanaman findFirst
   */
  export type HariPenanamanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which HariPenanaman to fetch.
     */
    where?: HariPenanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HariPenanamen to fetch.
     */
    orderBy?: HariPenanamanOrderByWithRelationInput | HariPenanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HariPenanamen.
     */
    cursor?: HariPenanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HariPenanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HariPenanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HariPenanamen.
     */
    distinct?: HariPenanamanScalarFieldEnum | HariPenanamanScalarFieldEnum[]
  }

  /**
   * HariPenanaman findFirstOrThrow
   */
  export type HariPenanamanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which HariPenanaman to fetch.
     */
    where?: HariPenanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HariPenanamen to fetch.
     */
    orderBy?: HariPenanamanOrderByWithRelationInput | HariPenanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HariPenanamen.
     */
    cursor?: HariPenanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HariPenanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HariPenanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HariPenanamen.
     */
    distinct?: HariPenanamanScalarFieldEnum | HariPenanamanScalarFieldEnum[]
  }

  /**
   * HariPenanaman findMany
   */
  export type HariPenanamanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which HariPenanamen to fetch.
     */
    where?: HariPenanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HariPenanamen to fetch.
     */
    orderBy?: HariPenanamanOrderByWithRelationInput | HariPenanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HariPenanamen.
     */
    cursor?: HariPenanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HariPenanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HariPenanamen.
     */
    skip?: number
    distinct?: HariPenanamanScalarFieldEnum | HariPenanamanScalarFieldEnum[]
  }

  /**
   * HariPenanaman create
   */
  export type HariPenanamanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    /**
     * The data needed to create a HariPenanaman.
     */
    data: XOR<HariPenanamanCreateInput, HariPenanamanUncheckedCreateInput>
  }

  /**
   * HariPenanaman createMany
   */
  export type HariPenanamanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HariPenanamen.
     */
    data: HariPenanamanCreateManyInput | HariPenanamanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HariPenanaman createManyAndReturn
   */
  export type HariPenanamanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * The data used to create many HariPenanamen.
     */
    data: HariPenanamanCreateManyInput | HariPenanamanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HariPenanaman update
   */
  export type HariPenanamanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    /**
     * The data needed to update a HariPenanaman.
     */
    data: XOR<HariPenanamanUpdateInput, HariPenanamanUncheckedUpdateInput>
    /**
     * Choose, which HariPenanaman to update.
     */
    where: HariPenanamanWhereUniqueInput
  }

  /**
   * HariPenanaman updateMany
   */
  export type HariPenanamanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HariPenanamen.
     */
    data: XOR<HariPenanamanUpdateManyMutationInput, HariPenanamanUncheckedUpdateManyInput>
    /**
     * Filter which HariPenanamen to update
     */
    where?: HariPenanamanWhereInput
    /**
     * Limit how many HariPenanamen to update.
     */
    limit?: number
  }

  /**
   * HariPenanaman updateManyAndReturn
   */
  export type HariPenanamanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * The data used to update HariPenanamen.
     */
    data: XOR<HariPenanamanUpdateManyMutationInput, HariPenanamanUncheckedUpdateManyInput>
    /**
     * Filter which HariPenanamen to update
     */
    where?: HariPenanamanWhereInput
    /**
     * Limit how many HariPenanamen to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HariPenanaman upsert
   */
  export type HariPenanamanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    /**
     * The filter to search for the HariPenanaman to update in case it exists.
     */
    where: HariPenanamanWhereUniqueInput
    /**
     * In case the HariPenanaman found by the `where` argument doesn't exist, create a new HariPenanaman with this data.
     */
    create: XOR<HariPenanamanCreateInput, HariPenanamanUncheckedCreateInput>
    /**
     * In case the HariPenanaman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HariPenanamanUpdateInput, HariPenanamanUncheckedUpdateInput>
  }

  /**
   * HariPenanaman delete
   */
  export type HariPenanamanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
    /**
     * Filter which HariPenanaman to delete.
     */
    where: HariPenanamanWhereUniqueInput
  }

  /**
   * HariPenanaman deleteMany
   */
  export type HariPenanamanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HariPenanamen to delete
     */
    where?: HariPenanamanWhereInput
    /**
     * Limit how many HariPenanamen to delete.
     */
    limit?: number
  }

  /**
   * HariPenanaman.tugas_penanaman
   */
  export type HariPenanaman$tugas_penanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    where?: TugasPenanamanWhereInput
    orderBy?: TugasPenanamanOrderByWithRelationInput | TugasPenanamanOrderByWithRelationInput[]
    cursor?: TugasPenanamanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TugasPenanamanScalarFieldEnum | TugasPenanamanScalarFieldEnum[]
  }

  /**
   * HariPenanaman without action
   */
  export type HariPenanamanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariPenanaman
     */
    select?: HariPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariPenanaman
     */
    omit?: HariPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariPenanamanInclude<ExtArgs> | null
  }


  /**
   * Model TugasPenanaman
   */

  export type AggregateTugasPenanaman = {
    _count: TugasPenanamanCountAggregateOutputType | null
    _avg: TugasPenanamanAvgAggregateOutputType | null
    _sum: TugasPenanamanSumAggregateOutputType | null
    _min: TugasPenanamanMinAggregateOutputType | null
    _max: TugasPenanamanMaxAggregateOutputType | null
  }

  export type TugasPenanamanAvgAggregateOutputType = {
    id_tugas: number | null
    id_hari_penanaman: number | null
  }

  export type TugasPenanamanSumAggregateOutputType = {
    id_tugas: number | null
    id_hari_penanaman: number | null
  }

  export type TugasPenanamanMinAggregateOutputType = {
    id_tugas: number | null
    nama_tugas: string | null
    id_hari_penanaman: number | null
  }

  export type TugasPenanamanMaxAggregateOutputType = {
    id_tugas: number | null
    nama_tugas: string | null
    id_hari_penanaman: number | null
  }

  export type TugasPenanamanCountAggregateOutputType = {
    id_tugas: number
    nama_tugas: number
    id_hari_penanaman: number
    _all: number
  }


  export type TugasPenanamanAvgAggregateInputType = {
    id_tugas?: true
    id_hari_penanaman?: true
  }

  export type TugasPenanamanSumAggregateInputType = {
    id_tugas?: true
    id_hari_penanaman?: true
  }

  export type TugasPenanamanMinAggregateInputType = {
    id_tugas?: true
    nama_tugas?: true
    id_hari_penanaman?: true
  }

  export type TugasPenanamanMaxAggregateInputType = {
    id_tugas?: true
    nama_tugas?: true
    id_hari_penanaman?: true
  }

  export type TugasPenanamanCountAggregateInputType = {
    id_tugas?: true
    nama_tugas?: true
    id_hari_penanaman?: true
    _all?: true
  }

  export type TugasPenanamanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TugasPenanaman to aggregate.
     */
    where?: TugasPenanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TugasPenanamen to fetch.
     */
    orderBy?: TugasPenanamanOrderByWithRelationInput | TugasPenanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TugasPenanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TugasPenanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TugasPenanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TugasPenanamen
    **/
    _count?: true | TugasPenanamanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TugasPenanamanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TugasPenanamanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TugasPenanamanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TugasPenanamanMaxAggregateInputType
  }

  export type GetTugasPenanamanAggregateType<T extends TugasPenanamanAggregateArgs> = {
        [P in keyof T & keyof AggregateTugasPenanaman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTugasPenanaman[P]>
      : GetScalarType<T[P], AggregateTugasPenanaman[P]>
  }




  export type TugasPenanamanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TugasPenanamanWhereInput
    orderBy?: TugasPenanamanOrderByWithAggregationInput | TugasPenanamanOrderByWithAggregationInput[]
    by: TugasPenanamanScalarFieldEnum[] | TugasPenanamanScalarFieldEnum
    having?: TugasPenanamanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TugasPenanamanCountAggregateInputType | true
    _avg?: TugasPenanamanAvgAggregateInputType
    _sum?: TugasPenanamanSumAggregateInputType
    _min?: TugasPenanamanMinAggregateInputType
    _max?: TugasPenanamanMaxAggregateInputType
  }

  export type TugasPenanamanGroupByOutputType = {
    id_tugas: number
    nama_tugas: string
    id_hari_penanaman: number
    _count: TugasPenanamanCountAggregateOutputType | null
    _avg: TugasPenanamanAvgAggregateOutputType | null
    _sum: TugasPenanamanSumAggregateOutputType | null
    _min: TugasPenanamanMinAggregateOutputType | null
    _max: TugasPenanamanMaxAggregateOutputType | null
  }

  type GetTugasPenanamanGroupByPayload<T extends TugasPenanamanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TugasPenanamanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TugasPenanamanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TugasPenanamanGroupByOutputType[P]>
            : GetScalarType<T[P], TugasPenanamanGroupByOutputType[P]>
        }
      >
    >


  export type TugasPenanamanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tugas?: boolean
    nama_tugas?: boolean
    id_hari_penanaman?: boolean
    hari_penanaman?: boolean | HariPenanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tugasPenanaman"]>

  export type TugasPenanamanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tugas?: boolean
    nama_tugas?: boolean
    id_hari_penanaman?: boolean
    hari_penanaman?: boolean | HariPenanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tugasPenanaman"]>

  export type TugasPenanamanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tugas?: boolean
    nama_tugas?: boolean
    id_hari_penanaman?: boolean
    hari_penanaman?: boolean | HariPenanamanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tugasPenanaman"]>

  export type TugasPenanamanSelectScalar = {
    id_tugas?: boolean
    nama_tugas?: boolean
    id_hari_penanaman?: boolean
  }

  export type TugasPenanamanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tugas" | "nama_tugas" | "id_hari_penanaman", ExtArgs["result"]["tugasPenanaman"]>
  export type TugasPenanamanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hari_penanaman?: boolean | HariPenanamanDefaultArgs<ExtArgs>
  }
  export type TugasPenanamanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hari_penanaman?: boolean | HariPenanamanDefaultArgs<ExtArgs>
  }
  export type TugasPenanamanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hari_penanaman?: boolean | HariPenanamanDefaultArgs<ExtArgs>
  }

  export type $TugasPenanamanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TugasPenanaman"
    objects: {
      hari_penanaman: Prisma.$HariPenanamanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tugas: number
      nama_tugas: string
      id_hari_penanaman: number
    }, ExtArgs["result"]["tugasPenanaman"]>
    composites: {}
  }

  type TugasPenanamanGetPayload<S extends boolean | null | undefined | TugasPenanamanDefaultArgs> = $Result.GetResult<Prisma.$TugasPenanamanPayload, S>

  type TugasPenanamanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TugasPenanamanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TugasPenanamanCountAggregateInputType | true
    }

  export interface TugasPenanamanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TugasPenanaman'], meta: { name: 'TugasPenanaman' } }
    /**
     * Find zero or one TugasPenanaman that matches the filter.
     * @param {TugasPenanamanFindUniqueArgs} args - Arguments to find a TugasPenanaman
     * @example
     * // Get one TugasPenanaman
     * const tugasPenanaman = await prisma.tugasPenanaman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TugasPenanamanFindUniqueArgs>(args: SelectSubset<T, TugasPenanamanFindUniqueArgs<ExtArgs>>): Prisma__TugasPenanamanClient<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TugasPenanaman that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TugasPenanamanFindUniqueOrThrowArgs} args - Arguments to find a TugasPenanaman
     * @example
     * // Get one TugasPenanaman
     * const tugasPenanaman = await prisma.tugasPenanaman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TugasPenanamanFindUniqueOrThrowArgs>(args: SelectSubset<T, TugasPenanamanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TugasPenanamanClient<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TugasPenanaman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanFindFirstArgs} args - Arguments to find a TugasPenanaman
     * @example
     * // Get one TugasPenanaman
     * const tugasPenanaman = await prisma.tugasPenanaman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TugasPenanamanFindFirstArgs>(args?: SelectSubset<T, TugasPenanamanFindFirstArgs<ExtArgs>>): Prisma__TugasPenanamanClient<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TugasPenanaman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanFindFirstOrThrowArgs} args - Arguments to find a TugasPenanaman
     * @example
     * // Get one TugasPenanaman
     * const tugasPenanaman = await prisma.tugasPenanaman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TugasPenanamanFindFirstOrThrowArgs>(args?: SelectSubset<T, TugasPenanamanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TugasPenanamanClient<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TugasPenanamen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TugasPenanamen
     * const tugasPenanamen = await prisma.tugasPenanaman.findMany()
     * 
     * // Get first 10 TugasPenanamen
     * const tugasPenanamen = await prisma.tugasPenanaman.findMany({ take: 10 })
     * 
     * // Only select the `id_tugas`
     * const tugasPenanamanWithId_tugasOnly = await prisma.tugasPenanaman.findMany({ select: { id_tugas: true } })
     * 
     */
    findMany<T extends TugasPenanamanFindManyArgs>(args?: SelectSubset<T, TugasPenanamanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TugasPenanaman.
     * @param {TugasPenanamanCreateArgs} args - Arguments to create a TugasPenanaman.
     * @example
     * // Create one TugasPenanaman
     * const TugasPenanaman = await prisma.tugasPenanaman.create({
     *   data: {
     *     // ... data to create a TugasPenanaman
     *   }
     * })
     * 
     */
    create<T extends TugasPenanamanCreateArgs>(args: SelectSubset<T, TugasPenanamanCreateArgs<ExtArgs>>): Prisma__TugasPenanamanClient<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TugasPenanamen.
     * @param {TugasPenanamanCreateManyArgs} args - Arguments to create many TugasPenanamen.
     * @example
     * // Create many TugasPenanamen
     * const tugasPenanaman = await prisma.tugasPenanaman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TugasPenanamanCreateManyArgs>(args?: SelectSubset<T, TugasPenanamanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TugasPenanamen and returns the data saved in the database.
     * @param {TugasPenanamanCreateManyAndReturnArgs} args - Arguments to create many TugasPenanamen.
     * @example
     * // Create many TugasPenanamen
     * const tugasPenanaman = await prisma.tugasPenanaman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TugasPenanamen and only return the `id_tugas`
     * const tugasPenanamanWithId_tugasOnly = await prisma.tugasPenanaman.createManyAndReturn({
     *   select: { id_tugas: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TugasPenanamanCreateManyAndReturnArgs>(args?: SelectSubset<T, TugasPenanamanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TugasPenanaman.
     * @param {TugasPenanamanDeleteArgs} args - Arguments to delete one TugasPenanaman.
     * @example
     * // Delete one TugasPenanaman
     * const TugasPenanaman = await prisma.tugasPenanaman.delete({
     *   where: {
     *     // ... filter to delete one TugasPenanaman
     *   }
     * })
     * 
     */
    delete<T extends TugasPenanamanDeleteArgs>(args: SelectSubset<T, TugasPenanamanDeleteArgs<ExtArgs>>): Prisma__TugasPenanamanClient<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TugasPenanaman.
     * @param {TugasPenanamanUpdateArgs} args - Arguments to update one TugasPenanaman.
     * @example
     * // Update one TugasPenanaman
     * const tugasPenanaman = await prisma.tugasPenanaman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TugasPenanamanUpdateArgs>(args: SelectSubset<T, TugasPenanamanUpdateArgs<ExtArgs>>): Prisma__TugasPenanamanClient<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TugasPenanamen.
     * @param {TugasPenanamanDeleteManyArgs} args - Arguments to filter TugasPenanamen to delete.
     * @example
     * // Delete a few TugasPenanamen
     * const { count } = await prisma.tugasPenanaman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TugasPenanamanDeleteManyArgs>(args?: SelectSubset<T, TugasPenanamanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TugasPenanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TugasPenanamen
     * const tugasPenanaman = await prisma.tugasPenanaman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TugasPenanamanUpdateManyArgs>(args: SelectSubset<T, TugasPenanamanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TugasPenanamen and returns the data updated in the database.
     * @param {TugasPenanamanUpdateManyAndReturnArgs} args - Arguments to update many TugasPenanamen.
     * @example
     * // Update many TugasPenanamen
     * const tugasPenanaman = await prisma.tugasPenanaman.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TugasPenanamen and only return the `id_tugas`
     * const tugasPenanamanWithId_tugasOnly = await prisma.tugasPenanaman.updateManyAndReturn({
     *   select: { id_tugas: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TugasPenanamanUpdateManyAndReturnArgs>(args: SelectSubset<T, TugasPenanamanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TugasPenanaman.
     * @param {TugasPenanamanUpsertArgs} args - Arguments to update or create a TugasPenanaman.
     * @example
     * // Update or create a TugasPenanaman
     * const tugasPenanaman = await prisma.tugasPenanaman.upsert({
     *   create: {
     *     // ... data to create a TugasPenanaman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TugasPenanaman we want to update
     *   }
     * })
     */
    upsert<T extends TugasPenanamanUpsertArgs>(args: SelectSubset<T, TugasPenanamanUpsertArgs<ExtArgs>>): Prisma__TugasPenanamanClient<$Result.GetResult<Prisma.$TugasPenanamanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TugasPenanamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanCountArgs} args - Arguments to filter TugasPenanamen to count.
     * @example
     * // Count the number of TugasPenanamen
     * const count = await prisma.tugasPenanaman.count({
     *   where: {
     *     // ... the filter for the TugasPenanamen we want to count
     *   }
     * })
    **/
    count<T extends TugasPenanamanCountArgs>(
      args?: Subset<T, TugasPenanamanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TugasPenanamanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TugasPenanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TugasPenanamanAggregateArgs>(args: Subset<T, TugasPenanamanAggregateArgs>): Prisma.PrismaPromise<GetTugasPenanamanAggregateType<T>>

    /**
     * Group by TugasPenanaman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TugasPenanamanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TugasPenanamanGroupByArgs['orderBy'] }
        : { orderBy?: TugasPenanamanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TugasPenanamanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTugasPenanamanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TugasPenanaman model
   */
  readonly fields: TugasPenanamanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TugasPenanaman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TugasPenanamanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hari_penanaman<T extends HariPenanamanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HariPenanamanDefaultArgs<ExtArgs>>): Prisma__HariPenanamanClient<$Result.GetResult<Prisma.$HariPenanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TugasPenanaman model
   */
  interface TugasPenanamanFieldRefs {
    readonly id_tugas: FieldRef<"TugasPenanaman", 'Int'>
    readonly nama_tugas: FieldRef<"TugasPenanaman", 'String'>
    readonly id_hari_penanaman: FieldRef<"TugasPenanaman", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TugasPenanaman findUnique
   */
  export type TugasPenanamanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanaman to fetch.
     */
    where: TugasPenanamanWhereUniqueInput
  }

  /**
   * TugasPenanaman findUniqueOrThrow
   */
  export type TugasPenanamanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanaman to fetch.
     */
    where: TugasPenanamanWhereUniqueInput
  }

  /**
   * TugasPenanaman findFirst
   */
  export type TugasPenanamanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanaman to fetch.
     */
    where?: TugasPenanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TugasPenanamen to fetch.
     */
    orderBy?: TugasPenanamanOrderByWithRelationInput | TugasPenanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TugasPenanamen.
     */
    cursor?: TugasPenanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TugasPenanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TugasPenanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TugasPenanamen.
     */
    distinct?: TugasPenanamanScalarFieldEnum | TugasPenanamanScalarFieldEnum[]
  }

  /**
   * TugasPenanaman findFirstOrThrow
   */
  export type TugasPenanamanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanaman to fetch.
     */
    where?: TugasPenanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TugasPenanamen to fetch.
     */
    orderBy?: TugasPenanamanOrderByWithRelationInput | TugasPenanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TugasPenanamen.
     */
    cursor?: TugasPenanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TugasPenanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TugasPenanamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TugasPenanamen.
     */
    distinct?: TugasPenanamanScalarFieldEnum | TugasPenanamanScalarFieldEnum[]
  }

  /**
   * TugasPenanaman findMany
   */
  export type TugasPenanamanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanamen to fetch.
     */
    where?: TugasPenanamanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TugasPenanamen to fetch.
     */
    orderBy?: TugasPenanamanOrderByWithRelationInput | TugasPenanamanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TugasPenanamen.
     */
    cursor?: TugasPenanamanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TugasPenanamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TugasPenanamen.
     */
    skip?: number
    distinct?: TugasPenanamanScalarFieldEnum | TugasPenanamanScalarFieldEnum[]
  }

  /**
   * TugasPenanaman create
   */
  export type TugasPenanamanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    /**
     * The data needed to create a TugasPenanaman.
     */
    data: XOR<TugasPenanamanCreateInput, TugasPenanamanUncheckedCreateInput>
  }

  /**
   * TugasPenanaman createMany
   */
  export type TugasPenanamanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TugasPenanamen.
     */
    data: TugasPenanamanCreateManyInput | TugasPenanamanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TugasPenanaman createManyAndReturn
   */
  export type TugasPenanamanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * The data used to create many TugasPenanamen.
     */
    data: TugasPenanamanCreateManyInput | TugasPenanamanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TugasPenanaman update
   */
  export type TugasPenanamanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    /**
     * The data needed to update a TugasPenanaman.
     */
    data: XOR<TugasPenanamanUpdateInput, TugasPenanamanUncheckedUpdateInput>
    /**
     * Choose, which TugasPenanaman to update.
     */
    where: TugasPenanamanWhereUniqueInput
  }

  /**
   * TugasPenanaman updateMany
   */
  export type TugasPenanamanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TugasPenanamen.
     */
    data: XOR<TugasPenanamanUpdateManyMutationInput, TugasPenanamanUncheckedUpdateManyInput>
    /**
     * Filter which TugasPenanamen to update
     */
    where?: TugasPenanamanWhereInput
    /**
     * Limit how many TugasPenanamen to update.
     */
    limit?: number
  }

  /**
   * TugasPenanaman updateManyAndReturn
   */
  export type TugasPenanamanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * The data used to update TugasPenanamen.
     */
    data: XOR<TugasPenanamanUpdateManyMutationInput, TugasPenanamanUncheckedUpdateManyInput>
    /**
     * Filter which TugasPenanamen to update
     */
    where?: TugasPenanamanWhereInput
    /**
     * Limit how many TugasPenanamen to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TugasPenanaman upsert
   */
  export type TugasPenanamanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    /**
     * The filter to search for the TugasPenanaman to update in case it exists.
     */
    where: TugasPenanamanWhereUniqueInput
    /**
     * In case the TugasPenanaman found by the `where` argument doesn't exist, create a new TugasPenanaman with this data.
     */
    create: XOR<TugasPenanamanCreateInput, TugasPenanamanUncheckedCreateInput>
    /**
     * In case the TugasPenanaman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TugasPenanamanUpdateInput, TugasPenanamanUncheckedUpdateInput>
  }

  /**
   * TugasPenanaman delete
   */
  export type TugasPenanamanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
    /**
     * Filter which TugasPenanaman to delete.
     */
    where: TugasPenanamanWhereUniqueInput
  }

  /**
   * TugasPenanaman deleteMany
   */
  export type TugasPenanamanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TugasPenanamen to delete
     */
    where?: TugasPenanamanWhereInput
    /**
     * Limit how many TugasPenanamen to delete.
     */
    limit?: number
  }

  /**
   * TugasPenanaman without action
   */
  export type TugasPenanamanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanaman
     */
    select?: TugasPenanamanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanaman
     */
    omit?: TugasPenanamanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanInclude<ExtArgs> | null
  }


  /**
   * Model TanamanPengguna
   */

  export type AggregateTanamanPengguna = {
    _count: TanamanPenggunaCountAggregateOutputType | null
    _min: TanamanPenggunaMinAggregateOutputType | null
    _max: TanamanPenggunaMaxAggregateOutputType | null
  }

  export type TanamanPenggunaMinAggregateOutputType = {
    id_tanaman_pengguna: string | null
    tanggal_penanaman: Date | null
    status_penanaman: boolean | null
    nama_tanaman: string | null
    id_tanaman: string | null
    id_pengguna: string | null
  }

  export type TanamanPenggunaMaxAggregateOutputType = {
    id_tanaman_pengguna: string | null
    tanggal_penanaman: Date | null
    status_penanaman: boolean | null
    nama_tanaman: string | null
    id_tanaman: string | null
    id_pengguna: string | null
  }

  export type TanamanPenggunaCountAggregateOutputType = {
    id_tanaman_pengguna: number
    tanggal_penanaman: number
    status_penanaman: number
    nama_tanaman: number
    id_tanaman: number
    id_pengguna: number
    _all: number
  }


  export type TanamanPenggunaMinAggregateInputType = {
    id_tanaman_pengguna?: true
    tanggal_penanaman?: true
    status_penanaman?: true
    nama_tanaman?: true
    id_tanaman?: true
    id_pengguna?: true
  }

  export type TanamanPenggunaMaxAggregateInputType = {
    id_tanaman_pengguna?: true
    tanggal_penanaman?: true
    status_penanaman?: true
    nama_tanaman?: true
    id_tanaman?: true
    id_pengguna?: true
  }

  export type TanamanPenggunaCountAggregateInputType = {
    id_tanaman_pengguna?: true
    tanggal_penanaman?: true
    status_penanaman?: true
    nama_tanaman?: true
    id_tanaman?: true
    id_pengguna?: true
    _all?: true
  }

  export type TanamanPenggunaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TanamanPengguna to aggregate.
     */
    where?: TanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TanamanPenggunas to fetch.
     */
    orderBy?: TanamanPenggunaOrderByWithRelationInput | TanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TanamanPenggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TanamanPenggunas
    **/
    _count?: true | TanamanPenggunaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TanamanPenggunaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TanamanPenggunaMaxAggregateInputType
  }

  export type GetTanamanPenggunaAggregateType<T extends TanamanPenggunaAggregateArgs> = {
        [P in keyof T & keyof AggregateTanamanPengguna]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTanamanPengguna[P]>
      : GetScalarType<T[P], AggregateTanamanPengguna[P]>
  }




  export type TanamanPenggunaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TanamanPenggunaWhereInput
    orderBy?: TanamanPenggunaOrderByWithAggregationInput | TanamanPenggunaOrderByWithAggregationInput[]
    by: TanamanPenggunaScalarFieldEnum[] | TanamanPenggunaScalarFieldEnum
    having?: TanamanPenggunaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TanamanPenggunaCountAggregateInputType | true
    _min?: TanamanPenggunaMinAggregateInputType
    _max?: TanamanPenggunaMaxAggregateInputType
  }

  export type TanamanPenggunaGroupByOutputType = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date
    status_penanaman: boolean
    nama_tanaman: string
    id_tanaman: string
    id_pengguna: string
    _count: TanamanPenggunaCountAggregateOutputType | null
    _min: TanamanPenggunaMinAggregateOutputType | null
    _max: TanamanPenggunaMaxAggregateOutputType | null
  }

  type GetTanamanPenggunaGroupByPayload<T extends TanamanPenggunaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TanamanPenggunaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TanamanPenggunaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TanamanPenggunaGroupByOutputType[P]>
            : GetScalarType<T[P], TanamanPenggunaGroupByOutputType[P]>
        }
      >
    >


  export type TanamanPenggunaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tanaman_pengguna?: boolean
    tanggal_penanaman?: boolean
    status_penanaman?: boolean
    nama_tanaman?: boolean
    id_tanaman?: boolean
    id_pengguna?: boolean
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    hari_tanaman?: boolean | TanamanPengguna$hari_tanamanArgs<ExtArgs>
    _count?: boolean | TanamanPenggunaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tanamanPengguna"]>

  export type TanamanPenggunaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tanaman_pengguna?: boolean
    tanggal_penanaman?: boolean
    status_penanaman?: boolean
    nama_tanaman?: boolean
    id_tanaman?: boolean
    id_pengguna?: boolean
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tanamanPengguna"]>

  export type TanamanPenggunaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tanaman_pengguna?: boolean
    tanggal_penanaman?: boolean
    status_penanaman?: boolean
    nama_tanaman?: boolean
    id_tanaman?: boolean
    id_pengguna?: boolean
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tanamanPengguna"]>

  export type TanamanPenggunaSelectScalar = {
    id_tanaman_pengguna?: boolean
    tanggal_penanaman?: boolean
    status_penanaman?: boolean
    nama_tanaman?: boolean
    id_tanaman?: boolean
    id_pengguna?: boolean
  }

  export type TanamanPenggunaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tanaman_pengguna" | "tanggal_penanaman" | "status_penanaman" | "nama_tanaman" | "id_tanaman" | "id_pengguna", ExtArgs["result"]["tanamanPengguna"]>
  export type TanamanPenggunaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
    hari_tanaman?: boolean | TanamanPengguna$hari_tanamanArgs<ExtArgs>
    _count?: boolean | TanamanPenggunaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TanamanPenggunaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }
  export type TanamanPenggunaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman?: boolean | TanamanDefaultArgs<ExtArgs>
    pengguna?: boolean | PenggunaDefaultArgs<ExtArgs>
  }

  export type $TanamanPenggunaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TanamanPengguna"
    objects: {
      tanaman: Prisma.$TanamanPayload<ExtArgs>
      pengguna: Prisma.$PenggunaPayload<ExtArgs>
      hari_tanaman: Prisma.$HariTanamanPenggunaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tanaman_pengguna: string
      tanggal_penanaman: Date
      status_penanaman: boolean
      nama_tanaman: string
      id_tanaman: string
      id_pengguna: string
    }, ExtArgs["result"]["tanamanPengguna"]>
    composites: {}
  }

  type TanamanPenggunaGetPayload<S extends boolean | null | undefined | TanamanPenggunaDefaultArgs> = $Result.GetResult<Prisma.$TanamanPenggunaPayload, S>

  type TanamanPenggunaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TanamanPenggunaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TanamanPenggunaCountAggregateInputType | true
    }

  export interface TanamanPenggunaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TanamanPengguna'], meta: { name: 'TanamanPengguna' } }
    /**
     * Find zero or one TanamanPengguna that matches the filter.
     * @param {TanamanPenggunaFindUniqueArgs} args - Arguments to find a TanamanPengguna
     * @example
     * // Get one TanamanPengguna
     * const tanamanPengguna = await prisma.tanamanPengguna.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TanamanPenggunaFindUniqueArgs>(args: SelectSubset<T, TanamanPenggunaFindUniqueArgs<ExtArgs>>): Prisma__TanamanPenggunaClient<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TanamanPengguna that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TanamanPenggunaFindUniqueOrThrowArgs} args - Arguments to find a TanamanPengguna
     * @example
     * // Get one TanamanPengguna
     * const tanamanPengguna = await prisma.tanamanPengguna.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TanamanPenggunaFindUniqueOrThrowArgs>(args: SelectSubset<T, TanamanPenggunaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TanamanPenggunaClient<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TanamanPengguna that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanPenggunaFindFirstArgs} args - Arguments to find a TanamanPengguna
     * @example
     * // Get one TanamanPengguna
     * const tanamanPengguna = await prisma.tanamanPengguna.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TanamanPenggunaFindFirstArgs>(args?: SelectSubset<T, TanamanPenggunaFindFirstArgs<ExtArgs>>): Prisma__TanamanPenggunaClient<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TanamanPengguna that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanPenggunaFindFirstOrThrowArgs} args - Arguments to find a TanamanPengguna
     * @example
     * // Get one TanamanPengguna
     * const tanamanPengguna = await prisma.tanamanPengguna.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TanamanPenggunaFindFirstOrThrowArgs>(args?: SelectSubset<T, TanamanPenggunaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TanamanPenggunaClient<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TanamanPenggunas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanPenggunaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TanamanPenggunas
     * const tanamanPenggunas = await prisma.tanamanPengguna.findMany()
     * 
     * // Get first 10 TanamanPenggunas
     * const tanamanPenggunas = await prisma.tanamanPengguna.findMany({ take: 10 })
     * 
     * // Only select the `id_tanaman_pengguna`
     * const tanamanPenggunaWithId_tanaman_penggunaOnly = await prisma.tanamanPengguna.findMany({ select: { id_tanaman_pengguna: true } })
     * 
     */
    findMany<T extends TanamanPenggunaFindManyArgs>(args?: SelectSubset<T, TanamanPenggunaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TanamanPengguna.
     * @param {TanamanPenggunaCreateArgs} args - Arguments to create a TanamanPengguna.
     * @example
     * // Create one TanamanPengguna
     * const TanamanPengguna = await prisma.tanamanPengguna.create({
     *   data: {
     *     // ... data to create a TanamanPengguna
     *   }
     * })
     * 
     */
    create<T extends TanamanPenggunaCreateArgs>(args: SelectSubset<T, TanamanPenggunaCreateArgs<ExtArgs>>): Prisma__TanamanPenggunaClient<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TanamanPenggunas.
     * @param {TanamanPenggunaCreateManyArgs} args - Arguments to create many TanamanPenggunas.
     * @example
     * // Create many TanamanPenggunas
     * const tanamanPengguna = await prisma.tanamanPengguna.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TanamanPenggunaCreateManyArgs>(args?: SelectSubset<T, TanamanPenggunaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TanamanPenggunas and returns the data saved in the database.
     * @param {TanamanPenggunaCreateManyAndReturnArgs} args - Arguments to create many TanamanPenggunas.
     * @example
     * // Create many TanamanPenggunas
     * const tanamanPengguna = await prisma.tanamanPengguna.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TanamanPenggunas and only return the `id_tanaman_pengguna`
     * const tanamanPenggunaWithId_tanaman_penggunaOnly = await prisma.tanamanPengguna.createManyAndReturn({
     *   select: { id_tanaman_pengguna: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TanamanPenggunaCreateManyAndReturnArgs>(args?: SelectSubset<T, TanamanPenggunaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TanamanPengguna.
     * @param {TanamanPenggunaDeleteArgs} args - Arguments to delete one TanamanPengguna.
     * @example
     * // Delete one TanamanPengguna
     * const TanamanPengguna = await prisma.tanamanPengguna.delete({
     *   where: {
     *     // ... filter to delete one TanamanPengguna
     *   }
     * })
     * 
     */
    delete<T extends TanamanPenggunaDeleteArgs>(args: SelectSubset<T, TanamanPenggunaDeleteArgs<ExtArgs>>): Prisma__TanamanPenggunaClient<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TanamanPengguna.
     * @param {TanamanPenggunaUpdateArgs} args - Arguments to update one TanamanPengguna.
     * @example
     * // Update one TanamanPengguna
     * const tanamanPengguna = await prisma.tanamanPengguna.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TanamanPenggunaUpdateArgs>(args: SelectSubset<T, TanamanPenggunaUpdateArgs<ExtArgs>>): Prisma__TanamanPenggunaClient<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TanamanPenggunas.
     * @param {TanamanPenggunaDeleteManyArgs} args - Arguments to filter TanamanPenggunas to delete.
     * @example
     * // Delete a few TanamanPenggunas
     * const { count } = await prisma.tanamanPengguna.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TanamanPenggunaDeleteManyArgs>(args?: SelectSubset<T, TanamanPenggunaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TanamanPenggunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanPenggunaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TanamanPenggunas
     * const tanamanPengguna = await prisma.tanamanPengguna.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TanamanPenggunaUpdateManyArgs>(args: SelectSubset<T, TanamanPenggunaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TanamanPenggunas and returns the data updated in the database.
     * @param {TanamanPenggunaUpdateManyAndReturnArgs} args - Arguments to update many TanamanPenggunas.
     * @example
     * // Update many TanamanPenggunas
     * const tanamanPengguna = await prisma.tanamanPengguna.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TanamanPenggunas and only return the `id_tanaman_pengguna`
     * const tanamanPenggunaWithId_tanaman_penggunaOnly = await prisma.tanamanPengguna.updateManyAndReturn({
     *   select: { id_tanaman_pengguna: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TanamanPenggunaUpdateManyAndReturnArgs>(args: SelectSubset<T, TanamanPenggunaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TanamanPengguna.
     * @param {TanamanPenggunaUpsertArgs} args - Arguments to update or create a TanamanPengguna.
     * @example
     * // Update or create a TanamanPengguna
     * const tanamanPengguna = await prisma.tanamanPengguna.upsert({
     *   create: {
     *     // ... data to create a TanamanPengguna
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TanamanPengguna we want to update
     *   }
     * })
     */
    upsert<T extends TanamanPenggunaUpsertArgs>(args: SelectSubset<T, TanamanPenggunaUpsertArgs<ExtArgs>>): Prisma__TanamanPenggunaClient<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TanamanPenggunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanPenggunaCountArgs} args - Arguments to filter TanamanPenggunas to count.
     * @example
     * // Count the number of TanamanPenggunas
     * const count = await prisma.tanamanPengguna.count({
     *   where: {
     *     // ... the filter for the TanamanPenggunas we want to count
     *   }
     * })
    **/
    count<T extends TanamanPenggunaCountArgs>(
      args?: Subset<T, TanamanPenggunaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TanamanPenggunaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TanamanPengguna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanPenggunaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TanamanPenggunaAggregateArgs>(args: Subset<T, TanamanPenggunaAggregateArgs>): Prisma.PrismaPromise<GetTanamanPenggunaAggregateType<T>>

    /**
     * Group by TanamanPengguna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TanamanPenggunaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TanamanPenggunaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TanamanPenggunaGroupByArgs['orderBy'] }
        : { orderBy?: TanamanPenggunaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TanamanPenggunaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTanamanPenggunaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TanamanPengguna model
   */
  readonly fields: TanamanPenggunaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TanamanPengguna.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TanamanPenggunaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tanaman<T extends TanamanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TanamanDefaultArgs<ExtArgs>>): Prisma__TanamanClient<$Result.GetResult<Prisma.$TanamanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pengguna<T extends PenggunaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PenggunaDefaultArgs<ExtArgs>>): Prisma__PenggunaClient<$Result.GetResult<Prisma.$PenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hari_tanaman<T extends TanamanPengguna$hari_tanamanArgs<ExtArgs> = {}>(args?: Subset<T, TanamanPengguna$hari_tanamanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TanamanPengguna model
   */
  interface TanamanPenggunaFieldRefs {
    readonly id_tanaman_pengguna: FieldRef<"TanamanPengguna", 'String'>
    readonly tanggal_penanaman: FieldRef<"TanamanPengguna", 'DateTime'>
    readonly status_penanaman: FieldRef<"TanamanPengguna", 'Boolean'>
    readonly nama_tanaman: FieldRef<"TanamanPengguna", 'String'>
    readonly id_tanaman: FieldRef<"TanamanPengguna", 'String'>
    readonly id_pengguna: FieldRef<"TanamanPengguna", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TanamanPengguna findUnique
   */
  export type TanamanPenggunaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TanamanPengguna to fetch.
     */
    where: TanamanPenggunaWhereUniqueInput
  }

  /**
   * TanamanPengguna findUniqueOrThrow
   */
  export type TanamanPenggunaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TanamanPengguna to fetch.
     */
    where: TanamanPenggunaWhereUniqueInput
  }

  /**
   * TanamanPengguna findFirst
   */
  export type TanamanPenggunaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TanamanPengguna to fetch.
     */
    where?: TanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TanamanPenggunas to fetch.
     */
    orderBy?: TanamanPenggunaOrderByWithRelationInput | TanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TanamanPenggunas.
     */
    cursor?: TanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TanamanPenggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TanamanPenggunas.
     */
    distinct?: TanamanPenggunaScalarFieldEnum | TanamanPenggunaScalarFieldEnum[]
  }

  /**
   * TanamanPengguna findFirstOrThrow
   */
  export type TanamanPenggunaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TanamanPengguna to fetch.
     */
    where?: TanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TanamanPenggunas to fetch.
     */
    orderBy?: TanamanPenggunaOrderByWithRelationInput | TanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TanamanPenggunas.
     */
    cursor?: TanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TanamanPenggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TanamanPenggunas.
     */
    distinct?: TanamanPenggunaScalarFieldEnum | TanamanPenggunaScalarFieldEnum[]
  }

  /**
   * TanamanPengguna findMany
   */
  export type TanamanPenggunaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TanamanPenggunas to fetch.
     */
    where?: TanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TanamanPenggunas to fetch.
     */
    orderBy?: TanamanPenggunaOrderByWithRelationInput | TanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TanamanPenggunas.
     */
    cursor?: TanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TanamanPenggunas.
     */
    skip?: number
    distinct?: TanamanPenggunaScalarFieldEnum | TanamanPenggunaScalarFieldEnum[]
  }

  /**
   * TanamanPengguna create
   */
  export type TanamanPenggunaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    /**
     * The data needed to create a TanamanPengguna.
     */
    data: XOR<TanamanPenggunaCreateInput, TanamanPenggunaUncheckedCreateInput>
  }

  /**
   * TanamanPengguna createMany
   */
  export type TanamanPenggunaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TanamanPenggunas.
     */
    data: TanamanPenggunaCreateManyInput | TanamanPenggunaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TanamanPengguna createManyAndReturn
   */
  export type TanamanPenggunaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * The data used to create many TanamanPenggunas.
     */
    data: TanamanPenggunaCreateManyInput | TanamanPenggunaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TanamanPengguna update
   */
  export type TanamanPenggunaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    /**
     * The data needed to update a TanamanPengguna.
     */
    data: XOR<TanamanPenggunaUpdateInput, TanamanPenggunaUncheckedUpdateInput>
    /**
     * Choose, which TanamanPengguna to update.
     */
    where: TanamanPenggunaWhereUniqueInput
  }

  /**
   * TanamanPengguna updateMany
   */
  export type TanamanPenggunaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TanamanPenggunas.
     */
    data: XOR<TanamanPenggunaUpdateManyMutationInput, TanamanPenggunaUncheckedUpdateManyInput>
    /**
     * Filter which TanamanPenggunas to update
     */
    where?: TanamanPenggunaWhereInput
    /**
     * Limit how many TanamanPenggunas to update.
     */
    limit?: number
  }

  /**
   * TanamanPengguna updateManyAndReturn
   */
  export type TanamanPenggunaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * The data used to update TanamanPenggunas.
     */
    data: XOR<TanamanPenggunaUpdateManyMutationInput, TanamanPenggunaUncheckedUpdateManyInput>
    /**
     * Filter which TanamanPenggunas to update
     */
    where?: TanamanPenggunaWhereInput
    /**
     * Limit how many TanamanPenggunas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TanamanPengguna upsert
   */
  export type TanamanPenggunaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    /**
     * The filter to search for the TanamanPengguna to update in case it exists.
     */
    where: TanamanPenggunaWhereUniqueInput
    /**
     * In case the TanamanPengguna found by the `where` argument doesn't exist, create a new TanamanPengguna with this data.
     */
    create: XOR<TanamanPenggunaCreateInput, TanamanPenggunaUncheckedCreateInput>
    /**
     * In case the TanamanPengguna was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TanamanPenggunaUpdateInput, TanamanPenggunaUncheckedUpdateInput>
  }

  /**
   * TanamanPengguna delete
   */
  export type TanamanPenggunaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter which TanamanPengguna to delete.
     */
    where: TanamanPenggunaWhereUniqueInput
  }

  /**
   * TanamanPengguna deleteMany
   */
  export type TanamanPenggunaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TanamanPenggunas to delete
     */
    where?: TanamanPenggunaWhereInput
    /**
     * Limit how many TanamanPenggunas to delete.
     */
    limit?: number
  }

  /**
   * TanamanPengguna.hari_tanaman
   */
  export type TanamanPengguna$hari_tanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    where?: HariTanamanPenggunaWhereInput
    orderBy?: HariTanamanPenggunaOrderByWithRelationInput | HariTanamanPenggunaOrderByWithRelationInput[]
    cursor?: HariTanamanPenggunaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HariTanamanPenggunaScalarFieldEnum | HariTanamanPenggunaScalarFieldEnum[]
  }

  /**
   * TanamanPengguna without action
   */
  export type TanamanPenggunaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TanamanPengguna
     */
    select?: TanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TanamanPengguna
     */
    omit?: TanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TanamanPenggunaInclude<ExtArgs> | null
  }


  /**
   * Model HariTanamanPengguna
   */

  export type AggregateHariTanamanPengguna = {
    _count: HariTanamanPenggunaCountAggregateOutputType | null
    _avg: HariTanamanPenggunaAvgAggregateOutputType | null
    _sum: HariTanamanPenggunaSumAggregateOutputType | null
    _min: HariTanamanPenggunaMinAggregateOutputType | null
    _max: HariTanamanPenggunaMaxAggregateOutputType | null
  }

  export type HariTanamanPenggunaAvgAggregateOutputType = {
    id_hari_tanaman_pengguna: number | null
  }

  export type HariTanamanPenggunaSumAggregateOutputType = {
    id_hari_tanaman_pengguna: number | null
  }

  export type HariTanamanPenggunaMinAggregateOutputType = {
    id_hari_tanaman_pengguna: number | null
    catatan: string | null
    id_tanaman_pengguna: string | null
  }

  export type HariTanamanPenggunaMaxAggregateOutputType = {
    id_hari_tanaman_pengguna: number | null
    catatan: string | null
    id_tanaman_pengguna: string | null
  }

  export type HariTanamanPenggunaCountAggregateOutputType = {
    id_hari_tanaman_pengguna: number
    catatan: number
    id_tanaman_pengguna: number
    _all: number
  }


  export type HariTanamanPenggunaAvgAggregateInputType = {
    id_hari_tanaman_pengguna?: true
  }

  export type HariTanamanPenggunaSumAggregateInputType = {
    id_hari_tanaman_pengguna?: true
  }

  export type HariTanamanPenggunaMinAggregateInputType = {
    id_hari_tanaman_pengguna?: true
    catatan?: true
    id_tanaman_pengguna?: true
  }

  export type HariTanamanPenggunaMaxAggregateInputType = {
    id_hari_tanaman_pengguna?: true
    catatan?: true
    id_tanaman_pengguna?: true
  }

  export type HariTanamanPenggunaCountAggregateInputType = {
    id_hari_tanaman_pengguna?: true
    catatan?: true
    id_tanaman_pengguna?: true
    _all?: true
  }

  export type HariTanamanPenggunaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HariTanamanPengguna to aggregate.
     */
    where?: HariTanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HariTanamanPenggunas to fetch.
     */
    orderBy?: HariTanamanPenggunaOrderByWithRelationInput | HariTanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HariTanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HariTanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HariTanamanPenggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HariTanamanPenggunas
    **/
    _count?: true | HariTanamanPenggunaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HariTanamanPenggunaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HariTanamanPenggunaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HariTanamanPenggunaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HariTanamanPenggunaMaxAggregateInputType
  }

  export type GetHariTanamanPenggunaAggregateType<T extends HariTanamanPenggunaAggregateArgs> = {
        [P in keyof T & keyof AggregateHariTanamanPengguna]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHariTanamanPengguna[P]>
      : GetScalarType<T[P], AggregateHariTanamanPengguna[P]>
  }




  export type HariTanamanPenggunaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HariTanamanPenggunaWhereInput
    orderBy?: HariTanamanPenggunaOrderByWithAggregationInput | HariTanamanPenggunaOrderByWithAggregationInput[]
    by: HariTanamanPenggunaScalarFieldEnum[] | HariTanamanPenggunaScalarFieldEnum
    having?: HariTanamanPenggunaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HariTanamanPenggunaCountAggregateInputType | true
    _avg?: HariTanamanPenggunaAvgAggregateInputType
    _sum?: HariTanamanPenggunaSumAggregateInputType
    _min?: HariTanamanPenggunaMinAggregateInputType
    _max?: HariTanamanPenggunaMaxAggregateInputType
  }

  export type HariTanamanPenggunaGroupByOutputType = {
    id_hari_tanaman_pengguna: number
    catatan: string
    id_tanaman_pengguna: string
    _count: HariTanamanPenggunaCountAggregateOutputType | null
    _avg: HariTanamanPenggunaAvgAggregateOutputType | null
    _sum: HariTanamanPenggunaSumAggregateOutputType | null
    _min: HariTanamanPenggunaMinAggregateOutputType | null
    _max: HariTanamanPenggunaMaxAggregateOutputType | null
  }

  type GetHariTanamanPenggunaGroupByPayload<T extends HariTanamanPenggunaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HariTanamanPenggunaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HariTanamanPenggunaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HariTanamanPenggunaGroupByOutputType[P]>
            : GetScalarType<T[P], HariTanamanPenggunaGroupByOutputType[P]>
        }
      >
    >


  export type HariTanamanPenggunaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hari_tanaman_pengguna?: boolean
    catatan?: boolean
    id_tanaman_pengguna?: boolean
    tugas_penanaman?: boolean | HariTanamanPengguna$tugas_penanamanArgs<ExtArgs>
    tanaman_pengguna?: boolean | TanamanPenggunaDefaultArgs<ExtArgs>
    _count?: boolean | HariTanamanPenggunaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hariTanamanPengguna"]>

  export type HariTanamanPenggunaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hari_tanaman_pengguna?: boolean
    catatan?: boolean
    id_tanaman_pengguna?: boolean
    tanaman_pengguna?: boolean | TanamanPenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hariTanamanPengguna"]>

  export type HariTanamanPenggunaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_hari_tanaman_pengguna?: boolean
    catatan?: boolean
    id_tanaman_pengguna?: boolean
    tanaman_pengguna?: boolean | TanamanPenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hariTanamanPengguna"]>

  export type HariTanamanPenggunaSelectScalar = {
    id_hari_tanaman_pengguna?: boolean
    catatan?: boolean
    id_tanaman_pengguna?: boolean
  }

  export type HariTanamanPenggunaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_hari_tanaman_pengguna" | "catatan" | "id_tanaman_pengguna", ExtArgs["result"]["hariTanamanPengguna"]>
  export type HariTanamanPenggunaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tugas_penanaman?: boolean | HariTanamanPengguna$tugas_penanamanArgs<ExtArgs>
    tanaman_pengguna?: boolean | TanamanPenggunaDefaultArgs<ExtArgs>
    _count?: boolean | HariTanamanPenggunaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HariTanamanPenggunaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman_pengguna?: boolean | TanamanPenggunaDefaultArgs<ExtArgs>
  }
  export type HariTanamanPenggunaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tanaman_pengguna?: boolean | TanamanPenggunaDefaultArgs<ExtArgs>
  }

  export type $HariTanamanPenggunaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HariTanamanPengguna"
    objects: {
      tugas_penanaman: Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>[]
      tanaman_pengguna: Prisma.$TanamanPenggunaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_hari_tanaman_pengguna: number
      catatan: string
      id_tanaman_pengguna: string
    }, ExtArgs["result"]["hariTanamanPengguna"]>
    composites: {}
  }

  type HariTanamanPenggunaGetPayload<S extends boolean | null | undefined | HariTanamanPenggunaDefaultArgs> = $Result.GetResult<Prisma.$HariTanamanPenggunaPayload, S>

  type HariTanamanPenggunaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HariTanamanPenggunaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HariTanamanPenggunaCountAggregateInputType | true
    }

  export interface HariTanamanPenggunaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HariTanamanPengguna'], meta: { name: 'HariTanamanPengguna' } }
    /**
     * Find zero or one HariTanamanPengguna that matches the filter.
     * @param {HariTanamanPenggunaFindUniqueArgs} args - Arguments to find a HariTanamanPengguna
     * @example
     * // Get one HariTanamanPengguna
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HariTanamanPenggunaFindUniqueArgs>(args: SelectSubset<T, HariTanamanPenggunaFindUniqueArgs<ExtArgs>>): Prisma__HariTanamanPenggunaClient<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HariTanamanPengguna that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HariTanamanPenggunaFindUniqueOrThrowArgs} args - Arguments to find a HariTanamanPengguna
     * @example
     * // Get one HariTanamanPengguna
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HariTanamanPenggunaFindUniqueOrThrowArgs>(args: SelectSubset<T, HariTanamanPenggunaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HariTanamanPenggunaClient<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HariTanamanPengguna that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariTanamanPenggunaFindFirstArgs} args - Arguments to find a HariTanamanPengguna
     * @example
     * // Get one HariTanamanPengguna
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HariTanamanPenggunaFindFirstArgs>(args?: SelectSubset<T, HariTanamanPenggunaFindFirstArgs<ExtArgs>>): Prisma__HariTanamanPenggunaClient<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HariTanamanPengguna that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariTanamanPenggunaFindFirstOrThrowArgs} args - Arguments to find a HariTanamanPengguna
     * @example
     * // Get one HariTanamanPengguna
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HariTanamanPenggunaFindFirstOrThrowArgs>(args?: SelectSubset<T, HariTanamanPenggunaFindFirstOrThrowArgs<ExtArgs>>): Prisma__HariTanamanPenggunaClient<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HariTanamanPenggunas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariTanamanPenggunaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HariTanamanPenggunas
     * const hariTanamanPenggunas = await prisma.hariTanamanPengguna.findMany()
     * 
     * // Get first 10 HariTanamanPenggunas
     * const hariTanamanPenggunas = await prisma.hariTanamanPengguna.findMany({ take: 10 })
     * 
     * // Only select the `id_hari_tanaman_pengguna`
     * const hariTanamanPenggunaWithId_hari_tanaman_penggunaOnly = await prisma.hariTanamanPengguna.findMany({ select: { id_hari_tanaman_pengguna: true } })
     * 
     */
    findMany<T extends HariTanamanPenggunaFindManyArgs>(args?: SelectSubset<T, HariTanamanPenggunaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HariTanamanPengguna.
     * @param {HariTanamanPenggunaCreateArgs} args - Arguments to create a HariTanamanPengguna.
     * @example
     * // Create one HariTanamanPengguna
     * const HariTanamanPengguna = await prisma.hariTanamanPengguna.create({
     *   data: {
     *     // ... data to create a HariTanamanPengguna
     *   }
     * })
     * 
     */
    create<T extends HariTanamanPenggunaCreateArgs>(args: SelectSubset<T, HariTanamanPenggunaCreateArgs<ExtArgs>>): Prisma__HariTanamanPenggunaClient<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HariTanamanPenggunas.
     * @param {HariTanamanPenggunaCreateManyArgs} args - Arguments to create many HariTanamanPenggunas.
     * @example
     * // Create many HariTanamanPenggunas
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HariTanamanPenggunaCreateManyArgs>(args?: SelectSubset<T, HariTanamanPenggunaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HariTanamanPenggunas and returns the data saved in the database.
     * @param {HariTanamanPenggunaCreateManyAndReturnArgs} args - Arguments to create many HariTanamanPenggunas.
     * @example
     * // Create many HariTanamanPenggunas
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HariTanamanPenggunas and only return the `id_hari_tanaman_pengguna`
     * const hariTanamanPenggunaWithId_hari_tanaman_penggunaOnly = await prisma.hariTanamanPengguna.createManyAndReturn({
     *   select: { id_hari_tanaman_pengguna: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HariTanamanPenggunaCreateManyAndReturnArgs>(args?: SelectSubset<T, HariTanamanPenggunaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HariTanamanPengguna.
     * @param {HariTanamanPenggunaDeleteArgs} args - Arguments to delete one HariTanamanPengguna.
     * @example
     * // Delete one HariTanamanPengguna
     * const HariTanamanPengguna = await prisma.hariTanamanPengguna.delete({
     *   where: {
     *     // ... filter to delete one HariTanamanPengguna
     *   }
     * })
     * 
     */
    delete<T extends HariTanamanPenggunaDeleteArgs>(args: SelectSubset<T, HariTanamanPenggunaDeleteArgs<ExtArgs>>): Prisma__HariTanamanPenggunaClient<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HariTanamanPengguna.
     * @param {HariTanamanPenggunaUpdateArgs} args - Arguments to update one HariTanamanPengguna.
     * @example
     * // Update one HariTanamanPengguna
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HariTanamanPenggunaUpdateArgs>(args: SelectSubset<T, HariTanamanPenggunaUpdateArgs<ExtArgs>>): Prisma__HariTanamanPenggunaClient<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HariTanamanPenggunas.
     * @param {HariTanamanPenggunaDeleteManyArgs} args - Arguments to filter HariTanamanPenggunas to delete.
     * @example
     * // Delete a few HariTanamanPenggunas
     * const { count } = await prisma.hariTanamanPengguna.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HariTanamanPenggunaDeleteManyArgs>(args?: SelectSubset<T, HariTanamanPenggunaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HariTanamanPenggunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariTanamanPenggunaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HariTanamanPenggunas
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HariTanamanPenggunaUpdateManyArgs>(args: SelectSubset<T, HariTanamanPenggunaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HariTanamanPenggunas and returns the data updated in the database.
     * @param {HariTanamanPenggunaUpdateManyAndReturnArgs} args - Arguments to update many HariTanamanPenggunas.
     * @example
     * // Update many HariTanamanPenggunas
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HariTanamanPenggunas and only return the `id_hari_tanaman_pengguna`
     * const hariTanamanPenggunaWithId_hari_tanaman_penggunaOnly = await prisma.hariTanamanPengguna.updateManyAndReturn({
     *   select: { id_hari_tanaman_pengguna: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HariTanamanPenggunaUpdateManyAndReturnArgs>(args: SelectSubset<T, HariTanamanPenggunaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HariTanamanPengguna.
     * @param {HariTanamanPenggunaUpsertArgs} args - Arguments to update or create a HariTanamanPengguna.
     * @example
     * // Update or create a HariTanamanPengguna
     * const hariTanamanPengguna = await prisma.hariTanamanPengguna.upsert({
     *   create: {
     *     // ... data to create a HariTanamanPengguna
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HariTanamanPengguna we want to update
     *   }
     * })
     */
    upsert<T extends HariTanamanPenggunaUpsertArgs>(args: SelectSubset<T, HariTanamanPenggunaUpsertArgs<ExtArgs>>): Prisma__HariTanamanPenggunaClient<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HariTanamanPenggunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariTanamanPenggunaCountArgs} args - Arguments to filter HariTanamanPenggunas to count.
     * @example
     * // Count the number of HariTanamanPenggunas
     * const count = await prisma.hariTanamanPengguna.count({
     *   where: {
     *     // ... the filter for the HariTanamanPenggunas we want to count
     *   }
     * })
    **/
    count<T extends HariTanamanPenggunaCountArgs>(
      args?: Subset<T, HariTanamanPenggunaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HariTanamanPenggunaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HariTanamanPengguna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariTanamanPenggunaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HariTanamanPenggunaAggregateArgs>(args: Subset<T, HariTanamanPenggunaAggregateArgs>): Prisma.PrismaPromise<GetHariTanamanPenggunaAggregateType<T>>

    /**
     * Group by HariTanamanPengguna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HariTanamanPenggunaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HariTanamanPenggunaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HariTanamanPenggunaGroupByArgs['orderBy'] }
        : { orderBy?: HariTanamanPenggunaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HariTanamanPenggunaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHariTanamanPenggunaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HariTanamanPengguna model
   */
  readonly fields: HariTanamanPenggunaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HariTanamanPengguna.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HariTanamanPenggunaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tugas_penanaman<T extends HariTanamanPengguna$tugas_penanamanArgs<ExtArgs> = {}>(args?: Subset<T, HariTanamanPengguna$tugas_penanamanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tanaman_pengguna<T extends TanamanPenggunaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TanamanPenggunaDefaultArgs<ExtArgs>>): Prisma__TanamanPenggunaClient<$Result.GetResult<Prisma.$TanamanPenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HariTanamanPengguna model
   */
  interface HariTanamanPenggunaFieldRefs {
    readonly id_hari_tanaman_pengguna: FieldRef<"HariTanamanPengguna", 'Int'>
    readonly catatan: FieldRef<"HariTanamanPengguna", 'String'>
    readonly id_tanaman_pengguna: FieldRef<"HariTanamanPengguna", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HariTanamanPengguna findUnique
   */
  export type HariTanamanPenggunaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which HariTanamanPengguna to fetch.
     */
    where: HariTanamanPenggunaWhereUniqueInput
  }

  /**
   * HariTanamanPengguna findUniqueOrThrow
   */
  export type HariTanamanPenggunaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which HariTanamanPengguna to fetch.
     */
    where: HariTanamanPenggunaWhereUniqueInput
  }

  /**
   * HariTanamanPengguna findFirst
   */
  export type HariTanamanPenggunaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which HariTanamanPengguna to fetch.
     */
    where?: HariTanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HariTanamanPenggunas to fetch.
     */
    orderBy?: HariTanamanPenggunaOrderByWithRelationInput | HariTanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HariTanamanPenggunas.
     */
    cursor?: HariTanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HariTanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HariTanamanPenggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HariTanamanPenggunas.
     */
    distinct?: HariTanamanPenggunaScalarFieldEnum | HariTanamanPenggunaScalarFieldEnum[]
  }

  /**
   * HariTanamanPengguna findFirstOrThrow
   */
  export type HariTanamanPenggunaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which HariTanamanPengguna to fetch.
     */
    where?: HariTanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HariTanamanPenggunas to fetch.
     */
    orderBy?: HariTanamanPenggunaOrderByWithRelationInput | HariTanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HariTanamanPenggunas.
     */
    cursor?: HariTanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HariTanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HariTanamanPenggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HariTanamanPenggunas.
     */
    distinct?: HariTanamanPenggunaScalarFieldEnum | HariTanamanPenggunaScalarFieldEnum[]
  }

  /**
   * HariTanamanPengguna findMany
   */
  export type HariTanamanPenggunaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which HariTanamanPenggunas to fetch.
     */
    where?: HariTanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HariTanamanPenggunas to fetch.
     */
    orderBy?: HariTanamanPenggunaOrderByWithRelationInput | HariTanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HariTanamanPenggunas.
     */
    cursor?: HariTanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HariTanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HariTanamanPenggunas.
     */
    skip?: number
    distinct?: HariTanamanPenggunaScalarFieldEnum | HariTanamanPenggunaScalarFieldEnum[]
  }

  /**
   * HariTanamanPengguna create
   */
  export type HariTanamanPenggunaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    /**
     * The data needed to create a HariTanamanPengguna.
     */
    data: XOR<HariTanamanPenggunaCreateInput, HariTanamanPenggunaUncheckedCreateInput>
  }

  /**
   * HariTanamanPengguna createMany
   */
  export type HariTanamanPenggunaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HariTanamanPenggunas.
     */
    data: HariTanamanPenggunaCreateManyInput | HariTanamanPenggunaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HariTanamanPengguna createManyAndReturn
   */
  export type HariTanamanPenggunaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * The data used to create many HariTanamanPenggunas.
     */
    data: HariTanamanPenggunaCreateManyInput | HariTanamanPenggunaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HariTanamanPengguna update
   */
  export type HariTanamanPenggunaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    /**
     * The data needed to update a HariTanamanPengguna.
     */
    data: XOR<HariTanamanPenggunaUpdateInput, HariTanamanPenggunaUncheckedUpdateInput>
    /**
     * Choose, which HariTanamanPengguna to update.
     */
    where: HariTanamanPenggunaWhereUniqueInput
  }

  /**
   * HariTanamanPengguna updateMany
   */
  export type HariTanamanPenggunaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HariTanamanPenggunas.
     */
    data: XOR<HariTanamanPenggunaUpdateManyMutationInput, HariTanamanPenggunaUncheckedUpdateManyInput>
    /**
     * Filter which HariTanamanPenggunas to update
     */
    where?: HariTanamanPenggunaWhereInput
    /**
     * Limit how many HariTanamanPenggunas to update.
     */
    limit?: number
  }

  /**
   * HariTanamanPengguna updateManyAndReturn
   */
  export type HariTanamanPenggunaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * The data used to update HariTanamanPenggunas.
     */
    data: XOR<HariTanamanPenggunaUpdateManyMutationInput, HariTanamanPenggunaUncheckedUpdateManyInput>
    /**
     * Filter which HariTanamanPenggunas to update
     */
    where?: HariTanamanPenggunaWhereInput
    /**
     * Limit how many HariTanamanPenggunas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HariTanamanPengguna upsert
   */
  export type HariTanamanPenggunaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    /**
     * The filter to search for the HariTanamanPengguna to update in case it exists.
     */
    where: HariTanamanPenggunaWhereUniqueInput
    /**
     * In case the HariTanamanPengguna found by the `where` argument doesn't exist, create a new HariTanamanPengguna with this data.
     */
    create: XOR<HariTanamanPenggunaCreateInput, HariTanamanPenggunaUncheckedCreateInput>
    /**
     * In case the HariTanamanPengguna was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HariTanamanPenggunaUpdateInput, HariTanamanPenggunaUncheckedUpdateInput>
  }

  /**
   * HariTanamanPengguna delete
   */
  export type HariTanamanPenggunaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter which HariTanamanPengguna to delete.
     */
    where: HariTanamanPenggunaWhereUniqueInput
  }

  /**
   * HariTanamanPengguna deleteMany
   */
  export type HariTanamanPenggunaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HariTanamanPenggunas to delete
     */
    where?: HariTanamanPenggunaWhereInput
    /**
     * Limit how many HariTanamanPenggunas to delete.
     */
    limit?: number
  }

  /**
   * HariTanamanPengguna.tugas_penanaman
   */
  export type HariTanamanPengguna$tugas_penanamanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    where?: TugasPenanamanPenggunaWhereInput
    orderBy?: TugasPenanamanPenggunaOrderByWithRelationInput | TugasPenanamanPenggunaOrderByWithRelationInput[]
    cursor?: TugasPenanamanPenggunaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TugasPenanamanPenggunaScalarFieldEnum | TugasPenanamanPenggunaScalarFieldEnum[]
  }

  /**
   * HariTanamanPengguna without action
   */
  export type HariTanamanPenggunaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HariTanamanPengguna
     */
    select?: HariTanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HariTanamanPengguna
     */
    omit?: HariTanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HariTanamanPenggunaInclude<ExtArgs> | null
  }


  /**
   * Model TugasPenanamanPengguna
   */

  export type AggregateTugasPenanamanPengguna = {
    _count: TugasPenanamanPenggunaCountAggregateOutputType | null
    _avg: TugasPenanamanPenggunaAvgAggregateOutputType | null
    _sum: TugasPenanamanPenggunaSumAggregateOutputType | null
    _min: TugasPenanamanPenggunaMinAggregateOutputType | null
    _max: TugasPenanamanPenggunaMaxAggregateOutputType | null
  }

  export type TugasPenanamanPenggunaAvgAggregateOutputType = {
    id_tugas_penanaman_pengguna: number | null
    id_hari_tanaman_pengguna: number | null
  }

  export type TugasPenanamanPenggunaSumAggregateOutputType = {
    id_tugas_penanaman_pengguna: number | null
    id_hari_tanaman_pengguna: number | null
  }

  export type TugasPenanamanPenggunaMinAggregateOutputType = {
    id_tugas_penanaman_pengguna: number | null
    nama_tugas: string | null
    id_hari_tanaman_pengguna: number | null
  }

  export type TugasPenanamanPenggunaMaxAggregateOutputType = {
    id_tugas_penanaman_pengguna: number | null
    nama_tugas: string | null
    id_hari_tanaman_pengguna: number | null
  }

  export type TugasPenanamanPenggunaCountAggregateOutputType = {
    id_tugas_penanaman_pengguna: number
    nama_tugas: number
    id_hari_tanaman_pengguna: number
    _all: number
  }


  export type TugasPenanamanPenggunaAvgAggregateInputType = {
    id_tugas_penanaman_pengguna?: true
    id_hari_tanaman_pengguna?: true
  }

  export type TugasPenanamanPenggunaSumAggregateInputType = {
    id_tugas_penanaman_pengguna?: true
    id_hari_tanaman_pengguna?: true
  }

  export type TugasPenanamanPenggunaMinAggregateInputType = {
    id_tugas_penanaman_pengguna?: true
    nama_tugas?: true
    id_hari_tanaman_pengguna?: true
  }

  export type TugasPenanamanPenggunaMaxAggregateInputType = {
    id_tugas_penanaman_pengguna?: true
    nama_tugas?: true
    id_hari_tanaman_pengguna?: true
  }

  export type TugasPenanamanPenggunaCountAggregateInputType = {
    id_tugas_penanaman_pengguna?: true
    nama_tugas?: true
    id_hari_tanaman_pengguna?: true
    _all?: true
  }

  export type TugasPenanamanPenggunaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TugasPenanamanPengguna to aggregate.
     */
    where?: TugasPenanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TugasPenanamanPenggunas to fetch.
     */
    orderBy?: TugasPenanamanPenggunaOrderByWithRelationInput | TugasPenanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TugasPenanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TugasPenanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TugasPenanamanPenggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TugasPenanamanPenggunas
    **/
    _count?: true | TugasPenanamanPenggunaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TugasPenanamanPenggunaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TugasPenanamanPenggunaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TugasPenanamanPenggunaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TugasPenanamanPenggunaMaxAggregateInputType
  }

  export type GetTugasPenanamanPenggunaAggregateType<T extends TugasPenanamanPenggunaAggregateArgs> = {
        [P in keyof T & keyof AggregateTugasPenanamanPengguna]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTugasPenanamanPengguna[P]>
      : GetScalarType<T[P], AggregateTugasPenanamanPengguna[P]>
  }




  export type TugasPenanamanPenggunaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TugasPenanamanPenggunaWhereInput
    orderBy?: TugasPenanamanPenggunaOrderByWithAggregationInput | TugasPenanamanPenggunaOrderByWithAggregationInput[]
    by: TugasPenanamanPenggunaScalarFieldEnum[] | TugasPenanamanPenggunaScalarFieldEnum
    having?: TugasPenanamanPenggunaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TugasPenanamanPenggunaCountAggregateInputType | true
    _avg?: TugasPenanamanPenggunaAvgAggregateInputType
    _sum?: TugasPenanamanPenggunaSumAggregateInputType
    _min?: TugasPenanamanPenggunaMinAggregateInputType
    _max?: TugasPenanamanPenggunaMaxAggregateInputType
  }

  export type TugasPenanamanPenggunaGroupByOutputType = {
    id_tugas_penanaman_pengguna: number
    nama_tugas: string
    id_hari_tanaman_pengguna: number
    _count: TugasPenanamanPenggunaCountAggregateOutputType | null
    _avg: TugasPenanamanPenggunaAvgAggregateOutputType | null
    _sum: TugasPenanamanPenggunaSumAggregateOutputType | null
    _min: TugasPenanamanPenggunaMinAggregateOutputType | null
    _max: TugasPenanamanPenggunaMaxAggregateOutputType | null
  }

  type GetTugasPenanamanPenggunaGroupByPayload<T extends TugasPenanamanPenggunaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TugasPenanamanPenggunaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TugasPenanamanPenggunaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TugasPenanamanPenggunaGroupByOutputType[P]>
            : GetScalarType<T[P], TugasPenanamanPenggunaGroupByOutputType[P]>
        }
      >
    >


  export type TugasPenanamanPenggunaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tugas_penanaman_pengguna?: boolean
    nama_tugas?: boolean
    id_hari_tanaman_pengguna?: boolean
    hari_tanaman?: boolean | HariTanamanPenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tugasPenanamanPengguna"]>

  export type TugasPenanamanPenggunaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tugas_penanaman_pengguna?: boolean
    nama_tugas?: boolean
    id_hari_tanaman_pengguna?: boolean
    hari_tanaman?: boolean | HariTanamanPenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tugasPenanamanPengguna"]>

  export type TugasPenanamanPenggunaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_tugas_penanaman_pengguna?: boolean
    nama_tugas?: boolean
    id_hari_tanaman_pengguna?: boolean
    hari_tanaman?: boolean | HariTanamanPenggunaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tugasPenanamanPengguna"]>

  export type TugasPenanamanPenggunaSelectScalar = {
    id_tugas_penanaman_pengguna?: boolean
    nama_tugas?: boolean
    id_hari_tanaman_pengguna?: boolean
  }

  export type TugasPenanamanPenggunaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id_tugas_penanaman_pengguna" | "nama_tugas" | "id_hari_tanaman_pengguna", ExtArgs["result"]["tugasPenanamanPengguna"]>
  export type TugasPenanamanPenggunaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hari_tanaman?: boolean | HariTanamanPenggunaDefaultArgs<ExtArgs>
  }
  export type TugasPenanamanPenggunaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hari_tanaman?: boolean | HariTanamanPenggunaDefaultArgs<ExtArgs>
  }
  export type TugasPenanamanPenggunaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hari_tanaman?: boolean | HariTanamanPenggunaDefaultArgs<ExtArgs>
  }

  export type $TugasPenanamanPenggunaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TugasPenanamanPengguna"
    objects: {
      hari_tanaman: Prisma.$HariTanamanPenggunaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_tugas_penanaman_pengguna: number
      nama_tugas: string
      id_hari_tanaman_pengguna: number
    }, ExtArgs["result"]["tugasPenanamanPengguna"]>
    composites: {}
  }

  type TugasPenanamanPenggunaGetPayload<S extends boolean | null | undefined | TugasPenanamanPenggunaDefaultArgs> = $Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload, S>

  type TugasPenanamanPenggunaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TugasPenanamanPenggunaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TugasPenanamanPenggunaCountAggregateInputType | true
    }

  export interface TugasPenanamanPenggunaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TugasPenanamanPengguna'], meta: { name: 'TugasPenanamanPengguna' } }
    /**
     * Find zero or one TugasPenanamanPengguna that matches the filter.
     * @param {TugasPenanamanPenggunaFindUniqueArgs} args - Arguments to find a TugasPenanamanPengguna
     * @example
     * // Get one TugasPenanamanPengguna
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TugasPenanamanPenggunaFindUniqueArgs>(args: SelectSubset<T, TugasPenanamanPenggunaFindUniqueArgs<ExtArgs>>): Prisma__TugasPenanamanPenggunaClient<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TugasPenanamanPengguna that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TugasPenanamanPenggunaFindUniqueOrThrowArgs} args - Arguments to find a TugasPenanamanPengguna
     * @example
     * // Get one TugasPenanamanPengguna
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TugasPenanamanPenggunaFindUniqueOrThrowArgs>(args: SelectSubset<T, TugasPenanamanPenggunaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TugasPenanamanPenggunaClient<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TugasPenanamanPengguna that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanPenggunaFindFirstArgs} args - Arguments to find a TugasPenanamanPengguna
     * @example
     * // Get one TugasPenanamanPengguna
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TugasPenanamanPenggunaFindFirstArgs>(args?: SelectSubset<T, TugasPenanamanPenggunaFindFirstArgs<ExtArgs>>): Prisma__TugasPenanamanPenggunaClient<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TugasPenanamanPengguna that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanPenggunaFindFirstOrThrowArgs} args - Arguments to find a TugasPenanamanPengguna
     * @example
     * // Get one TugasPenanamanPengguna
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TugasPenanamanPenggunaFindFirstOrThrowArgs>(args?: SelectSubset<T, TugasPenanamanPenggunaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TugasPenanamanPenggunaClient<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TugasPenanamanPenggunas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanPenggunaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TugasPenanamanPenggunas
     * const tugasPenanamanPenggunas = await prisma.tugasPenanamanPengguna.findMany()
     * 
     * // Get first 10 TugasPenanamanPenggunas
     * const tugasPenanamanPenggunas = await prisma.tugasPenanamanPengguna.findMany({ take: 10 })
     * 
     * // Only select the `id_tugas_penanaman_pengguna`
     * const tugasPenanamanPenggunaWithId_tugas_penanaman_penggunaOnly = await prisma.tugasPenanamanPengguna.findMany({ select: { id_tugas_penanaman_pengguna: true } })
     * 
     */
    findMany<T extends TugasPenanamanPenggunaFindManyArgs>(args?: SelectSubset<T, TugasPenanamanPenggunaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TugasPenanamanPengguna.
     * @param {TugasPenanamanPenggunaCreateArgs} args - Arguments to create a TugasPenanamanPengguna.
     * @example
     * // Create one TugasPenanamanPengguna
     * const TugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.create({
     *   data: {
     *     // ... data to create a TugasPenanamanPengguna
     *   }
     * })
     * 
     */
    create<T extends TugasPenanamanPenggunaCreateArgs>(args: SelectSubset<T, TugasPenanamanPenggunaCreateArgs<ExtArgs>>): Prisma__TugasPenanamanPenggunaClient<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TugasPenanamanPenggunas.
     * @param {TugasPenanamanPenggunaCreateManyArgs} args - Arguments to create many TugasPenanamanPenggunas.
     * @example
     * // Create many TugasPenanamanPenggunas
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TugasPenanamanPenggunaCreateManyArgs>(args?: SelectSubset<T, TugasPenanamanPenggunaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TugasPenanamanPenggunas and returns the data saved in the database.
     * @param {TugasPenanamanPenggunaCreateManyAndReturnArgs} args - Arguments to create many TugasPenanamanPenggunas.
     * @example
     * // Create many TugasPenanamanPenggunas
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TugasPenanamanPenggunas and only return the `id_tugas_penanaman_pengguna`
     * const tugasPenanamanPenggunaWithId_tugas_penanaman_penggunaOnly = await prisma.tugasPenanamanPengguna.createManyAndReturn({
     *   select: { id_tugas_penanaman_pengguna: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TugasPenanamanPenggunaCreateManyAndReturnArgs>(args?: SelectSubset<T, TugasPenanamanPenggunaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TugasPenanamanPengguna.
     * @param {TugasPenanamanPenggunaDeleteArgs} args - Arguments to delete one TugasPenanamanPengguna.
     * @example
     * // Delete one TugasPenanamanPengguna
     * const TugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.delete({
     *   where: {
     *     // ... filter to delete one TugasPenanamanPengguna
     *   }
     * })
     * 
     */
    delete<T extends TugasPenanamanPenggunaDeleteArgs>(args: SelectSubset<T, TugasPenanamanPenggunaDeleteArgs<ExtArgs>>): Prisma__TugasPenanamanPenggunaClient<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TugasPenanamanPengguna.
     * @param {TugasPenanamanPenggunaUpdateArgs} args - Arguments to update one TugasPenanamanPengguna.
     * @example
     * // Update one TugasPenanamanPengguna
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TugasPenanamanPenggunaUpdateArgs>(args: SelectSubset<T, TugasPenanamanPenggunaUpdateArgs<ExtArgs>>): Prisma__TugasPenanamanPenggunaClient<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TugasPenanamanPenggunas.
     * @param {TugasPenanamanPenggunaDeleteManyArgs} args - Arguments to filter TugasPenanamanPenggunas to delete.
     * @example
     * // Delete a few TugasPenanamanPenggunas
     * const { count } = await prisma.tugasPenanamanPengguna.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TugasPenanamanPenggunaDeleteManyArgs>(args?: SelectSubset<T, TugasPenanamanPenggunaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TugasPenanamanPenggunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanPenggunaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TugasPenanamanPenggunas
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TugasPenanamanPenggunaUpdateManyArgs>(args: SelectSubset<T, TugasPenanamanPenggunaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TugasPenanamanPenggunas and returns the data updated in the database.
     * @param {TugasPenanamanPenggunaUpdateManyAndReturnArgs} args - Arguments to update many TugasPenanamanPenggunas.
     * @example
     * // Update many TugasPenanamanPenggunas
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TugasPenanamanPenggunas and only return the `id_tugas_penanaman_pengguna`
     * const tugasPenanamanPenggunaWithId_tugas_penanaman_penggunaOnly = await prisma.tugasPenanamanPengguna.updateManyAndReturn({
     *   select: { id_tugas_penanaman_pengguna: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TugasPenanamanPenggunaUpdateManyAndReturnArgs>(args: SelectSubset<T, TugasPenanamanPenggunaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TugasPenanamanPengguna.
     * @param {TugasPenanamanPenggunaUpsertArgs} args - Arguments to update or create a TugasPenanamanPengguna.
     * @example
     * // Update or create a TugasPenanamanPengguna
     * const tugasPenanamanPengguna = await prisma.tugasPenanamanPengguna.upsert({
     *   create: {
     *     // ... data to create a TugasPenanamanPengguna
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TugasPenanamanPengguna we want to update
     *   }
     * })
     */
    upsert<T extends TugasPenanamanPenggunaUpsertArgs>(args: SelectSubset<T, TugasPenanamanPenggunaUpsertArgs<ExtArgs>>): Prisma__TugasPenanamanPenggunaClient<$Result.GetResult<Prisma.$TugasPenanamanPenggunaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TugasPenanamanPenggunas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanPenggunaCountArgs} args - Arguments to filter TugasPenanamanPenggunas to count.
     * @example
     * // Count the number of TugasPenanamanPenggunas
     * const count = await prisma.tugasPenanamanPengguna.count({
     *   where: {
     *     // ... the filter for the TugasPenanamanPenggunas we want to count
     *   }
     * })
    **/
    count<T extends TugasPenanamanPenggunaCountArgs>(
      args?: Subset<T, TugasPenanamanPenggunaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TugasPenanamanPenggunaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TugasPenanamanPengguna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanPenggunaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TugasPenanamanPenggunaAggregateArgs>(args: Subset<T, TugasPenanamanPenggunaAggregateArgs>): Prisma.PrismaPromise<GetTugasPenanamanPenggunaAggregateType<T>>

    /**
     * Group by TugasPenanamanPengguna.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasPenanamanPenggunaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TugasPenanamanPenggunaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TugasPenanamanPenggunaGroupByArgs['orderBy'] }
        : { orderBy?: TugasPenanamanPenggunaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TugasPenanamanPenggunaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTugasPenanamanPenggunaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TugasPenanamanPengguna model
   */
  readonly fields: TugasPenanamanPenggunaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TugasPenanamanPengguna.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TugasPenanamanPenggunaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hari_tanaman<T extends HariTanamanPenggunaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HariTanamanPenggunaDefaultArgs<ExtArgs>>): Prisma__HariTanamanPenggunaClient<$Result.GetResult<Prisma.$HariTanamanPenggunaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TugasPenanamanPengguna model
   */
  interface TugasPenanamanPenggunaFieldRefs {
    readonly id_tugas_penanaman_pengguna: FieldRef<"TugasPenanamanPengguna", 'Int'>
    readonly nama_tugas: FieldRef<"TugasPenanamanPengguna", 'String'>
    readonly id_hari_tanaman_pengguna: FieldRef<"TugasPenanamanPengguna", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TugasPenanamanPengguna findUnique
   */
  export type TugasPenanamanPenggunaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanamanPengguna to fetch.
     */
    where: TugasPenanamanPenggunaWhereUniqueInput
  }

  /**
   * TugasPenanamanPengguna findUniqueOrThrow
   */
  export type TugasPenanamanPenggunaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanamanPengguna to fetch.
     */
    where: TugasPenanamanPenggunaWhereUniqueInput
  }

  /**
   * TugasPenanamanPengguna findFirst
   */
  export type TugasPenanamanPenggunaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanamanPengguna to fetch.
     */
    where?: TugasPenanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TugasPenanamanPenggunas to fetch.
     */
    orderBy?: TugasPenanamanPenggunaOrderByWithRelationInput | TugasPenanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TugasPenanamanPenggunas.
     */
    cursor?: TugasPenanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TugasPenanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TugasPenanamanPenggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TugasPenanamanPenggunas.
     */
    distinct?: TugasPenanamanPenggunaScalarFieldEnum | TugasPenanamanPenggunaScalarFieldEnum[]
  }

  /**
   * TugasPenanamanPengguna findFirstOrThrow
   */
  export type TugasPenanamanPenggunaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanamanPengguna to fetch.
     */
    where?: TugasPenanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TugasPenanamanPenggunas to fetch.
     */
    orderBy?: TugasPenanamanPenggunaOrderByWithRelationInput | TugasPenanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TugasPenanamanPenggunas.
     */
    cursor?: TugasPenanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TugasPenanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TugasPenanamanPenggunas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TugasPenanamanPenggunas.
     */
    distinct?: TugasPenanamanPenggunaScalarFieldEnum | TugasPenanamanPenggunaScalarFieldEnum[]
  }

  /**
   * TugasPenanamanPengguna findMany
   */
  export type TugasPenanamanPenggunaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter, which TugasPenanamanPenggunas to fetch.
     */
    where?: TugasPenanamanPenggunaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TugasPenanamanPenggunas to fetch.
     */
    orderBy?: TugasPenanamanPenggunaOrderByWithRelationInput | TugasPenanamanPenggunaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TugasPenanamanPenggunas.
     */
    cursor?: TugasPenanamanPenggunaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TugasPenanamanPenggunas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TugasPenanamanPenggunas.
     */
    skip?: number
    distinct?: TugasPenanamanPenggunaScalarFieldEnum | TugasPenanamanPenggunaScalarFieldEnum[]
  }

  /**
   * TugasPenanamanPengguna create
   */
  export type TugasPenanamanPenggunaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    /**
     * The data needed to create a TugasPenanamanPengguna.
     */
    data: XOR<TugasPenanamanPenggunaCreateInput, TugasPenanamanPenggunaUncheckedCreateInput>
  }

  /**
   * TugasPenanamanPengguna createMany
   */
  export type TugasPenanamanPenggunaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TugasPenanamanPenggunas.
     */
    data: TugasPenanamanPenggunaCreateManyInput | TugasPenanamanPenggunaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TugasPenanamanPengguna createManyAndReturn
   */
  export type TugasPenanamanPenggunaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * The data used to create many TugasPenanamanPenggunas.
     */
    data: TugasPenanamanPenggunaCreateManyInput | TugasPenanamanPenggunaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TugasPenanamanPengguna update
   */
  export type TugasPenanamanPenggunaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    /**
     * The data needed to update a TugasPenanamanPengguna.
     */
    data: XOR<TugasPenanamanPenggunaUpdateInput, TugasPenanamanPenggunaUncheckedUpdateInput>
    /**
     * Choose, which TugasPenanamanPengguna to update.
     */
    where: TugasPenanamanPenggunaWhereUniqueInput
  }

  /**
   * TugasPenanamanPengguna updateMany
   */
  export type TugasPenanamanPenggunaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TugasPenanamanPenggunas.
     */
    data: XOR<TugasPenanamanPenggunaUpdateManyMutationInput, TugasPenanamanPenggunaUncheckedUpdateManyInput>
    /**
     * Filter which TugasPenanamanPenggunas to update
     */
    where?: TugasPenanamanPenggunaWhereInput
    /**
     * Limit how many TugasPenanamanPenggunas to update.
     */
    limit?: number
  }

  /**
   * TugasPenanamanPengguna updateManyAndReturn
   */
  export type TugasPenanamanPenggunaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * The data used to update TugasPenanamanPenggunas.
     */
    data: XOR<TugasPenanamanPenggunaUpdateManyMutationInput, TugasPenanamanPenggunaUncheckedUpdateManyInput>
    /**
     * Filter which TugasPenanamanPenggunas to update
     */
    where?: TugasPenanamanPenggunaWhereInput
    /**
     * Limit how many TugasPenanamanPenggunas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TugasPenanamanPengguna upsert
   */
  export type TugasPenanamanPenggunaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    /**
     * The filter to search for the TugasPenanamanPengguna to update in case it exists.
     */
    where: TugasPenanamanPenggunaWhereUniqueInput
    /**
     * In case the TugasPenanamanPengguna found by the `where` argument doesn't exist, create a new TugasPenanamanPengguna with this data.
     */
    create: XOR<TugasPenanamanPenggunaCreateInput, TugasPenanamanPenggunaUncheckedCreateInput>
    /**
     * In case the TugasPenanamanPengguna was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TugasPenanamanPenggunaUpdateInput, TugasPenanamanPenggunaUncheckedUpdateInput>
  }

  /**
   * TugasPenanamanPengguna delete
   */
  export type TugasPenanamanPenggunaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
    /**
     * Filter which TugasPenanamanPengguna to delete.
     */
    where: TugasPenanamanPenggunaWhereUniqueInput
  }

  /**
   * TugasPenanamanPengguna deleteMany
   */
  export type TugasPenanamanPenggunaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TugasPenanamanPenggunas to delete
     */
    where?: TugasPenanamanPenggunaWhereInput
    /**
     * Limit how many TugasPenanamanPenggunas to delete.
     */
    limit?: number
  }

  /**
   * TugasPenanamanPengguna without action
   */
  export type TugasPenanamanPenggunaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasPenanamanPengguna
     */
    select?: TugasPenanamanPenggunaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TugasPenanamanPengguna
     */
    omit?: TugasPenanamanPenggunaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TugasPenanamanPenggunaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProvinsiScalarFieldEnum: {
    id_provinsi: 'id_provinsi',
    nama_provinsi: 'nama_provinsi'
  };

  export type ProvinsiScalarFieldEnum = (typeof ProvinsiScalarFieldEnum)[keyof typeof ProvinsiScalarFieldEnum]


  export const KabupatenScalarFieldEnum: {
    id_kabupaten: 'id_kabupaten',
    nama_kabupaten: 'nama_kabupaten',
    type: 'type',
    id_provinsi: 'id_provinsi'
  };

  export type KabupatenScalarFieldEnum = (typeof KabupatenScalarFieldEnum)[keyof typeof KabupatenScalarFieldEnum]


  export const PenggunaScalarFieldEnum: {
    id_pengguna: 'id_pengguna',
    nama_depan_pengguna: 'nama_depan_pengguna',
    nama_belakang_pengguna: 'nama_belakang_pengguna',
    tanggal_lahir_pengguna: 'tanggal_lahir_pengguna',
    email_pengguna: 'email_pengguna',
    nomor_telepon_pengguna: 'nomor_telepon_pengguna',
    jenisKelamin: 'jenisKelamin',
    password_pengguna: 'password_pengguna',
    tanggal_pembuatan_akun: 'tanggal_pembuatan_akun',
    kode_verifikasi: 'kode_verifikasi',
    status_verfikasi: 'status_verfikasi',
    avatar: 'avatar',
    status_aktif: 'status_aktif'
  };

  export type PenggunaScalarFieldEnum = (typeof PenggunaScalarFieldEnum)[keyof typeof PenggunaScalarFieldEnum]


  export const FacilitatorScalarFieldEnum: {
    id_facilitator: 'id_facilitator',
    nama_facilitator: 'nama_facilitator',
    email_facilitator: 'email_facilitator',
    nomor_telepon_facilitator: 'nomor_telepon_facilitator',
    password_facilitator: 'password_facilitator',
    tanggal_pembuatan_akun: 'tanggal_pembuatan_akun',
    alamat_lengkap_facilitator: 'alamat_lengkap_facilitator',
    avatar: 'avatar',
    status_aktif: 'status_aktif',
    id_kabupaten: 'id_kabupaten'
  };

  export type FacilitatorScalarFieldEnum = (typeof FacilitatorScalarFieldEnum)[keyof typeof FacilitatorScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id_admin: 'id_admin',
    nama_depan_admin: 'nama_depan_admin',
    nama_belakang_admin: 'nama_belakang_admin',
    email_admin: 'email_admin',
    password_admin: 'password_admin',
    tanggal_pembuatan_akun: 'tanggal_pembuatan_akun',
    avatar: 'avatar'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ArtikelScalarFieldEnum: {
    id_artikel: 'id_artikel',
    judul_artikel: 'judul_artikel',
    tanggal_artikel: 'tanggal_artikel',
    deskripsi_artikel: 'deskripsi_artikel',
    isi_artikel: 'isi_artikel',
    status_artikel: 'status_artikel',
    status_verifikasi: 'status_verifikasi',
    gambar_artikel: 'gambar_artikel',
    status_aktif: 'status_aktif',
    id_kategori_artikel: 'id_kategori_artikel',
    id_pengguna: 'id_pengguna'
  };

  export type ArtikelScalarFieldEnum = (typeof ArtikelScalarFieldEnum)[keyof typeof ArtikelScalarFieldEnum]


  export const KategoriArtikelScalarFieldEnum: {
    id_kategori_artikel: 'id_kategori_artikel',
    nama_kategori_artikel: 'nama_kategori_artikel'
  };

  export type KategoriArtikelScalarFieldEnum = (typeof KategoriArtikelScalarFieldEnum)[keyof typeof KategoriArtikelScalarFieldEnum]


  export const ArtikelDisimpanScalarFieldEnum: {
    id_penyimpanan: 'id_penyimpanan',
    id_artikel: 'id_artikel',
    id_pengguna: 'id_pengguna'
  };

  export type ArtikelDisimpanScalarFieldEnum = (typeof ArtikelDisimpanScalarFieldEnum)[keyof typeof ArtikelDisimpanScalarFieldEnum]


  export const ArtikelDisukaiScalarFieldEnum: {
    id_disukai: 'id_disukai',
    id_artikel: 'id_artikel',
    id_pengguna: 'id_pengguna',
    rating: 'rating'
  };

  export type ArtikelDisukaiScalarFieldEnum = (typeof ArtikelDisukaiScalarFieldEnum)[keyof typeof ArtikelDisukaiScalarFieldEnum]


  export const KomentarArtikelScalarFieldEnum: {
    id_komentar: 'id_komentar',
    id_artikel: 'id_artikel',
    id_pengguna: 'id_pengguna',
    komentar: 'komentar'
  };

  export type KomentarArtikelScalarFieldEnum = (typeof KomentarArtikelScalarFieldEnum)[keyof typeof KomentarArtikelScalarFieldEnum]


  export const WorkshopScalarFieldEnum: {
    id_workshop: 'id_workshop',
    judul_workshop: 'judul_workshop',
    tanggal_workshop: 'tanggal_workshop',
    alaamt_lengkap_workshop: 'alaamt_lengkap_workshop',
    deskripsi_workshop: 'deskripsi_workshop',
    harga_workshop: 'harga_workshop',
    kapasitas: 'kapasitas',
    status_verifikasi: 'status_verifikasi',
    lat_lokasi: 'lat_lokasi',
    long_lokasi: 'long_lokasi',
    gambar_workshop: 'gambar_workshop',
    status_aktif: 'status_aktif',
    id_facilitator: 'id_facilitator',
    id_kabupaten: 'id_kabupaten'
  };

  export type WorkshopScalarFieldEnum = (typeof WorkshopScalarFieldEnum)[keyof typeof WorkshopScalarFieldEnum]


  export const WorkshopTerdaftarScalarFieldEnum: {
    id_pendaftaran: 'id_pendaftaran',
    nama_peserta: 'nama_peserta',
    email_peserta: 'email_peserta',
    nomor_telepon_peserta: 'nomor_telepon_peserta',
    tanggal_pendaftaran: 'tanggal_pendaftaran',
    status_pembayaran: 'status_pembayaran',
    nomor_tiket: 'nomor_tiket',
    id_pengguna: 'id_pengguna',
    id_workshop: 'id_workshop'
  };

  export type WorkshopTerdaftarScalarFieldEnum = (typeof WorkshopTerdaftarScalarFieldEnum)[keyof typeof WorkshopTerdaftarScalarFieldEnum]


  export const KategoriTanamanScalarFieldEnum: {
    id_kategori_tanaman: 'id_kategori_tanaman',
    nama_kategori_tanaman: 'nama_kategori_tanaman'
  };

  export type KategoriTanamanScalarFieldEnum = (typeof KategoriTanamanScalarFieldEnum)[keyof typeof KategoriTanamanScalarFieldEnum]


  export const TanamanScalarFieldEnum: {
    id_tanaman: 'id_tanaman',
    nama_tanaman: 'nama_tanaman',
    nama_latin: 'nama_latin',
    durasi_penanaman: 'durasi_penanaman',
    deskripsi_tanaman: 'deskripsi_tanaman',
    id_kategori_tanaman: 'id_kategori_tanaman'
  };

  export type TanamanScalarFieldEnum = (typeof TanamanScalarFieldEnum)[keyof typeof TanamanScalarFieldEnum]


  export const InstruksiTanamanScalarFieldEnum: {
    id_instruksi: 'id_instruksi',
    instruksi: 'instruksi',
    id_tanaman: 'id_tanaman'
  };

  export type InstruksiTanamanScalarFieldEnum = (typeof InstruksiTanamanScalarFieldEnum)[keyof typeof InstruksiTanamanScalarFieldEnum]


  export const HariPenanamanScalarFieldEnum: {
    id_hari_penanaman: 'id_hari_penanaman',
    jenis_tugas: 'jenis_tugas',
    id_tanaman: 'id_tanaman'
  };

  export type HariPenanamanScalarFieldEnum = (typeof HariPenanamanScalarFieldEnum)[keyof typeof HariPenanamanScalarFieldEnum]


  export const TugasPenanamanScalarFieldEnum: {
    id_tugas: 'id_tugas',
    nama_tugas: 'nama_tugas',
    id_hari_penanaman: 'id_hari_penanaman'
  };

  export type TugasPenanamanScalarFieldEnum = (typeof TugasPenanamanScalarFieldEnum)[keyof typeof TugasPenanamanScalarFieldEnum]


  export const TanamanPenggunaScalarFieldEnum: {
    id_tanaman_pengguna: 'id_tanaman_pengguna',
    tanggal_penanaman: 'tanggal_penanaman',
    status_penanaman: 'status_penanaman',
    nama_tanaman: 'nama_tanaman',
    id_tanaman: 'id_tanaman',
    id_pengguna: 'id_pengguna'
  };

  export type TanamanPenggunaScalarFieldEnum = (typeof TanamanPenggunaScalarFieldEnum)[keyof typeof TanamanPenggunaScalarFieldEnum]


  export const HariTanamanPenggunaScalarFieldEnum: {
    id_hari_tanaman_pengguna: 'id_hari_tanaman_pengguna',
    catatan: 'catatan',
    id_tanaman_pengguna: 'id_tanaman_pengguna'
  };

  export type HariTanamanPenggunaScalarFieldEnum = (typeof HariTanamanPenggunaScalarFieldEnum)[keyof typeof HariTanamanPenggunaScalarFieldEnum]


  export const TugasPenanamanPenggunaScalarFieldEnum: {
    id_tugas_penanaman_pengguna: 'id_tugas_penanaman_pengguna',
    nama_tugas: 'nama_tugas',
    id_hari_tanaman_pengguna: 'id_hari_tanaman_pengguna'
  };

  export type TugasPenanamanPenggunaScalarFieldEnum = (typeof TugasPenanamanPenggunaScalarFieldEnum)[keyof typeof TugasPenanamanPenggunaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'StatusArtikel'
   */
  export type EnumStatusArtikelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusArtikel'>
    


  /**
   * Reference to a field of type 'StatusArtikel[]'
   */
  export type ListEnumStatusArtikelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusArtikel[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProvinsiWhereInput = {
    AND?: ProvinsiWhereInput | ProvinsiWhereInput[]
    OR?: ProvinsiWhereInput[]
    NOT?: ProvinsiWhereInput | ProvinsiWhereInput[]
    id_provinsi?: IntFilter<"Provinsi"> | number
    nama_provinsi?: StringFilter<"Provinsi"> | string
    kabupaten?: KabupatenListRelationFilter
  }

  export type ProvinsiOrderByWithRelationInput = {
    id_provinsi?: SortOrder
    nama_provinsi?: SortOrder
    kabupaten?: KabupatenOrderByRelationAggregateInput
  }

  export type ProvinsiWhereUniqueInput = Prisma.AtLeast<{
    id_provinsi?: number
    AND?: ProvinsiWhereInput | ProvinsiWhereInput[]
    OR?: ProvinsiWhereInput[]
    NOT?: ProvinsiWhereInput | ProvinsiWhereInput[]
    nama_provinsi?: StringFilter<"Provinsi"> | string
    kabupaten?: KabupatenListRelationFilter
  }, "id_provinsi">

  export type ProvinsiOrderByWithAggregationInput = {
    id_provinsi?: SortOrder
    nama_provinsi?: SortOrder
    _count?: ProvinsiCountOrderByAggregateInput
    _avg?: ProvinsiAvgOrderByAggregateInput
    _max?: ProvinsiMaxOrderByAggregateInput
    _min?: ProvinsiMinOrderByAggregateInput
    _sum?: ProvinsiSumOrderByAggregateInput
  }

  export type ProvinsiScalarWhereWithAggregatesInput = {
    AND?: ProvinsiScalarWhereWithAggregatesInput | ProvinsiScalarWhereWithAggregatesInput[]
    OR?: ProvinsiScalarWhereWithAggregatesInput[]
    NOT?: ProvinsiScalarWhereWithAggregatesInput | ProvinsiScalarWhereWithAggregatesInput[]
    id_provinsi?: IntWithAggregatesFilter<"Provinsi"> | number
    nama_provinsi?: StringWithAggregatesFilter<"Provinsi"> | string
  }

  export type KabupatenWhereInput = {
    AND?: KabupatenWhereInput | KabupatenWhereInput[]
    OR?: KabupatenWhereInput[]
    NOT?: KabupatenWhereInput | KabupatenWhereInput[]
    id_kabupaten?: IntFilter<"Kabupaten"> | number
    nama_kabupaten?: StringFilter<"Kabupaten"> | string
    type?: StringFilter<"Kabupaten"> | string
    id_provinsi?: IntFilter<"Kabupaten"> | number
    provinsi?: XOR<ProvinsiScalarRelationFilter, ProvinsiWhereInput>
    facilitators?: FacilitatorListRelationFilter
    workshop?: WorkshopListRelationFilter
  }

  export type KabupatenOrderByWithRelationInput = {
    id_kabupaten?: SortOrder
    nama_kabupaten?: SortOrder
    type?: SortOrder
    id_provinsi?: SortOrder
    provinsi?: ProvinsiOrderByWithRelationInput
    facilitators?: FacilitatorOrderByRelationAggregateInput
    workshop?: WorkshopOrderByRelationAggregateInput
  }

  export type KabupatenWhereUniqueInput = Prisma.AtLeast<{
    id_kabupaten?: number
    AND?: KabupatenWhereInput | KabupatenWhereInput[]
    OR?: KabupatenWhereInput[]
    NOT?: KabupatenWhereInput | KabupatenWhereInput[]
    nama_kabupaten?: StringFilter<"Kabupaten"> | string
    type?: StringFilter<"Kabupaten"> | string
    id_provinsi?: IntFilter<"Kabupaten"> | number
    provinsi?: XOR<ProvinsiScalarRelationFilter, ProvinsiWhereInput>
    facilitators?: FacilitatorListRelationFilter
    workshop?: WorkshopListRelationFilter
  }, "id_kabupaten">

  export type KabupatenOrderByWithAggregationInput = {
    id_kabupaten?: SortOrder
    nama_kabupaten?: SortOrder
    type?: SortOrder
    id_provinsi?: SortOrder
    _count?: KabupatenCountOrderByAggregateInput
    _avg?: KabupatenAvgOrderByAggregateInput
    _max?: KabupatenMaxOrderByAggregateInput
    _min?: KabupatenMinOrderByAggregateInput
    _sum?: KabupatenSumOrderByAggregateInput
  }

  export type KabupatenScalarWhereWithAggregatesInput = {
    AND?: KabupatenScalarWhereWithAggregatesInput | KabupatenScalarWhereWithAggregatesInput[]
    OR?: KabupatenScalarWhereWithAggregatesInput[]
    NOT?: KabupatenScalarWhereWithAggregatesInput | KabupatenScalarWhereWithAggregatesInput[]
    id_kabupaten?: IntWithAggregatesFilter<"Kabupaten"> | number
    nama_kabupaten?: StringWithAggregatesFilter<"Kabupaten"> | string
    type?: StringWithAggregatesFilter<"Kabupaten"> | string
    id_provinsi?: IntWithAggregatesFilter<"Kabupaten"> | number
  }

  export type PenggunaWhereInput = {
    AND?: PenggunaWhereInput | PenggunaWhereInput[]
    OR?: PenggunaWhereInput[]
    NOT?: PenggunaWhereInput | PenggunaWhereInput[]
    id_pengguna?: StringFilter<"Pengguna"> | string
    nama_depan_pengguna?: StringFilter<"Pengguna"> | string
    nama_belakang_pengguna?: StringFilter<"Pengguna"> | string
    tanggal_lahir_pengguna?: DateTimeFilter<"Pengguna"> | Date | string
    email_pengguna?: StringFilter<"Pengguna"> | string
    nomor_telepon_pengguna?: StringFilter<"Pengguna"> | string
    jenisKelamin?: IntFilter<"Pengguna"> | number
    password_pengguna?: StringFilter<"Pengguna"> | string
    tanggal_pembuatan_akun?: DateTimeFilter<"Pengguna"> | Date | string
    kode_verifikasi?: StringFilter<"Pengguna"> | string
    status_verfikasi?: BoolFilter<"Pengguna"> | boolean
    avatar?: StringNullableFilter<"Pengguna"> | string | null
    status_aktif?: BoolFilter<"Pengguna"> | boolean
    workshop_terdaftar?: WorkshopTerdaftarListRelationFilter
    artikel?: ArtikelListRelationFilter
    artikel_disimpan?: ArtikelDisimpanListRelationFilter
    artikel_disukai?: ArtikelDisukaiListRelationFilter
    komentar_artikel?: KomentarArtikelListRelationFilter
    tanaman_pengguna?: TanamanPenggunaListRelationFilter
  }

  export type PenggunaOrderByWithRelationInput = {
    id_pengguna?: SortOrder
    nama_depan_pengguna?: SortOrder
    nama_belakang_pengguna?: SortOrder
    tanggal_lahir_pengguna?: SortOrder
    email_pengguna?: SortOrder
    nomor_telepon_pengguna?: SortOrder
    jenisKelamin?: SortOrder
    password_pengguna?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    kode_verifikasi?: SortOrder
    status_verfikasi?: SortOrder
    avatar?: SortOrderInput | SortOrder
    status_aktif?: SortOrder
    workshop_terdaftar?: WorkshopTerdaftarOrderByRelationAggregateInput
    artikel?: ArtikelOrderByRelationAggregateInput
    artikel_disimpan?: ArtikelDisimpanOrderByRelationAggregateInput
    artikel_disukai?: ArtikelDisukaiOrderByRelationAggregateInput
    komentar_artikel?: KomentarArtikelOrderByRelationAggregateInput
    tanaman_pengguna?: TanamanPenggunaOrderByRelationAggregateInput
  }

  export type PenggunaWhereUniqueInput = Prisma.AtLeast<{
    id_pengguna?: string
    email_pengguna?: string
    nomor_telepon_pengguna?: string
    AND?: PenggunaWhereInput | PenggunaWhereInput[]
    OR?: PenggunaWhereInput[]
    NOT?: PenggunaWhereInput | PenggunaWhereInput[]
    nama_depan_pengguna?: StringFilter<"Pengguna"> | string
    nama_belakang_pengguna?: StringFilter<"Pengguna"> | string
    tanggal_lahir_pengguna?: DateTimeFilter<"Pengguna"> | Date | string
    jenisKelamin?: IntFilter<"Pengguna"> | number
    password_pengguna?: StringFilter<"Pengguna"> | string
    tanggal_pembuatan_akun?: DateTimeFilter<"Pengguna"> | Date | string
    kode_verifikasi?: StringFilter<"Pengguna"> | string
    status_verfikasi?: BoolFilter<"Pengguna"> | boolean
    avatar?: StringNullableFilter<"Pengguna"> | string | null
    status_aktif?: BoolFilter<"Pengguna"> | boolean
    workshop_terdaftar?: WorkshopTerdaftarListRelationFilter
    artikel?: ArtikelListRelationFilter
    artikel_disimpan?: ArtikelDisimpanListRelationFilter
    artikel_disukai?: ArtikelDisukaiListRelationFilter
    komentar_artikel?: KomentarArtikelListRelationFilter
    tanaman_pengguna?: TanamanPenggunaListRelationFilter
  }, "id_pengguna" | "email_pengguna" | "nomor_telepon_pengguna">

  export type PenggunaOrderByWithAggregationInput = {
    id_pengguna?: SortOrder
    nama_depan_pengguna?: SortOrder
    nama_belakang_pengguna?: SortOrder
    tanggal_lahir_pengguna?: SortOrder
    email_pengguna?: SortOrder
    nomor_telepon_pengguna?: SortOrder
    jenisKelamin?: SortOrder
    password_pengguna?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    kode_verifikasi?: SortOrder
    status_verfikasi?: SortOrder
    avatar?: SortOrderInput | SortOrder
    status_aktif?: SortOrder
    _count?: PenggunaCountOrderByAggregateInput
    _avg?: PenggunaAvgOrderByAggregateInput
    _max?: PenggunaMaxOrderByAggregateInput
    _min?: PenggunaMinOrderByAggregateInput
    _sum?: PenggunaSumOrderByAggregateInput
  }

  export type PenggunaScalarWhereWithAggregatesInput = {
    AND?: PenggunaScalarWhereWithAggregatesInput | PenggunaScalarWhereWithAggregatesInput[]
    OR?: PenggunaScalarWhereWithAggregatesInput[]
    NOT?: PenggunaScalarWhereWithAggregatesInput | PenggunaScalarWhereWithAggregatesInput[]
    id_pengguna?: StringWithAggregatesFilter<"Pengguna"> | string
    nama_depan_pengguna?: StringWithAggregatesFilter<"Pengguna"> | string
    nama_belakang_pengguna?: StringWithAggregatesFilter<"Pengguna"> | string
    tanggal_lahir_pengguna?: DateTimeWithAggregatesFilter<"Pengguna"> | Date | string
    email_pengguna?: StringWithAggregatesFilter<"Pengguna"> | string
    nomor_telepon_pengguna?: StringWithAggregatesFilter<"Pengguna"> | string
    jenisKelamin?: IntWithAggregatesFilter<"Pengguna"> | number
    password_pengguna?: StringWithAggregatesFilter<"Pengguna"> | string
    tanggal_pembuatan_akun?: DateTimeWithAggregatesFilter<"Pengguna"> | Date | string
    kode_verifikasi?: StringWithAggregatesFilter<"Pengguna"> | string
    status_verfikasi?: BoolWithAggregatesFilter<"Pengguna"> | boolean
    avatar?: StringNullableWithAggregatesFilter<"Pengguna"> | string | null
    status_aktif?: BoolWithAggregatesFilter<"Pengguna"> | boolean
  }

  export type FacilitatorWhereInput = {
    AND?: FacilitatorWhereInput | FacilitatorWhereInput[]
    OR?: FacilitatorWhereInput[]
    NOT?: FacilitatorWhereInput | FacilitatorWhereInput[]
    id_facilitator?: StringFilter<"Facilitator"> | string
    nama_facilitator?: StringFilter<"Facilitator"> | string
    email_facilitator?: StringFilter<"Facilitator"> | string
    nomor_telepon_facilitator?: StringFilter<"Facilitator"> | string
    password_facilitator?: StringFilter<"Facilitator"> | string
    tanggal_pembuatan_akun?: DateTimeFilter<"Facilitator"> | Date | string
    alamat_lengkap_facilitator?: StringFilter<"Facilitator"> | string
    avatar?: StringNullableFilter<"Facilitator"> | string | null
    status_aktif?: BoolFilter<"Facilitator"> | boolean
    id_kabupaten?: IntFilter<"Facilitator"> | number
    kabupaten?: XOR<KabupatenScalarRelationFilter, KabupatenWhereInput>
    workshops?: WorkshopListRelationFilter
  }

  export type FacilitatorOrderByWithRelationInput = {
    id_facilitator?: SortOrder
    nama_facilitator?: SortOrder
    email_facilitator?: SortOrder
    nomor_telepon_facilitator?: SortOrder
    password_facilitator?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    alamat_lengkap_facilitator?: SortOrder
    avatar?: SortOrderInput | SortOrder
    status_aktif?: SortOrder
    id_kabupaten?: SortOrder
    kabupaten?: KabupatenOrderByWithRelationInput
    workshops?: WorkshopOrderByRelationAggregateInput
  }

  export type FacilitatorWhereUniqueInput = Prisma.AtLeast<{
    id_facilitator?: string
    email_facilitator?: string
    nomor_telepon_facilitator?: string
    AND?: FacilitatorWhereInput | FacilitatorWhereInput[]
    OR?: FacilitatorWhereInput[]
    NOT?: FacilitatorWhereInput | FacilitatorWhereInput[]
    nama_facilitator?: StringFilter<"Facilitator"> | string
    password_facilitator?: StringFilter<"Facilitator"> | string
    tanggal_pembuatan_akun?: DateTimeFilter<"Facilitator"> | Date | string
    alamat_lengkap_facilitator?: StringFilter<"Facilitator"> | string
    avatar?: StringNullableFilter<"Facilitator"> | string | null
    status_aktif?: BoolFilter<"Facilitator"> | boolean
    id_kabupaten?: IntFilter<"Facilitator"> | number
    kabupaten?: XOR<KabupatenScalarRelationFilter, KabupatenWhereInput>
    workshops?: WorkshopListRelationFilter
  }, "id_facilitator" | "email_facilitator" | "nomor_telepon_facilitator">

  export type FacilitatorOrderByWithAggregationInput = {
    id_facilitator?: SortOrder
    nama_facilitator?: SortOrder
    email_facilitator?: SortOrder
    nomor_telepon_facilitator?: SortOrder
    password_facilitator?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    alamat_lengkap_facilitator?: SortOrder
    avatar?: SortOrderInput | SortOrder
    status_aktif?: SortOrder
    id_kabupaten?: SortOrder
    _count?: FacilitatorCountOrderByAggregateInput
    _avg?: FacilitatorAvgOrderByAggregateInput
    _max?: FacilitatorMaxOrderByAggregateInput
    _min?: FacilitatorMinOrderByAggregateInput
    _sum?: FacilitatorSumOrderByAggregateInput
  }

  export type FacilitatorScalarWhereWithAggregatesInput = {
    AND?: FacilitatorScalarWhereWithAggregatesInput | FacilitatorScalarWhereWithAggregatesInput[]
    OR?: FacilitatorScalarWhereWithAggregatesInput[]
    NOT?: FacilitatorScalarWhereWithAggregatesInput | FacilitatorScalarWhereWithAggregatesInput[]
    id_facilitator?: StringWithAggregatesFilter<"Facilitator"> | string
    nama_facilitator?: StringWithAggregatesFilter<"Facilitator"> | string
    email_facilitator?: StringWithAggregatesFilter<"Facilitator"> | string
    nomor_telepon_facilitator?: StringWithAggregatesFilter<"Facilitator"> | string
    password_facilitator?: StringWithAggregatesFilter<"Facilitator"> | string
    tanggal_pembuatan_akun?: DateTimeWithAggregatesFilter<"Facilitator"> | Date | string
    alamat_lengkap_facilitator?: StringWithAggregatesFilter<"Facilitator"> | string
    avatar?: StringNullableWithAggregatesFilter<"Facilitator"> | string | null
    status_aktif?: BoolWithAggregatesFilter<"Facilitator"> | boolean
    id_kabupaten?: IntWithAggregatesFilter<"Facilitator"> | number
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id_admin?: StringFilter<"Admin"> | string
    nama_depan_admin?: StringFilter<"Admin"> | string
    nama_belakang_admin?: StringFilter<"Admin"> | string
    email_admin?: StringFilter<"Admin"> | string
    password_admin?: StringFilter<"Admin"> | string
    tanggal_pembuatan_akun?: DateTimeFilter<"Admin"> | Date | string
    avatar?: StringNullableFilter<"Admin"> | string | null
  }

  export type AdminOrderByWithRelationInput = {
    id_admin?: SortOrder
    nama_depan_admin?: SortOrder
    nama_belakang_admin?: SortOrder
    email_admin?: SortOrder
    password_admin?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    avatar?: SortOrderInput | SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id_admin?: string
    email_admin?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    nama_depan_admin?: StringFilter<"Admin"> | string
    nama_belakang_admin?: StringFilter<"Admin"> | string
    password_admin?: StringFilter<"Admin"> | string
    tanggal_pembuatan_akun?: DateTimeFilter<"Admin"> | Date | string
    avatar?: StringNullableFilter<"Admin"> | string | null
  }, "id_admin" | "email_admin">

  export type AdminOrderByWithAggregationInput = {
    id_admin?: SortOrder
    nama_depan_admin?: SortOrder
    nama_belakang_admin?: SortOrder
    email_admin?: SortOrder
    password_admin?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    avatar?: SortOrderInput | SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id_admin?: StringWithAggregatesFilter<"Admin"> | string
    nama_depan_admin?: StringWithAggregatesFilter<"Admin"> | string
    nama_belakang_admin?: StringWithAggregatesFilter<"Admin"> | string
    email_admin?: StringWithAggregatesFilter<"Admin"> | string
    password_admin?: StringWithAggregatesFilter<"Admin"> | string
    tanggal_pembuatan_akun?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    avatar?: StringNullableWithAggregatesFilter<"Admin"> | string | null
  }

  export type ArtikelWhereInput = {
    AND?: ArtikelWhereInput | ArtikelWhereInput[]
    OR?: ArtikelWhereInput[]
    NOT?: ArtikelWhereInput | ArtikelWhereInput[]
    id_artikel?: StringFilter<"Artikel"> | string
    judul_artikel?: StringFilter<"Artikel"> | string
    tanggal_artikel?: DateTimeFilter<"Artikel"> | Date | string
    deskripsi_artikel?: StringFilter<"Artikel"> | string
    isi_artikel?: StringFilter<"Artikel"> | string
    status_artikel?: EnumStatusArtikelFilter<"Artikel"> | $Enums.StatusArtikel
    status_verifikasi?: BoolFilter<"Artikel"> | boolean
    gambar_artikel?: StringFilter<"Artikel"> | string
    status_aktif?: BoolFilter<"Artikel"> | boolean
    id_kategori_artikel?: IntFilter<"Artikel"> | number
    id_pengguna?: StringFilter<"Artikel"> | string
    kategori?: XOR<KategoriArtikelScalarRelationFilter, KategoriArtikelWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
    artikel_disimpan?: ArtikelDisimpanListRelationFilter
    artikel_disukai?: ArtikelDisukaiListRelationFilter
    komentar_artikel?: KomentarArtikelListRelationFilter
  }

  export type ArtikelOrderByWithRelationInput = {
    id_artikel?: SortOrder
    judul_artikel?: SortOrder
    tanggal_artikel?: SortOrder
    deskripsi_artikel?: SortOrder
    isi_artikel?: SortOrder
    status_artikel?: SortOrder
    status_verifikasi?: SortOrder
    gambar_artikel?: SortOrder
    status_aktif?: SortOrder
    id_kategori_artikel?: SortOrder
    id_pengguna?: SortOrder
    kategori?: KategoriArtikelOrderByWithRelationInput
    pengguna?: PenggunaOrderByWithRelationInput
    artikel_disimpan?: ArtikelDisimpanOrderByRelationAggregateInput
    artikel_disukai?: ArtikelDisukaiOrderByRelationAggregateInput
    komentar_artikel?: KomentarArtikelOrderByRelationAggregateInput
  }

  export type ArtikelWhereUniqueInput = Prisma.AtLeast<{
    id_artikel?: string
    AND?: ArtikelWhereInput | ArtikelWhereInput[]
    OR?: ArtikelWhereInput[]
    NOT?: ArtikelWhereInput | ArtikelWhereInput[]
    judul_artikel?: StringFilter<"Artikel"> | string
    tanggal_artikel?: DateTimeFilter<"Artikel"> | Date | string
    deskripsi_artikel?: StringFilter<"Artikel"> | string
    isi_artikel?: StringFilter<"Artikel"> | string
    status_artikel?: EnumStatusArtikelFilter<"Artikel"> | $Enums.StatusArtikel
    status_verifikasi?: BoolFilter<"Artikel"> | boolean
    gambar_artikel?: StringFilter<"Artikel"> | string
    status_aktif?: BoolFilter<"Artikel"> | boolean
    id_kategori_artikel?: IntFilter<"Artikel"> | number
    id_pengguna?: StringFilter<"Artikel"> | string
    kategori?: XOR<KategoriArtikelScalarRelationFilter, KategoriArtikelWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
    artikel_disimpan?: ArtikelDisimpanListRelationFilter
    artikel_disukai?: ArtikelDisukaiListRelationFilter
    komentar_artikel?: KomentarArtikelListRelationFilter
  }, "id_artikel">

  export type ArtikelOrderByWithAggregationInput = {
    id_artikel?: SortOrder
    judul_artikel?: SortOrder
    tanggal_artikel?: SortOrder
    deskripsi_artikel?: SortOrder
    isi_artikel?: SortOrder
    status_artikel?: SortOrder
    status_verifikasi?: SortOrder
    gambar_artikel?: SortOrder
    status_aktif?: SortOrder
    id_kategori_artikel?: SortOrder
    id_pengguna?: SortOrder
    _count?: ArtikelCountOrderByAggregateInput
    _avg?: ArtikelAvgOrderByAggregateInput
    _max?: ArtikelMaxOrderByAggregateInput
    _min?: ArtikelMinOrderByAggregateInput
    _sum?: ArtikelSumOrderByAggregateInput
  }

  export type ArtikelScalarWhereWithAggregatesInput = {
    AND?: ArtikelScalarWhereWithAggregatesInput | ArtikelScalarWhereWithAggregatesInput[]
    OR?: ArtikelScalarWhereWithAggregatesInput[]
    NOT?: ArtikelScalarWhereWithAggregatesInput | ArtikelScalarWhereWithAggregatesInput[]
    id_artikel?: StringWithAggregatesFilter<"Artikel"> | string
    judul_artikel?: StringWithAggregatesFilter<"Artikel"> | string
    tanggal_artikel?: DateTimeWithAggregatesFilter<"Artikel"> | Date | string
    deskripsi_artikel?: StringWithAggregatesFilter<"Artikel"> | string
    isi_artikel?: StringWithAggregatesFilter<"Artikel"> | string
    status_artikel?: EnumStatusArtikelWithAggregatesFilter<"Artikel"> | $Enums.StatusArtikel
    status_verifikasi?: BoolWithAggregatesFilter<"Artikel"> | boolean
    gambar_artikel?: StringWithAggregatesFilter<"Artikel"> | string
    status_aktif?: BoolWithAggregatesFilter<"Artikel"> | boolean
    id_kategori_artikel?: IntWithAggregatesFilter<"Artikel"> | number
    id_pengguna?: StringWithAggregatesFilter<"Artikel"> | string
  }

  export type KategoriArtikelWhereInput = {
    AND?: KategoriArtikelWhereInput | KategoriArtikelWhereInput[]
    OR?: KategoriArtikelWhereInput[]
    NOT?: KategoriArtikelWhereInput | KategoriArtikelWhereInput[]
    id_kategori_artikel?: IntFilter<"KategoriArtikel"> | number
    nama_kategori_artikel?: StringFilter<"KategoriArtikel"> | string
    artikel?: ArtikelListRelationFilter
  }

  export type KategoriArtikelOrderByWithRelationInput = {
    id_kategori_artikel?: SortOrder
    nama_kategori_artikel?: SortOrder
    artikel?: ArtikelOrderByRelationAggregateInput
  }

  export type KategoriArtikelWhereUniqueInput = Prisma.AtLeast<{
    id_kategori_artikel?: number
    AND?: KategoriArtikelWhereInput | KategoriArtikelWhereInput[]
    OR?: KategoriArtikelWhereInput[]
    NOT?: KategoriArtikelWhereInput | KategoriArtikelWhereInput[]
    nama_kategori_artikel?: StringFilter<"KategoriArtikel"> | string
    artikel?: ArtikelListRelationFilter
  }, "id_kategori_artikel">

  export type KategoriArtikelOrderByWithAggregationInput = {
    id_kategori_artikel?: SortOrder
    nama_kategori_artikel?: SortOrder
    _count?: KategoriArtikelCountOrderByAggregateInput
    _avg?: KategoriArtikelAvgOrderByAggregateInput
    _max?: KategoriArtikelMaxOrderByAggregateInput
    _min?: KategoriArtikelMinOrderByAggregateInput
    _sum?: KategoriArtikelSumOrderByAggregateInput
  }

  export type KategoriArtikelScalarWhereWithAggregatesInput = {
    AND?: KategoriArtikelScalarWhereWithAggregatesInput | KategoriArtikelScalarWhereWithAggregatesInput[]
    OR?: KategoriArtikelScalarWhereWithAggregatesInput[]
    NOT?: KategoriArtikelScalarWhereWithAggregatesInput | KategoriArtikelScalarWhereWithAggregatesInput[]
    id_kategori_artikel?: IntWithAggregatesFilter<"KategoriArtikel"> | number
    nama_kategori_artikel?: StringWithAggregatesFilter<"KategoriArtikel"> | string
  }

  export type ArtikelDisimpanWhereInput = {
    AND?: ArtikelDisimpanWhereInput | ArtikelDisimpanWhereInput[]
    OR?: ArtikelDisimpanWhereInput[]
    NOT?: ArtikelDisimpanWhereInput | ArtikelDisimpanWhereInput[]
    id_penyimpanan?: IntFilter<"ArtikelDisimpan"> | number
    id_artikel?: StringFilter<"ArtikelDisimpan"> | string
    id_pengguna?: StringFilter<"ArtikelDisimpan"> | string
    artikel?: XOR<ArtikelScalarRelationFilter, ArtikelWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
  }

  export type ArtikelDisimpanOrderByWithRelationInput = {
    id_penyimpanan?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    artikel?: ArtikelOrderByWithRelationInput
    pengguna?: PenggunaOrderByWithRelationInput
  }

  export type ArtikelDisimpanWhereUniqueInput = Prisma.AtLeast<{
    id_penyimpanan?: number
    id_artikel_id_pengguna?: ArtikelDisimpanId_artikelId_penggunaCompoundUniqueInput
    AND?: ArtikelDisimpanWhereInput | ArtikelDisimpanWhereInput[]
    OR?: ArtikelDisimpanWhereInput[]
    NOT?: ArtikelDisimpanWhereInput | ArtikelDisimpanWhereInput[]
    id_artikel?: StringFilter<"ArtikelDisimpan"> | string
    id_pengguna?: StringFilter<"ArtikelDisimpan"> | string
    artikel?: XOR<ArtikelScalarRelationFilter, ArtikelWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
  }, "id_penyimpanan" | "id_artikel_id_pengguna">

  export type ArtikelDisimpanOrderByWithAggregationInput = {
    id_penyimpanan?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    _count?: ArtikelDisimpanCountOrderByAggregateInput
    _avg?: ArtikelDisimpanAvgOrderByAggregateInput
    _max?: ArtikelDisimpanMaxOrderByAggregateInput
    _min?: ArtikelDisimpanMinOrderByAggregateInput
    _sum?: ArtikelDisimpanSumOrderByAggregateInput
  }

  export type ArtikelDisimpanScalarWhereWithAggregatesInput = {
    AND?: ArtikelDisimpanScalarWhereWithAggregatesInput | ArtikelDisimpanScalarWhereWithAggregatesInput[]
    OR?: ArtikelDisimpanScalarWhereWithAggregatesInput[]
    NOT?: ArtikelDisimpanScalarWhereWithAggregatesInput | ArtikelDisimpanScalarWhereWithAggregatesInput[]
    id_penyimpanan?: IntWithAggregatesFilter<"ArtikelDisimpan"> | number
    id_artikel?: StringWithAggregatesFilter<"ArtikelDisimpan"> | string
    id_pengguna?: StringWithAggregatesFilter<"ArtikelDisimpan"> | string
  }

  export type ArtikelDisukaiWhereInput = {
    AND?: ArtikelDisukaiWhereInput | ArtikelDisukaiWhereInput[]
    OR?: ArtikelDisukaiWhereInput[]
    NOT?: ArtikelDisukaiWhereInput | ArtikelDisukaiWhereInput[]
    id_disukai?: IntFilter<"ArtikelDisukai"> | number
    id_artikel?: StringFilter<"ArtikelDisukai"> | string
    id_pengguna?: StringFilter<"ArtikelDisukai"> | string
    rating?: IntFilter<"ArtikelDisukai"> | number
    artikel?: XOR<ArtikelScalarRelationFilter, ArtikelWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
  }

  export type ArtikelDisukaiOrderByWithRelationInput = {
    id_disukai?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    rating?: SortOrder
    artikel?: ArtikelOrderByWithRelationInput
    pengguna?: PenggunaOrderByWithRelationInput
  }

  export type ArtikelDisukaiWhereUniqueInput = Prisma.AtLeast<{
    id_disukai?: number
    id_artikel_id_pengguna?: ArtikelDisukaiId_artikelId_penggunaCompoundUniqueInput
    AND?: ArtikelDisukaiWhereInput | ArtikelDisukaiWhereInput[]
    OR?: ArtikelDisukaiWhereInput[]
    NOT?: ArtikelDisukaiWhereInput | ArtikelDisukaiWhereInput[]
    id_artikel?: StringFilter<"ArtikelDisukai"> | string
    id_pengguna?: StringFilter<"ArtikelDisukai"> | string
    rating?: IntFilter<"ArtikelDisukai"> | number
    artikel?: XOR<ArtikelScalarRelationFilter, ArtikelWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
  }, "id_disukai" | "id_artikel_id_pengguna">

  export type ArtikelDisukaiOrderByWithAggregationInput = {
    id_disukai?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    rating?: SortOrder
    _count?: ArtikelDisukaiCountOrderByAggregateInput
    _avg?: ArtikelDisukaiAvgOrderByAggregateInput
    _max?: ArtikelDisukaiMaxOrderByAggregateInput
    _min?: ArtikelDisukaiMinOrderByAggregateInput
    _sum?: ArtikelDisukaiSumOrderByAggregateInput
  }

  export type ArtikelDisukaiScalarWhereWithAggregatesInput = {
    AND?: ArtikelDisukaiScalarWhereWithAggregatesInput | ArtikelDisukaiScalarWhereWithAggregatesInput[]
    OR?: ArtikelDisukaiScalarWhereWithAggregatesInput[]
    NOT?: ArtikelDisukaiScalarWhereWithAggregatesInput | ArtikelDisukaiScalarWhereWithAggregatesInput[]
    id_disukai?: IntWithAggregatesFilter<"ArtikelDisukai"> | number
    id_artikel?: StringWithAggregatesFilter<"ArtikelDisukai"> | string
    id_pengguna?: StringWithAggregatesFilter<"ArtikelDisukai"> | string
    rating?: IntWithAggregatesFilter<"ArtikelDisukai"> | number
  }

  export type KomentarArtikelWhereInput = {
    AND?: KomentarArtikelWhereInput | KomentarArtikelWhereInput[]
    OR?: KomentarArtikelWhereInput[]
    NOT?: KomentarArtikelWhereInput | KomentarArtikelWhereInput[]
    id_komentar?: IntFilter<"KomentarArtikel"> | number
    id_artikel?: StringFilter<"KomentarArtikel"> | string
    id_pengguna?: StringFilter<"KomentarArtikel"> | string
    komentar?: StringFilter<"KomentarArtikel"> | string
    artikel?: XOR<ArtikelScalarRelationFilter, ArtikelWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
  }

  export type KomentarArtikelOrderByWithRelationInput = {
    id_komentar?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    komentar?: SortOrder
    artikel?: ArtikelOrderByWithRelationInput
    pengguna?: PenggunaOrderByWithRelationInput
  }

  export type KomentarArtikelWhereUniqueInput = Prisma.AtLeast<{
    id_komentar?: number
    id_artikel_id_pengguna?: KomentarArtikelId_artikelId_penggunaCompoundUniqueInput
    AND?: KomentarArtikelWhereInput | KomentarArtikelWhereInput[]
    OR?: KomentarArtikelWhereInput[]
    NOT?: KomentarArtikelWhereInput | KomentarArtikelWhereInput[]
    id_artikel?: StringFilter<"KomentarArtikel"> | string
    id_pengguna?: StringFilter<"KomentarArtikel"> | string
    komentar?: StringFilter<"KomentarArtikel"> | string
    artikel?: XOR<ArtikelScalarRelationFilter, ArtikelWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
  }, "id_komentar" | "id_artikel_id_pengguna">

  export type KomentarArtikelOrderByWithAggregationInput = {
    id_komentar?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    komentar?: SortOrder
    _count?: KomentarArtikelCountOrderByAggregateInput
    _avg?: KomentarArtikelAvgOrderByAggregateInput
    _max?: KomentarArtikelMaxOrderByAggregateInput
    _min?: KomentarArtikelMinOrderByAggregateInput
    _sum?: KomentarArtikelSumOrderByAggregateInput
  }

  export type KomentarArtikelScalarWhereWithAggregatesInput = {
    AND?: KomentarArtikelScalarWhereWithAggregatesInput | KomentarArtikelScalarWhereWithAggregatesInput[]
    OR?: KomentarArtikelScalarWhereWithAggregatesInput[]
    NOT?: KomentarArtikelScalarWhereWithAggregatesInput | KomentarArtikelScalarWhereWithAggregatesInput[]
    id_komentar?: IntWithAggregatesFilter<"KomentarArtikel"> | number
    id_artikel?: StringWithAggregatesFilter<"KomentarArtikel"> | string
    id_pengguna?: StringWithAggregatesFilter<"KomentarArtikel"> | string
    komentar?: StringWithAggregatesFilter<"KomentarArtikel"> | string
  }

  export type WorkshopWhereInput = {
    AND?: WorkshopWhereInput | WorkshopWhereInput[]
    OR?: WorkshopWhereInput[]
    NOT?: WorkshopWhereInput | WorkshopWhereInput[]
    id_workshop?: StringFilter<"Workshop"> | string
    judul_workshop?: StringFilter<"Workshop"> | string
    tanggal_workshop?: DateTimeFilter<"Workshop"> | Date | string
    alaamt_lengkap_workshop?: StringFilter<"Workshop"> | string
    deskripsi_workshop?: StringFilter<"Workshop"> | string
    harga_workshop?: DecimalFilter<"Workshop"> | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFilter<"Workshop"> | number
    status_verifikasi?: BoolFilter<"Workshop"> | boolean
    lat_lokasi?: FloatFilter<"Workshop"> | number
    long_lokasi?: FloatFilter<"Workshop"> | number
    gambar_workshop?: StringFilter<"Workshop"> | string
    status_aktif?: BoolFilter<"Workshop"> | boolean
    id_facilitator?: StringFilter<"Workshop"> | string
    id_kabupaten?: IntFilter<"Workshop"> | number
    facilitator?: XOR<FacilitatorScalarRelationFilter, FacilitatorWhereInput>
    kabupaten?: XOR<KabupatenScalarRelationFilter, KabupatenWhereInput>
    pendaftaran?: WorkshopTerdaftarListRelationFilter
  }

  export type WorkshopOrderByWithRelationInput = {
    id_workshop?: SortOrder
    judul_workshop?: SortOrder
    tanggal_workshop?: SortOrder
    alaamt_lengkap_workshop?: SortOrder
    deskripsi_workshop?: SortOrder
    harga_workshop?: SortOrder
    kapasitas?: SortOrder
    status_verifikasi?: SortOrder
    lat_lokasi?: SortOrder
    long_lokasi?: SortOrder
    gambar_workshop?: SortOrder
    status_aktif?: SortOrder
    id_facilitator?: SortOrder
    id_kabupaten?: SortOrder
    facilitator?: FacilitatorOrderByWithRelationInput
    kabupaten?: KabupatenOrderByWithRelationInput
    pendaftaran?: WorkshopTerdaftarOrderByRelationAggregateInput
  }

  export type WorkshopWhereUniqueInput = Prisma.AtLeast<{
    id_workshop?: string
    AND?: WorkshopWhereInput | WorkshopWhereInput[]
    OR?: WorkshopWhereInput[]
    NOT?: WorkshopWhereInput | WorkshopWhereInput[]
    judul_workshop?: StringFilter<"Workshop"> | string
    tanggal_workshop?: DateTimeFilter<"Workshop"> | Date | string
    alaamt_lengkap_workshop?: StringFilter<"Workshop"> | string
    deskripsi_workshop?: StringFilter<"Workshop"> | string
    harga_workshop?: DecimalFilter<"Workshop"> | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFilter<"Workshop"> | number
    status_verifikasi?: BoolFilter<"Workshop"> | boolean
    lat_lokasi?: FloatFilter<"Workshop"> | number
    long_lokasi?: FloatFilter<"Workshop"> | number
    gambar_workshop?: StringFilter<"Workshop"> | string
    status_aktif?: BoolFilter<"Workshop"> | boolean
    id_facilitator?: StringFilter<"Workshop"> | string
    id_kabupaten?: IntFilter<"Workshop"> | number
    facilitator?: XOR<FacilitatorScalarRelationFilter, FacilitatorWhereInput>
    kabupaten?: XOR<KabupatenScalarRelationFilter, KabupatenWhereInput>
    pendaftaran?: WorkshopTerdaftarListRelationFilter
  }, "id_workshop">

  export type WorkshopOrderByWithAggregationInput = {
    id_workshop?: SortOrder
    judul_workshop?: SortOrder
    tanggal_workshop?: SortOrder
    alaamt_lengkap_workshop?: SortOrder
    deskripsi_workshop?: SortOrder
    harga_workshop?: SortOrder
    kapasitas?: SortOrder
    status_verifikasi?: SortOrder
    lat_lokasi?: SortOrder
    long_lokasi?: SortOrder
    gambar_workshop?: SortOrder
    status_aktif?: SortOrder
    id_facilitator?: SortOrder
    id_kabupaten?: SortOrder
    _count?: WorkshopCountOrderByAggregateInput
    _avg?: WorkshopAvgOrderByAggregateInput
    _max?: WorkshopMaxOrderByAggregateInput
    _min?: WorkshopMinOrderByAggregateInput
    _sum?: WorkshopSumOrderByAggregateInput
  }

  export type WorkshopScalarWhereWithAggregatesInput = {
    AND?: WorkshopScalarWhereWithAggregatesInput | WorkshopScalarWhereWithAggregatesInput[]
    OR?: WorkshopScalarWhereWithAggregatesInput[]
    NOT?: WorkshopScalarWhereWithAggregatesInput | WorkshopScalarWhereWithAggregatesInput[]
    id_workshop?: StringWithAggregatesFilter<"Workshop"> | string
    judul_workshop?: StringWithAggregatesFilter<"Workshop"> | string
    tanggal_workshop?: DateTimeWithAggregatesFilter<"Workshop"> | Date | string
    alaamt_lengkap_workshop?: StringWithAggregatesFilter<"Workshop"> | string
    deskripsi_workshop?: StringWithAggregatesFilter<"Workshop"> | string
    harga_workshop?: DecimalWithAggregatesFilter<"Workshop"> | Decimal | DecimalJsLike | number | string
    kapasitas?: IntWithAggregatesFilter<"Workshop"> | number
    status_verifikasi?: BoolWithAggregatesFilter<"Workshop"> | boolean
    lat_lokasi?: FloatWithAggregatesFilter<"Workshop"> | number
    long_lokasi?: FloatWithAggregatesFilter<"Workshop"> | number
    gambar_workshop?: StringWithAggregatesFilter<"Workshop"> | string
    status_aktif?: BoolWithAggregatesFilter<"Workshop"> | boolean
    id_facilitator?: StringWithAggregatesFilter<"Workshop"> | string
    id_kabupaten?: IntWithAggregatesFilter<"Workshop"> | number
  }

  export type WorkshopTerdaftarWhereInput = {
    AND?: WorkshopTerdaftarWhereInput | WorkshopTerdaftarWhereInput[]
    OR?: WorkshopTerdaftarWhereInput[]
    NOT?: WorkshopTerdaftarWhereInput | WorkshopTerdaftarWhereInput[]
    id_pendaftaran?: IntFilter<"WorkshopTerdaftar"> | number
    nama_peserta?: StringFilter<"WorkshopTerdaftar"> | string
    email_peserta?: StringFilter<"WorkshopTerdaftar"> | string
    nomor_telepon_peserta?: StringFilter<"WorkshopTerdaftar"> | string
    tanggal_pendaftaran?: DateTimeFilter<"WorkshopTerdaftar"> | Date | string
    status_pembayaran?: StringFilter<"WorkshopTerdaftar"> | string
    nomor_tiket?: StringNullableFilter<"WorkshopTerdaftar"> | string | null
    id_pengguna?: StringFilter<"WorkshopTerdaftar"> | string
    id_workshop?: StringFilter<"WorkshopTerdaftar"> | string
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
  }

  export type WorkshopTerdaftarOrderByWithRelationInput = {
    id_pendaftaran?: SortOrder
    nama_peserta?: SortOrder
    email_peserta?: SortOrder
    nomor_telepon_peserta?: SortOrder
    tanggal_pendaftaran?: SortOrder
    status_pembayaran?: SortOrder
    nomor_tiket?: SortOrderInput | SortOrder
    id_pengguna?: SortOrder
    id_workshop?: SortOrder
    pengguna?: PenggunaOrderByWithRelationInput
    workshop?: WorkshopOrderByWithRelationInput
  }

  export type WorkshopTerdaftarWhereUniqueInput = Prisma.AtLeast<{
    id_pendaftaran?: number
    nomor_tiket?: string
    AND?: WorkshopTerdaftarWhereInput | WorkshopTerdaftarWhereInput[]
    OR?: WorkshopTerdaftarWhereInput[]
    NOT?: WorkshopTerdaftarWhereInput | WorkshopTerdaftarWhereInput[]
    nama_peserta?: StringFilter<"WorkshopTerdaftar"> | string
    email_peserta?: StringFilter<"WorkshopTerdaftar"> | string
    nomor_telepon_peserta?: StringFilter<"WorkshopTerdaftar"> | string
    tanggal_pendaftaran?: DateTimeFilter<"WorkshopTerdaftar"> | Date | string
    status_pembayaran?: StringFilter<"WorkshopTerdaftar"> | string
    id_pengguna?: StringFilter<"WorkshopTerdaftar"> | string
    id_workshop?: StringFilter<"WorkshopTerdaftar"> | string
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
    workshop?: XOR<WorkshopScalarRelationFilter, WorkshopWhereInput>
  }, "id_pendaftaran" | "nomor_tiket">

  export type WorkshopTerdaftarOrderByWithAggregationInput = {
    id_pendaftaran?: SortOrder
    nama_peserta?: SortOrder
    email_peserta?: SortOrder
    nomor_telepon_peserta?: SortOrder
    tanggal_pendaftaran?: SortOrder
    status_pembayaran?: SortOrder
    nomor_tiket?: SortOrderInput | SortOrder
    id_pengguna?: SortOrder
    id_workshop?: SortOrder
    _count?: WorkshopTerdaftarCountOrderByAggregateInput
    _avg?: WorkshopTerdaftarAvgOrderByAggregateInput
    _max?: WorkshopTerdaftarMaxOrderByAggregateInput
    _min?: WorkshopTerdaftarMinOrderByAggregateInput
    _sum?: WorkshopTerdaftarSumOrderByAggregateInput
  }

  export type WorkshopTerdaftarScalarWhereWithAggregatesInput = {
    AND?: WorkshopTerdaftarScalarWhereWithAggregatesInput | WorkshopTerdaftarScalarWhereWithAggregatesInput[]
    OR?: WorkshopTerdaftarScalarWhereWithAggregatesInput[]
    NOT?: WorkshopTerdaftarScalarWhereWithAggregatesInput | WorkshopTerdaftarScalarWhereWithAggregatesInput[]
    id_pendaftaran?: IntWithAggregatesFilter<"WorkshopTerdaftar"> | number
    nama_peserta?: StringWithAggregatesFilter<"WorkshopTerdaftar"> | string
    email_peserta?: StringWithAggregatesFilter<"WorkshopTerdaftar"> | string
    nomor_telepon_peserta?: StringWithAggregatesFilter<"WorkshopTerdaftar"> | string
    tanggal_pendaftaran?: DateTimeWithAggregatesFilter<"WorkshopTerdaftar"> | Date | string
    status_pembayaran?: StringWithAggregatesFilter<"WorkshopTerdaftar"> | string
    nomor_tiket?: StringNullableWithAggregatesFilter<"WorkshopTerdaftar"> | string | null
    id_pengguna?: StringWithAggregatesFilter<"WorkshopTerdaftar"> | string
    id_workshop?: StringWithAggregatesFilter<"WorkshopTerdaftar"> | string
  }

  export type kategoriTanamanWhereInput = {
    AND?: kategoriTanamanWhereInput | kategoriTanamanWhereInput[]
    OR?: kategoriTanamanWhereInput[]
    NOT?: kategoriTanamanWhereInput | kategoriTanamanWhereInput[]
    id_kategori_tanaman?: IntFilter<"kategoriTanaman"> | number
    nama_kategori_tanaman?: StringFilter<"kategoriTanaman"> | string
    tanaman?: TanamanListRelationFilter
  }

  export type kategoriTanamanOrderByWithRelationInput = {
    id_kategori_tanaman?: SortOrder
    nama_kategori_tanaman?: SortOrder
    tanaman?: TanamanOrderByRelationAggregateInput
  }

  export type kategoriTanamanWhereUniqueInput = Prisma.AtLeast<{
    id_kategori_tanaman?: number
    AND?: kategoriTanamanWhereInput | kategoriTanamanWhereInput[]
    OR?: kategoriTanamanWhereInput[]
    NOT?: kategoriTanamanWhereInput | kategoriTanamanWhereInput[]
    nama_kategori_tanaman?: StringFilter<"kategoriTanaman"> | string
    tanaman?: TanamanListRelationFilter
  }, "id_kategori_tanaman">

  export type kategoriTanamanOrderByWithAggregationInput = {
    id_kategori_tanaman?: SortOrder
    nama_kategori_tanaman?: SortOrder
    _count?: kategoriTanamanCountOrderByAggregateInput
    _avg?: kategoriTanamanAvgOrderByAggregateInput
    _max?: kategoriTanamanMaxOrderByAggregateInput
    _min?: kategoriTanamanMinOrderByAggregateInput
    _sum?: kategoriTanamanSumOrderByAggregateInput
  }

  export type kategoriTanamanScalarWhereWithAggregatesInput = {
    AND?: kategoriTanamanScalarWhereWithAggregatesInput | kategoriTanamanScalarWhereWithAggregatesInput[]
    OR?: kategoriTanamanScalarWhereWithAggregatesInput[]
    NOT?: kategoriTanamanScalarWhereWithAggregatesInput | kategoriTanamanScalarWhereWithAggregatesInput[]
    id_kategori_tanaman?: IntWithAggregatesFilter<"kategoriTanaman"> | number
    nama_kategori_tanaman?: StringWithAggregatesFilter<"kategoriTanaman"> | string
  }

  export type TanamanWhereInput = {
    AND?: TanamanWhereInput | TanamanWhereInput[]
    OR?: TanamanWhereInput[]
    NOT?: TanamanWhereInput | TanamanWhereInput[]
    id_tanaman?: StringFilter<"Tanaman"> | string
    nama_tanaman?: StringFilter<"Tanaman"> | string
    nama_latin?: StringFilter<"Tanaman"> | string
    durasi_penanaman?: IntFilter<"Tanaman"> | number
    deskripsi_tanaman?: StringFilter<"Tanaman"> | string
    id_kategori_tanaman?: IntFilter<"Tanaman"> | number
    kategori?: XOR<KategoriTanamanScalarRelationFilter, kategoriTanamanWhereInput>
    instruksi_tanaman?: InstruksiTanamanListRelationFilter
    hari_penanaman?: HariPenanamanListRelationFilter
    tanaman_pengguna?: TanamanPenggunaListRelationFilter
  }

  export type TanamanOrderByWithRelationInput = {
    id_tanaman?: SortOrder
    nama_tanaman?: SortOrder
    nama_latin?: SortOrder
    durasi_penanaman?: SortOrder
    deskripsi_tanaman?: SortOrder
    id_kategori_tanaman?: SortOrder
    kategori?: kategoriTanamanOrderByWithRelationInput
    instruksi_tanaman?: InstruksiTanamanOrderByRelationAggregateInput
    hari_penanaman?: HariPenanamanOrderByRelationAggregateInput
    tanaman_pengguna?: TanamanPenggunaOrderByRelationAggregateInput
  }

  export type TanamanWhereUniqueInput = Prisma.AtLeast<{
    id_tanaman?: string
    AND?: TanamanWhereInput | TanamanWhereInput[]
    OR?: TanamanWhereInput[]
    NOT?: TanamanWhereInput | TanamanWhereInput[]
    nama_tanaman?: StringFilter<"Tanaman"> | string
    nama_latin?: StringFilter<"Tanaman"> | string
    durasi_penanaman?: IntFilter<"Tanaman"> | number
    deskripsi_tanaman?: StringFilter<"Tanaman"> | string
    id_kategori_tanaman?: IntFilter<"Tanaman"> | number
    kategori?: XOR<KategoriTanamanScalarRelationFilter, kategoriTanamanWhereInput>
    instruksi_tanaman?: InstruksiTanamanListRelationFilter
    hari_penanaman?: HariPenanamanListRelationFilter
    tanaman_pengguna?: TanamanPenggunaListRelationFilter
  }, "id_tanaman">

  export type TanamanOrderByWithAggregationInput = {
    id_tanaman?: SortOrder
    nama_tanaman?: SortOrder
    nama_latin?: SortOrder
    durasi_penanaman?: SortOrder
    deskripsi_tanaman?: SortOrder
    id_kategori_tanaman?: SortOrder
    _count?: TanamanCountOrderByAggregateInput
    _avg?: TanamanAvgOrderByAggregateInput
    _max?: TanamanMaxOrderByAggregateInput
    _min?: TanamanMinOrderByAggregateInput
    _sum?: TanamanSumOrderByAggregateInput
  }

  export type TanamanScalarWhereWithAggregatesInput = {
    AND?: TanamanScalarWhereWithAggregatesInput | TanamanScalarWhereWithAggregatesInput[]
    OR?: TanamanScalarWhereWithAggregatesInput[]
    NOT?: TanamanScalarWhereWithAggregatesInput | TanamanScalarWhereWithAggregatesInput[]
    id_tanaman?: StringWithAggregatesFilter<"Tanaman"> | string
    nama_tanaman?: StringWithAggregatesFilter<"Tanaman"> | string
    nama_latin?: StringWithAggregatesFilter<"Tanaman"> | string
    durasi_penanaman?: IntWithAggregatesFilter<"Tanaman"> | number
    deskripsi_tanaman?: StringWithAggregatesFilter<"Tanaman"> | string
    id_kategori_tanaman?: IntWithAggregatesFilter<"Tanaman"> | number
  }

  export type InstruksiTanamanWhereInput = {
    AND?: InstruksiTanamanWhereInput | InstruksiTanamanWhereInput[]
    OR?: InstruksiTanamanWhereInput[]
    NOT?: InstruksiTanamanWhereInput | InstruksiTanamanWhereInput[]
    id_instruksi?: IntFilter<"InstruksiTanaman"> | number
    instruksi?: StringFilter<"InstruksiTanaman"> | string
    id_tanaman?: StringFilter<"InstruksiTanaman"> | string
    tanaman?: XOR<TanamanScalarRelationFilter, TanamanWhereInput>
  }

  export type InstruksiTanamanOrderByWithRelationInput = {
    id_instruksi?: SortOrder
    instruksi?: SortOrder
    id_tanaman?: SortOrder
    tanaman?: TanamanOrderByWithRelationInput
  }

  export type InstruksiTanamanWhereUniqueInput = Prisma.AtLeast<{
    id_instruksi?: number
    AND?: InstruksiTanamanWhereInput | InstruksiTanamanWhereInput[]
    OR?: InstruksiTanamanWhereInput[]
    NOT?: InstruksiTanamanWhereInput | InstruksiTanamanWhereInput[]
    instruksi?: StringFilter<"InstruksiTanaman"> | string
    id_tanaman?: StringFilter<"InstruksiTanaman"> | string
    tanaman?: XOR<TanamanScalarRelationFilter, TanamanWhereInput>
  }, "id_instruksi">

  export type InstruksiTanamanOrderByWithAggregationInput = {
    id_instruksi?: SortOrder
    instruksi?: SortOrder
    id_tanaman?: SortOrder
    _count?: InstruksiTanamanCountOrderByAggregateInput
    _avg?: InstruksiTanamanAvgOrderByAggregateInput
    _max?: InstruksiTanamanMaxOrderByAggregateInput
    _min?: InstruksiTanamanMinOrderByAggregateInput
    _sum?: InstruksiTanamanSumOrderByAggregateInput
  }

  export type InstruksiTanamanScalarWhereWithAggregatesInput = {
    AND?: InstruksiTanamanScalarWhereWithAggregatesInput | InstruksiTanamanScalarWhereWithAggregatesInput[]
    OR?: InstruksiTanamanScalarWhereWithAggregatesInput[]
    NOT?: InstruksiTanamanScalarWhereWithAggregatesInput | InstruksiTanamanScalarWhereWithAggregatesInput[]
    id_instruksi?: IntWithAggregatesFilter<"InstruksiTanaman"> | number
    instruksi?: StringWithAggregatesFilter<"InstruksiTanaman"> | string
    id_tanaman?: StringWithAggregatesFilter<"InstruksiTanaman"> | string
  }

  export type HariPenanamanWhereInput = {
    AND?: HariPenanamanWhereInput | HariPenanamanWhereInput[]
    OR?: HariPenanamanWhereInput[]
    NOT?: HariPenanamanWhereInput | HariPenanamanWhereInput[]
    id_hari_penanaman?: IntFilter<"HariPenanaman"> | number
    jenis_tugas?: IntFilter<"HariPenanaman"> | number
    id_tanaman?: StringFilter<"HariPenanaman"> | string
    tanaman?: XOR<TanamanScalarRelationFilter, TanamanWhereInput>
    tugas_penanaman?: TugasPenanamanListRelationFilter
  }

  export type HariPenanamanOrderByWithRelationInput = {
    id_hari_penanaman?: SortOrder
    jenis_tugas?: SortOrder
    id_tanaman?: SortOrder
    tanaman?: TanamanOrderByWithRelationInput
    tugas_penanaman?: TugasPenanamanOrderByRelationAggregateInput
  }

  export type HariPenanamanWhereUniqueInput = Prisma.AtLeast<{
    id_hari_penanaman?: number
    AND?: HariPenanamanWhereInput | HariPenanamanWhereInput[]
    OR?: HariPenanamanWhereInput[]
    NOT?: HariPenanamanWhereInput | HariPenanamanWhereInput[]
    jenis_tugas?: IntFilter<"HariPenanaman"> | number
    id_tanaman?: StringFilter<"HariPenanaman"> | string
    tanaman?: XOR<TanamanScalarRelationFilter, TanamanWhereInput>
    tugas_penanaman?: TugasPenanamanListRelationFilter
  }, "id_hari_penanaman">

  export type HariPenanamanOrderByWithAggregationInput = {
    id_hari_penanaman?: SortOrder
    jenis_tugas?: SortOrder
    id_tanaman?: SortOrder
    _count?: HariPenanamanCountOrderByAggregateInput
    _avg?: HariPenanamanAvgOrderByAggregateInput
    _max?: HariPenanamanMaxOrderByAggregateInput
    _min?: HariPenanamanMinOrderByAggregateInput
    _sum?: HariPenanamanSumOrderByAggregateInput
  }

  export type HariPenanamanScalarWhereWithAggregatesInput = {
    AND?: HariPenanamanScalarWhereWithAggregatesInput | HariPenanamanScalarWhereWithAggregatesInput[]
    OR?: HariPenanamanScalarWhereWithAggregatesInput[]
    NOT?: HariPenanamanScalarWhereWithAggregatesInput | HariPenanamanScalarWhereWithAggregatesInput[]
    id_hari_penanaman?: IntWithAggregatesFilter<"HariPenanaman"> | number
    jenis_tugas?: IntWithAggregatesFilter<"HariPenanaman"> | number
    id_tanaman?: StringWithAggregatesFilter<"HariPenanaman"> | string
  }

  export type TugasPenanamanWhereInput = {
    AND?: TugasPenanamanWhereInput | TugasPenanamanWhereInput[]
    OR?: TugasPenanamanWhereInput[]
    NOT?: TugasPenanamanWhereInput | TugasPenanamanWhereInput[]
    id_tugas?: IntFilter<"TugasPenanaman"> | number
    nama_tugas?: StringFilter<"TugasPenanaman"> | string
    id_hari_penanaman?: IntFilter<"TugasPenanaman"> | number
    hari_penanaman?: XOR<HariPenanamanScalarRelationFilter, HariPenanamanWhereInput>
  }

  export type TugasPenanamanOrderByWithRelationInput = {
    id_tugas?: SortOrder
    nama_tugas?: SortOrder
    id_hari_penanaman?: SortOrder
    hari_penanaman?: HariPenanamanOrderByWithRelationInput
  }

  export type TugasPenanamanWhereUniqueInput = Prisma.AtLeast<{
    id_tugas?: number
    AND?: TugasPenanamanWhereInput | TugasPenanamanWhereInput[]
    OR?: TugasPenanamanWhereInput[]
    NOT?: TugasPenanamanWhereInput | TugasPenanamanWhereInput[]
    nama_tugas?: StringFilter<"TugasPenanaman"> | string
    id_hari_penanaman?: IntFilter<"TugasPenanaman"> | number
    hari_penanaman?: XOR<HariPenanamanScalarRelationFilter, HariPenanamanWhereInput>
  }, "id_tugas">

  export type TugasPenanamanOrderByWithAggregationInput = {
    id_tugas?: SortOrder
    nama_tugas?: SortOrder
    id_hari_penanaman?: SortOrder
    _count?: TugasPenanamanCountOrderByAggregateInput
    _avg?: TugasPenanamanAvgOrderByAggregateInput
    _max?: TugasPenanamanMaxOrderByAggregateInput
    _min?: TugasPenanamanMinOrderByAggregateInput
    _sum?: TugasPenanamanSumOrderByAggregateInput
  }

  export type TugasPenanamanScalarWhereWithAggregatesInput = {
    AND?: TugasPenanamanScalarWhereWithAggregatesInput | TugasPenanamanScalarWhereWithAggregatesInput[]
    OR?: TugasPenanamanScalarWhereWithAggregatesInput[]
    NOT?: TugasPenanamanScalarWhereWithAggregatesInput | TugasPenanamanScalarWhereWithAggregatesInput[]
    id_tugas?: IntWithAggregatesFilter<"TugasPenanaman"> | number
    nama_tugas?: StringWithAggregatesFilter<"TugasPenanaman"> | string
    id_hari_penanaman?: IntWithAggregatesFilter<"TugasPenanaman"> | number
  }

  export type TanamanPenggunaWhereInput = {
    AND?: TanamanPenggunaWhereInput | TanamanPenggunaWhereInput[]
    OR?: TanamanPenggunaWhereInput[]
    NOT?: TanamanPenggunaWhereInput | TanamanPenggunaWhereInput[]
    id_tanaman_pengguna?: StringFilter<"TanamanPengguna"> | string
    tanggal_penanaman?: DateTimeFilter<"TanamanPengguna"> | Date | string
    status_penanaman?: BoolFilter<"TanamanPengguna"> | boolean
    nama_tanaman?: StringFilter<"TanamanPengguna"> | string
    id_tanaman?: StringFilter<"TanamanPengguna"> | string
    id_pengguna?: StringFilter<"TanamanPengguna"> | string
    tanaman?: XOR<TanamanScalarRelationFilter, TanamanWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
    hari_tanaman?: HariTanamanPenggunaListRelationFilter
  }

  export type TanamanPenggunaOrderByWithRelationInput = {
    id_tanaman_pengguna?: SortOrder
    tanggal_penanaman?: SortOrder
    status_penanaman?: SortOrder
    nama_tanaman?: SortOrder
    id_tanaman?: SortOrder
    id_pengguna?: SortOrder
    tanaman?: TanamanOrderByWithRelationInput
    pengguna?: PenggunaOrderByWithRelationInput
    hari_tanaman?: HariTanamanPenggunaOrderByRelationAggregateInput
  }

  export type TanamanPenggunaWhereUniqueInput = Prisma.AtLeast<{
    id_tanaman_pengguna?: string
    AND?: TanamanPenggunaWhereInput | TanamanPenggunaWhereInput[]
    OR?: TanamanPenggunaWhereInput[]
    NOT?: TanamanPenggunaWhereInput | TanamanPenggunaWhereInput[]
    tanggal_penanaman?: DateTimeFilter<"TanamanPengguna"> | Date | string
    status_penanaman?: BoolFilter<"TanamanPengguna"> | boolean
    nama_tanaman?: StringFilter<"TanamanPengguna"> | string
    id_tanaman?: StringFilter<"TanamanPengguna"> | string
    id_pengguna?: StringFilter<"TanamanPengguna"> | string
    tanaman?: XOR<TanamanScalarRelationFilter, TanamanWhereInput>
    pengguna?: XOR<PenggunaScalarRelationFilter, PenggunaWhereInput>
    hari_tanaman?: HariTanamanPenggunaListRelationFilter
  }, "id_tanaman_pengguna">

  export type TanamanPenggunaOrderByWithAggregationInput = {
    id_tanaman_pengguna?: SortOrder
    tanggal_penanaman?: SortOrder
    status_penanaman?: SortOrder
    nama_tanaman?: SortOrder
    id_tanaman?: SortOrder
    id_pengguna?: SortOrder
    _count?: TanamanPenggunaCountOrderByAggregateInput
    _max?: TanamanPenggunaMaxOrderByAggregateInput
    _min?: TanamanPenggunaMinOrderByAggregateInput
  }

  export type TanamanPenggunaScalarWhereWithAggregatesInput = {
    AND?: TanamanPenggunaScalarWhereWithAggregatesInput | TanamanPenggunaScalarWhereWithAggregatesInput[]
    OR?: TanamanPenggunaScalarWhereWithAggregatesInput[]
    NOT?: TanamanPenggunaScalarWhereWithAggregatesInput | TanamanPenggunaScalarWhereWithAggregatesInput[]
    id_tanaman_pengguna?: StringWithAggregatesFilter<"TanamanPengguna"> | string
    tanggal_penanaman?: DateTimeWithAggregatesFilter<"TanamanPengguna"> | Date | string
    status_penanaman?: BoolWithAggregatesFilter<"TanamanPengguna"> | boolean
    nama_tanaman?: StringWithAggregatesFilter<"TanamanPengguna"> | string
    id_tanaman?: StringWithAggregatesFilter<"TanamanPengguna"> | string
    id_pengguna?: StringWithAggregatesFilter<"TanamanPengguna"> | string
  }

  export type HariTanamanPenggunaWhereInput = {
    AND?: HariTanamanPenggunaWhereInput | HariTanamanPenggunaWhereInput[]
    OR?: HariTanamanPenggunaWhereInput[]
    NOT?: HariTanamanPenggunaWhereInput | HariTanamanPenggunaWhereInput[]
    id_hari_tanaman_pengguna?: IntFilter<"HariTanamanPengguna"> | number
    catatan?: StringFilter<"HariTanamanPengguna"> | string
    id_tanaman_pengguna?: StringFilter<"HariTanamanPengguna"> | string
    tugas_penanaman?: TugasPenanamanPenggunaListRelationFilter
    tanaman_pengguna?: XOR<TanamanPenggunaScalarRelationFilter, TanamanPenggunaWhereInput>
  }

  export type HariTanamanPenggunaOrderByWithRelationInput = {
    id_hari_tanaman_pengguna?: SortOrder
    catatan?: SortOrder
    id_tanaman_pengguna?: SortOrder
    tugas_penanaman?: TugasPenanamanPenggunaOrderByRelationAggregateInput
    tanaman_pengguna?: TanamanPenggunaOrderByWithRelationInput
  }

  export type HariTanamanPenggunaWhereUniqueInput = Prisma.AtLeast<{
    id_hari_tanaman_pengguna?: number
    AND?: HariTanamanPenggunaWhereInput | HariTanamanPenggunaWhereInput[]
    OR?: HariTanamanPenggunaWhereInput[]
    NOT?: HariTanamanPenggunaWhereInput | HariTanamanPenggunaWhereInput[]
    catatan?: StringFilter<"HariTanamanPengguna"> | string
    id_tanaman_pengguna?: StringFilter<"HariTanamanPengguna"> | string
    tugas_penanaman?: TugasPenanamanPenggunaListRelationFilter
    tanaman_pengguna?: XOR<TanamanPenggunaScalarRelationFilter, TanamanPenggunaWhereInput>
  }, "id_hari_tanaman_pengguna">

  export type HariTanamanPenggunaOrderByWithAggregationInput = {
    id_hari_tanaman_pengguna?: SortOrder
    catatan?: SortOrder
    id_tanaman_pengguna?: SortOrder
    _count?: HariTanamanPenggunaCountOrderByAggregateInput
    _avg?: HariTanamanPenggunaAvgOrderByAggregateInput
    _max?: HariTanamanPenggunaMaxOrderByAggregateInput
    _min?: HariTanamanPenggunaMinOrderByAggregateInput
    _sum?: HariTanamanPenggunaSumOrderByAggregateInput
  }

  export type HariTanamanPenggunaScalarWhereWithAggregatesInput = {
    AND?: HariTanamanPenggunaScalarWhereWithAggregatesInput | HariTanamanPenggunaScalarWhereWithAggregatesInput[]
    OR?: HariTanamanPenggunaScalarWhereWithAggregatesInput[]
    NOT?: HariTanamanPenggunaScalarWhereWithAggregatesInput | HariTanamanPenggunaScalarWhereWithAggregatesInput[]
    id_hari_tanaman_pengguna?: IntWithAggregatesFilter<"HariTanamanPengguna"> | number
    catatan?: StringWithAggregatesFilter<"HariTanamanPengguna"> | string
    id_tanaman_pengguna?: StringWithAggregatesFilter<"HariTanamanPengguna"> | string
  }

  export type TugasPenanamanPenggunaWhereInput = {
    AND?: TugasPenanamanPenggunaWhereInput | TugasPenanamanPenggunaWhereInput[]
    OR?: TugasPenanamanPenggunaWhereInput[]
    NOT?: TugasPenanamanPenggunaWhereInput | TugasPenanamanPenggunaWhereInput[]
    id_tugas_penanaman_pengguna?: IntFilter<"TugasPenanamanPengguna"> | number
    nama_tugas?: StringFilter<"TugasPenanamanPengguna"> | string
    id_hari_tanaman_pengguna?: IntFilter<"TugasPenanamanPengguna"> | number
    hari_tanaman?: XOR<HariTanamanPenggunaScalarRelationFilter, HariTanamanPenggunaWhereInput>
  }

  export type TugasPenanamanPenggunaOrderByWithRelationInput = {
    id_tugas_penanaman_pengguna?: SortOrder
    nama_tugas?: SortOrder
    id_hari_tanaman_pengguna?: SortOrder
    hari_tanaman?: HariTanamanPenggunaOrderByWithRelationInput
  }

  export type TugasPenanamanPenggunaWhereUniqueInput = Prisma.AtLeast<{
    id_tugas_penanaman_pengguna?: number
    AND?: TugasPenanamanPenggunaWhereInput | TugasPenanamanPenggunaWhereInput[]
    OR?: TugasPenanamanPenggunaWhereInput[]
    NOT?: TugasPenanamanPenggunaWhereInput | TugasPenanamanPenggunaWhereInput[]
    nama_tugas?: StringFilter<"TugasPenanamanPengguna"> | string
    id_hari_tanaman_pengguna?: IntFilter<"TugasPenanamanPengguna"> | number
    hari_tanaman?: XOR<HariTanamanPenggunaScalarRelationFilter, HariTanamanPenggunaWhereInput>
  }, "id_tugas_penanaman_pengguna">

  export type TugasPenanamanPenggunaOrderByWithAggregationInput = {
    id_tugas_penanaman_pengguna?: SortOrder
    nama_tugas?: SortOrder
    id_hari_tanaman_pengguna?: SortOrder
    _count?: TugasPenanamanPenggunaCountOrderByAggregateInput
    _avg?: TugasPenanamanPenggunaAvgOrderByAggregateInput
    _max?: TugasPenanamanPenggunaMaxOrderByAggregateInput
    _min?: TugasPenanamanPenggunaMinOrderByAggregateInput
    _sum?: TugasPenanamanPenggunaSumOrderByAggregateInput
  }

  export type TugasPenanamanPenggunaScalarWhereWithAggregatesInput = {
    AND?: TugasPenanamanPenggunaScalarWhereWithAggregatesInput | TugasPenanamanPenggunaScalarWhereWithAggregatesInput[]
    OR?: TugasPenanamanPenggunaScalarWhereWithAggregatesInput[]
    NOT?: TugasPenanamanPenggunaScalarWhereWithAggregatesInput | TugasPenanamanPenggunaScalarWhereWithAggregatesInput[]
    id_tugas_penanaman_pengguna?: IntWithAggregatesFilter<"TugasPenanamanPengguna"> | number
    nama_tugas?: StringWithAggregatesFilter<"TugasPenanamanPengguna"> | string
    id_hari_tanaman_pengguna?: IntWithAggregatesFilter<"TugasPenanamanPengguna"> | number
  }

  export type ProvinsiCreateInput = {
    nama_provinsi: string
    kabupaten?: KabupatenCreateNestedManyWithoutProvinsiInput
  }

  export type ProvinsiUncheckedCreateInput = {
    id_provinsi?: number
    nama_provinsi: string
    kabupaten?: KabupatenUncheckedCreateNestedManyWithoutProvinsiInput
  }

  export type ProvinsiUpdateInput = {
    nama_provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: KabupatenUpdateManyWithoutProvinsiNestedInput
  }

  export type ProvinsiUncheckedUpdateInput = {
    id_provinsi?: IntFieldUpdateOperationsInput | number
    nama_provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: KabupatenUncheckedUpdateManyWithoutProvinsiNestedInput
  }

  export type ProvinsiCreateManyInput = {
    id_provinsi?: number
    nama_provinsi: string
  }

  export type ProvinsiUpdateManyMutationInput = {
    nama_provinsi?: StringFieldUpdateOperationsInput | string
  }

  export type ProvinsiUncheckedUpdateManyInput = {
    id_provinsi?: IntFieldUpdateOperationsInput | number
    nama_provinsi?: StringFieldUpdateOperationsInput | string
  }

  export type KabupatenCreateInput = {
    nama_kabupaten: string
    type: string
    provinsi: ProvinsiCreateNestedOneWithoutKabupatenInput
    facilitators?: FacilitatorCreateNestedManyWithoutKabupatenInput
    workshop?: WorkshopCreateNestedManyWithoutKabupatenInput
  }

  export type KabupatenUncheckedCreateInput = {
    id_kabupaten?: number
    nama_kabupaten: string
    type: string
    id_provinsi: number
    facilitators?: FacilitatorUncheckedCreateNestedManyWithoutKabupatenInput
    workshop?: WorkshopUncheckedCreateNestedManyWithoutKabupatenInput
  }

  export type KabupatenUpdateInput = {
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provinsi?: ProvinsiUpdateOneRequiredWithoutKabupatenNestedInput
    facilitators?: FacilitatorUpdateManyWithoutKabupatenNestedInput
    workshop?: WorkshopUpdateManyWithoutKabupatenNestedInput
  }

  export type KabupatenUncheckedUpdateInput = {
    id_kabupaten?: IntFieldUpdateOperationsInput | number
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    id_provinsi?: IntFieldUpdateOperationsInput | number
    facilitators?: FacilitatorUncheckedUpdateManyWithoutKabupatenNestedInput
    workshop?: WorkshopUncheckedUpdateManyWithoutKabupatenNestedInput
  }

  export type KabupatenCreateManyInput = {
    id_kabupaten?: number
    nama_kabupaten: string
    type: string
    id_provinsi: number
  }

  export type KabupatenUpdateManyMutationInput = {
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type KabupatenUncheckedUpdateManyInput = {
    id_kabupaten?: IntFieldUpdateOperationsInput | number
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    id_provinsi?: IntFieldUpdateOperationsInput | number
  }

  export type PenggunaCreateInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaUncheckedCreateInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaUpdateInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutPenggunaNestedInput
  }

  export type PenggunaUncheckedUpdateInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutPenggunaNestedInput
  }

  export type PenggunaCreateManyInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
  }

  export type PenggunaUpdateManyMutationInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PenggunaUncheckedUpdateManyInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FacilitatorCreateInput = {
    id_facilitator?: string
    nama_facilitator: string
    email_facilitator: string
    nomor_telepon_facilitator: string
    password_facilitator: string
    tanggal_pembuatan_akun: Date | string
    alamat_lengkap_facilitator: string
    avatar?: string | null
    status_aktif?: boolean
    kabupaten: KabupatenCreateNestedOneWithoutFacilitatorsInput
    workshops?: WorkshopCreateNestedManyWithoutFacilitatorInput
  }

  export type FacilitatorUncheckedCreateInput = {
    id_facilitator?: string
    nama_facilitator: string
    email_facilitator: string
    nomor_telepon_facilitator: string
    password_facilitator: string
    tanggal_pembuatan_akun: Date | string
    alamat_lengkap_facilitator: string
    avatar?: string | null
    status_aktif?: boolean
    id_kabupaten: number
    workshops?: WorkshopUncheckedCreateNestedManyWithoutFacilitatorInput
  }

  export type FacilitatorUpdateInput = {
    id_facilitator?: StringFieldUpdateOperationsInput | string
    nama_facilitator?: StringFieldUpdateOperationsInput | string
    email_facilitator?: StringFieldUpdateOperationsInput | string
    nomor_telepon_facilitator?: StringFieldUpdateOperationsInput | string
    password_facilitator?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    alamat_lengkap_facilitator?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    kabupaten?: KabupatenUpdateOneRequiredWithoutFacilitatorsNestedInput
    workshops?: WorkshopUpdateManyWithoutFacilitatorNestedInput
  }

  export type FacilitatorUncheckedUpdateInput = {
    id_facilitator?: StringFieldUpdateOperationsInput | string
    nama_facilitator?: StringFieldUpdateOperationsInput | string
    email_facilitator?: StringFieldUpdateOperationsInput | string
    nomor_telepon_facilitator?: StringFieldUpdateOperationsInput | string
    password_facilitator?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    alamat_lengkap_facilitator?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kabupaten?: IntFieldUpdateOperationsInput | number
    workshops?: WorkshopUncheckedUpdateManyWithoutFacilitatorNestedInput
  }

  export type FacilitatorCreateManyInput = {
    id_facilitator?: string
    nama_facilitator: string
    email_facilitator: string
    nomor_telepon_facilitator: string
    password_facilitator: string
    tanggal_pembuatan_akun: Date | string
    alamat_lengkap_facilitator: string
    avatar?: string | null
    status_aktif?: boolean
    id_kabupaten: number
  }

  export type FacilitatorUpdateManyMutationInput = {
    id_facilitator?: StringFieldUpdateOperationsInput | string
    nama_facilitator?: StringFieldUpdateOperationsInput | string
    email_facilitator?: StringFieldUpdateOperationsInput | string
    nomor_telepon_facilitator?: StringFieldUpdateOperationsInput | string
    password_facilitator?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    alamat_lengkap_facilitator?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FacilitatorUncheckedUpdateManyInput = {
    id_facilitator?: StringFieldUpdateOperationsInput | string
    nama_facilitator?: StringFieldUpdateOperationsInput | string
    email_facilitator?: StringFieldUpdateOperationsInput | string
    nomor_telepon_facilitator?: StringFieldUpdateOperationsInput | string
    password_facilitator?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    alamat_lengkap_facilitator?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kabupaten?: IntFieldUpdateOperationsInput | number
  }

  export type AdminCreateInput = {
    id_admin?: string
    nama_depan_admin: string
    nama_belakang_admin: string
    email_admin: string
    password_admin: string
    tanggal_pembuatan_akun: Date | string
    avatar?: string | null
  }

  export type AdminUncheckedCreateInput = {
    id_admin?: string
    nama_depan_admin: string
    nama_belakang_admin: string
    email_admin: string
    password_admin: string
    tanggal_pembuatan_akun: Date | string
    avatar?: string | null
  }

  export type AdminUpdateInput = {
    id_admin?: StringFieldUpdateOperationsInput | string
    nama_depan_admin?: StringFieldUpdateOperationsInput | string
    nama_belakang_admin?: StringFieldUpdateOperationsInput | string
    email_admin?: StringFieldUpdateOperationsInput | string
    password_admin?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateInput = {
    id_admin?: StringFieldUpdateOperationsInput | string
    nama_depan_admin?: StringFieldUpdateOperationsInput | string
    nama_belakang_admin?: StringFieldUpdateOperationsInput | string
    email_admin?: StringFieldUpdateOperationsInput | string
    password_admin?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateManyInput = {
    id_admin?: string
    nama_depan_admin: string
    nama_belakang_admin: string
    email_admin: string
    password_admin: string
    tanggal_pembuatan_akun: Date | string
    avatar?: string | null
  }

  export type AdminUpdateManyMutationInput = {
    id_admin?: StringFieldUpdateOperationsInput | string
    nama_depan_admin?: StringFieldUpdateOperationsInput | string
    nama_belakang_admin?: StringFieldUpdateOperationsInput | string
    email_admin?: StringFieldUpdateOperationsInput | string
    password_admin?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminUncheckedUpdateManyInput = {
    id_admin?: StringFieldUpdateOperationsInput | string
    nama_depan_admin?: StringFieldUpdateOperationsInput | string
    nama_belakang_admin?: StringFieldUpdateOperationsInput | string
    email_admin?: StringFieldUpdateOperationsInput | string
    password_admin?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArtikelCreateInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    kategori: KategoriArtikelCreateNestedOneWithoutArtikelInput
    pengguna: PenggunaCreateNestedOneWithoutArtikelInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutArtikelInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelUncheckedCreateInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    id_kategori_artikel: number
    id_pengguna: string
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutArtikelInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelUpdateInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    kategori?: KategoriArtikelUpdateOneRequiredWithoutArtikelNestedInput
    pengguna?: PenggunaUpdateOneRequiredWithoutArtikelNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutArtikelNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutArtikelNestedInput
  }

  export type ArtikelUncheckedUpdateInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutArtikelNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutArtikelNestedInput
  }

  export type ArtikelCreateManyInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    id_kategori_artikel: number
    id_pengguna: string
  }

  export type ArtikelUpdateManyMutationInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArtikelUncheckedUpdateManyInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type KategoriArtikelCreateInput = {
    nama_kategori_artikel: string
    artikel?: ArtikelCreateNestedManyWithoutKategoriInput
  }

  export type KategoriArtikelUncheckedCreateInput = {
    id_kategori_artikel?: number
    nama_kategori_artikel: string
    artikel?: ArtikelUncheckedCreateNestedManyWithoutKategoriInput
  }

  export type KategoriArtikelUpdateInput = {
    nama_kategori_artikel?: StringFieldUpdateOperationsInput | string
    artikel?: ArtikelUpdateManyWithoutKategoriNestedInput
  }

  export type KategoriArtikelUncheckedUpdateInput = {
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
    nama_kategori_artikel?: StringFieldUpdateOperationsInput | string
    artikel?: ArtikelUncheckedUpdateManyWithoutKategoriNestedInput
  }

  export type KategoriArtikelCreateManyInput = {
    id_kategori_artikel?: number
    nama_kategori_artikel: string
  }

  export type KategoriArtikelUpdateManyMutationInput = {
    nama_kategori_artikel?: StringFieldUpdateOperationsInput | string
  }

  export type KategoriArtikelUncheckedUpdateManyInput = {
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
    nama_kategori_artikel?: StringFieldUpdateOperationsInput | string
  }

  export type ArtikelDisimpanCreateInput = {
    artikel: ArtikelCreateNestedOneWithoutArtikel_disimpanInput
    pengguna: PenggunaCreateNestedOneWithoutArtikel_disimpanInput
  }

  export type ArtikelDisimpanUncheckedCreateInput = {
    id_penyimpanan?: number
    id_artikel: string
    id_pengguna: string
  }

  export type ArtikelDisimpanUpdateInput = {
    artikel?: ArtikelUpdateOneRequiredWithoutArtikel_disimpanNestedInput
    pengguna?: PenggunaUpdateOneRequiredWithoutArtikel_disimpanNestedInput
  }

  export type ArtikelDisimpanUncheckedUpdateInput = {
    id_penyimpanan?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type ArtikelDisimpanCreateManyInput = {
    id_penyimpanan?: number
    id_artikel: string
    id_pengguna: string
  }

  export type ArtikelDisimpanUpdateManyMutationInput = {

  }

  export type ArtikelDisimpanUncheckedUpdateManyInput = {
    id_penyimpanan?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type ArtikelDisukaiCreateInput = {
    rating: number
    artikel: ArtikelCreateNestedOneWithoutArtikel_disukaiInput
    pengguna: PenggunaCreateNestedOneWithoutArtikel_disukaiInput
  }

  export type ArtikelDisukaiUncheckedCreateInput = {
    id_disukai?: number
    id_artikel: string
    id_pengguna: string
    rating: number
  }

  export type ArtikelDisukaiUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    artikel?: ArtikelUpdateOneRequiredWithoutArtikel_disukaiNestedInput
    pengguna?: PenggunaUpdateOneRequiredWithoutArtikel_disukaiNestedInput
  }

  export type ArtikelDisukaiUncheckedUpdateInput = {
    id_disukai?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type ArtikelDisukaiCreateManyInput = {
    id_disukai?: number
    id_artikel: string
    id_pengguna: string
    rating: number
  }

  export type ArtikelDisukaiUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type ArtikelDisukaiUncheckedUpdateManyInput = {
    id_disukai?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type KomentarArtikelCreateInput = {
    komentar: string
    artikel: ArtikelCreateNestedOneWithoutKomentar_artikelInput
    pengguna: PenggunaCreateNestedOneWithoutKomentar_artikelInput
  }

  export type KomentarArtikelUncheckedCreateInput = {
    id_komentar?: number
    id_artikel: string
    id_pengguna: string
    komentar: string
  }

  export type KomentarArtikelUpdateInput = {
    komentar?: StringFieldUpdateOperationsInput | string
    artikel?: ArtikelUpdateOneRequiredWithoutKomentar_artikelNestedInput
    pengguna?: PenggunaUpdateOneRequiredWithoutKomentar_artikelNestedInput
  }

  export type KomentarArtikelUncheckedUpdateInput = {
    id_komentar?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
    komentar?: StringFieldUpdateOperationsInput | string
  }

  export type KomentarArtikelCreateManyInput = {
    id_komentar?: number
    id_artikel: string
    id_pengguna: string
    komentar: string
  }

  export type KomentarArtikelUpdateManyMutationInput = {
    komentar?: StringFieldUpdateOperationsInput | string
  }

  export type KomentarArtikelUncheckedUpdateManyInput = {
    id_komentar?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
    komentar?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopCreateInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    facilitator: FacilitatorCreateNestedOneWithoutWorkshopsInput
    kabupaten: KabupatenCreateNestedOneWithoutWorkshopInput
    pendaftaran?: WorkshopTerdaftarCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    id_facilitator: string
    id_kabupaten: number
    pendaftaran?: WorkshopTerdaftarUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUpdateInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    facilitator?: FacilitatorUpdateOneRequiredWithoutWorkshopsNestedInput
    kabupaten?: KabupatenUpdateOneRequiredWithoutWorkshopNestedInput
    pendaftaran?: WorkshopTerdaftarUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_facilitator?: StringFieldUpdateOperationsInput | string
    id_kabupaten?: IntFieldUpdateOperationsInput | number
    pendaftaran?: WorkshopTerdaftarUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopCreateManyInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    id_facilitator: string
    id_kabupaten: number
  }

  export type WorkshopUpdateManyMutationInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkshopUncheckedUpdateManyInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_facilitator?: StringFieldUpdateOperationsInput | string
    id_kabupaten?: IntFieldUpdateOperationsInput | number
  }

  export type WorkshopTerdaftarCreateInput = {
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran?: Date | string
    status_pembayaran: string
    nomor_tiket?: string | null
    pengguna: PenggunaCreateNestedOneWithoutWorkshop_terdaftarInput
    workshop: WorkshopCreateNestedOneWithoutPendaftaranInput
  }

  export type WorkshopTerdaftarUncheckedCreateInput = {
    id_pendaftaran?: number
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran?: Date | string
    status_pembayaran: string
    nomor_tiket?: string | null
    id_pengguna: string
    id_workshop: string
  }

  export type WorkshopTerdaftarUpdateInput = {
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
    pengguna?: PenggunaUpdateOneRequiredWithoutWorkshop_terdaftarNestedInput
    workshop?: WorkshopUpdateOneRequiredWithoutPendaftaranNestedInput
  }

  export type WorkshopTerdaftarUncheckedUpdateInput = {
    id_pendaftaran?: IntFieldUpdateOperationsInput | number
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
    id_pengguna?: StringFieldUpdateOperationsInput | string
    id_workshop?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTerdaftarCreateManyInput = {
    id_pendaftaran?: number
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran?: Date | string
    status_pembayaran: string
    nomor_tiket?: string | null
    id_pengguna: string
    id_workshop: string
  }

  export type WorkshopTerdaftarUpdateManyMutationInput = {
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkshopTerdaftarUncheckedUpdateManyInput = {
    id_pendaftaran?: IntFieldUpdateOperationsInput | number
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
    id_pengguna?: StringFieldUpdateOperationsInput | string
    id_workshop?: StringFieldUpdateOperationsInput | string
  }

  export type kategoriTanamanCreateInput = {
    nama_kategori_tanaman: string
    tanaman?: TanamanCreateNestedManyWithoutKategoriInput
  }

  export type kategoriTanamanUncheckedCreateInput = {
    id_kategori_tanaman?: number
    nama_kategori_tanaman: string
    tanaman?: TanamanUncheckedCreateNestedManyWithoutKategoriInput
  }

  export type kategoriTanamanUpdateInput = {
    nama_kategori_tanaman?: StringFieldUpdateOperationsInput | string
    tanaman?: TanamanUpdateManyWithoutKategoriNestedInput
  }

  export type kategoriTanamanUncheckedUpdateInput = {
    id_kategori_tanaman?: IntFieldUpdateOperationsInput | number
    nama_kategori_tanaman?: StringFieldUpdateOperationsInput | string
    tanaman?: TanamanUncheckedUpdateManyWithoutKategoriNestedInput
  }

  export type kategoriTanamanCreateManyInput = {
    id_kategori_tanaman?: number
    nama_kategori_tanaman: string
  }

  export type kategoriTanamanUpdateManyMutationInput = {
    nama_kategori_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type kategoriTanamanUncheckedUpdateManyInput = {
    id_kategori_tanaman?: IntFieldUpdateOperationsInput | number
    nama_kategori_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type TanamanCreateInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    kategori: kategoriTanamanCreateNestedOneWithoutTanamanInput
    instruksi_tanaman?: InstruksiTanamanCreateNestedManyWithoutTanamanInput
    hari_penanaman?: HariPenanamanCreateNestedManyWithoutTanamanInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutTanamanInput
  }

  export type TanamanUncheckedCreateInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    id_kategori_tanaman: number
    instruksi_tanaman?: InstruksiTanamanUncheckedCreateNestedManyWithoutTanamanInput
    hari_penanaman?: HariPenanamanUncheckedCreateNestedManyWithoutTanamanInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutTanamanInput
  }

  export type TanamanUpdateInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    kategori?: kategoriTanamanUpdateOneRequiredWithoutTanamanNestedInput
    instruksi_tanaman?: InstruksiTanamanUpdateManyWithoutTanamanNestedInput
    hari_penanaman?: HariPenanamanUpdateManyWithoutTanamanNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutTanamanNestedInput
  }

  export type TanamanUncheckedUpdateInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    id_kategori_tanaman?: IntFieldUpdateOperationsInput | number
    instruksi_tanaman?: InstruksiTanamanUncheckedUpdateManyWithoutTanamanNestedInput
    hari_penanaman?: HariPenanamanUncheckedUpdateManyWithoutTanamanNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutTanamanNestedInput
  }

  export type TanamanCreateManyInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    id_kategori_tanaman: number
  }

  export type TanamanUpdateManyMutationInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type TanamanUncheckedUpdateManyInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    id_kategori_tanaman?: IntFieldUpdateOperationsInput | number
  }

  export type InstruksiTanamanCreateInput = {
    instruksi: string
    tanaman: TanamanCreateNestedOneWithoutInstruksi_tanamanInput
  }

  export type InstruksiTanamanUncheckedCreateInput = {
    id_instruksi?: number
    instruksi: string
    id_tanaman: string
  }

  export type InstruksiTanamanUpdateInput = {
    instruksi?: StringFieldUpdateOperationsInput | string
    tanaman?: TanamanUpdateOneRequiredWithoutInstruksi_tanamanNestedInput
  }

  export type InstruksiTanamanUncheckedUpdateInput = {
    id_instruksi?: IntFieldUpdateOperationsInput | number
    instruksi?: StringFieldUpdateOperationsInput | string
    id_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type InstruksiTanamanCreateManyInput = {
    id_instruksi?: number
    instruksi: string
    id_tanaman: string
  }

  export type InstruksiTanamanUpdateManyMutationInput = {
    instruksi?: StringFieldUpdateOperationsInput | string
  }

  export type InstruksiTanamanUncheckedUpdateManyInput = {
    id_instruksi?: IntFieldUpdateOperationsInput | number
    instruksi?: StringFieldUpdateOperationsInput | string
    id_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type HariPenanamanCreateInput = {
    jenis_tugas: number
    tanaman: TanamanCreateNestedOneWithoutHari_penanamanInput
    tugas_penanaman?: TugasPenanamanCreateNestedManyWithoutHari_penanamanInput
  }

  export type HariPenanamanUncheckedCreateInput = {
    id_hari_penanaman?: number
    jenis_tugas: number
    id_tanaman: string
    tugas_penanaman?: TugasPenanamanUncheckedCreateNestedManyWithoutHari_penanamanInput
  }

  export type HariPenanamanUpdateInput = {
    jenis_tugas?: IntFieldUpdateOperationsInput | number
    tanaman?: TanamanUpdateOneRequiredWithoutHari_penanamanNestedInput
    tugas_penanaman?: TugasPenanamanUpdateManyWithoutHari_penanamanNestedInput
  }

  export type HariPenanamanUncheckedUpdateInput = {
    id_hari_penanaman?: IntFieldUpdateOperationsInput | number
    jenis_tugas?: IntFieldUpdateOperationsInput | number
    id_tanaman?: StringFieldUpdateOperationsInput | string
    tugas_penanaman?: TugasPenanamanUncheckedUpdateManyWithoutHari_penanamanNestedInput
  }

  export type HariPenanamanCreateManyInput = {
    id_hari_penanaman?: number
    jenis_tugas: number
    id_tanaman: string
  }

  export type HariPenanamanUpdateManyMutationInput = {
    jenis_tugas?: IntFieldUpdateOperationsInput | number
  }

  export type HariPenanamanUncheckedUpdateManyInput = {
    id_hari_penanaman?: IntFieldUpdateOperationsInput | number
    jenis_tugas?: IntFieldUpdateOperationsInput | number
    id_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanCreateInput = {
    nama_tugas: string
    hari_penanaman: HariPenanamanCreateNestedOneWithoutTugas_penanamanInput
  }

  export type TugasPenanamanUncheckedCreateInput = {
    id_tugas?: number
    nama_tugas: string
    id_hari_penanaman: number
  }

  export type TugasPenanamanUpdateInput = {
    nama_tugas?: StringFieldUpdateOperationsInput | string
    hari_penanaman?: HariPenanamanUpdateOneRequiredWithoutTugas_penanamanNestedInput
  }

  export type TugasPenanamanUncheckedUpdateInput = {
    id_tugas?: IntFieldUpdateOperationsInput | number
    nama_tugas?: StringFieldUpdateOperationsInput | string
    id_hari_penanaman?: IntFieldUpdateOperationsInput | number
  }

  export type TugasPenanamanCreateManyInput = {
    id_tugas?: number
    nama_tugas: string
    id_hari_penanaman: number
  }

  export type TugasPenanamanUpdateManyMutationInput = {
    nama_tugas?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanUncheckedUpdateManyInput = {
    id_tugas?: IntFieldUpdateOperationsInput | number
    nama_tugas?: StringFieldUpdateOperationsInput | string
    id_hari_penanaman?: IntFieldUpdateOperationsInput | number
  }

  export type TanamanPenggunaCreateInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    tanaman: TanamanCreateNestedOneWithoutTanaman_penggunaInput
    pengguna: PenggunaCreateNestedOneWithoutTanaman_penggunaInput
    hari_tanaman?: HariTanamanPenggunaCreateNestedManyWithoutTanaman_penggunaInput
  }

  export type TanamanPenggunaUncheckedCreateInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    id_tanaman: string
    id_pengguna: string
    hari_tanaman?: HariTanamanPenggunaUncheckedCreateNestedManyWithoutTanaman_penggunaInput
  }

  export type TanamanPenggunaUpdateInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    tanaman?: TanamanUpdateOneRequiredWithoutTanaman_penggunaNestedInput
    pengguna?: PenggunaUpdateOneRequiredWithoutTanaman_penggunaNestedInput
    hari_tanaman?: HariTanamanPenggunaUpdateManyWithoutTanaman_penggunaNestedInput
  }

  export type TanamanPenggunaUncheckedUpdateInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    id_tanaman?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
    hari_tanaman?: HariTanamanPenggunaUncheckedUpdateManyWithoutTanaman_penggunaNestedInput
  }

  export type TanamanPenggunaCreateManyInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    id_tanaman: string
    id_pengguna: string
  }

  export type TanamanPenggunaUpdateManyMutationInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type TanamanPenggunaUncheckedUpdateManyInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    id_tanaman?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type HariTanamanPenggunaCreateInput = {
    catatan: string
    tugas_penanaman?: TugasPenanamanPenggunaCreateNestedManyWithoutHari_tanamanInput
    tanaman_pengguna: TanamanPenggunaCreateNestedOneWithoutHari_tanamanInput
  }

  export type HariTanamanPenggunaUncheckedCreateInput = {
    id_hari_tanaman_pengguna?: number
    catatan: string
    id_tanaman_pengguna: string
    tugas_penanaman?: TugasPenanamanPenggunaUncheckedCreateNestedManyWithoutHari_tanamanInput
  }

  export type HariTanamanPenggunaUpdateInput = {
    catatan?: StringFieldUpdateOperationsInput | string
    tugas_penanaman?: TugasPenanamanPenggunaUpdateManyWithoutHari_tanamanNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateOneRequiredWithoutHari_tanamanNestedInput
  }

  export type HariTanamanPenggunaUncheckedUpdateInput = {
    id_hari_tanaman_pengguna?: IntFieldUpdateOperationsInput | number
    catatan?: StringFieldUpdateOperationsInput | string
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tugas_penanaman?: TugasPenanamanPenggunaUncheckedUpdateManyWithoutHari_tanamanNestedInput
  }

  export type HariTanamanPenggunaCreateManyInput = {
    id_hari_tanaman_pengguna?: number
    catatan: string
    id_tanaman_pengguna: string
  }

  export type HariTanamanPenggunaUpdateManyMutationInput = {
    catatan?: StringFieldUpdateOperationsInput | string
  }

  export type HariTanamanPenggunaUncheckedUpdateManyInput = {
    id_hari_tanaman_pengguna?: IntFieldUpdateOperationsInput | number
    catatan?: StringFieldUpdateOperationsInput | string
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanPenggunaCreateInput = {
    nama_tugas: string
    hari_tanaman: HariTanamanPenggunaCreateNestedOneWithoutTugas_penanamanInput
  }

  export type TugasPenanamanPenggunaUncheckedCreateInput = {
    id_tugas_penanaman_pengguna?: number
    nama_tugas: string
    id_hari_tanaman_pengguna: number
  }

  export type TugasPenanamanPenggunaUpdateInput = {
    nama_tugas?: StringFieldUpdateOperationsInput | string
    hari_tanaman?: HariTanamanPenggunaUpdateOneRequiredWithoutTugas_penanamanNestedInput
  }

  export type TugasPenanamanPenggunaUncheckedUpdateInput = {
    id_tugas_penanaman_pengguna?: IntFieldUpdateOperationsInput | number
    nama_tugas?: StringFieldUpdateOperationsInput | string
    id_hari_tanaman_pengguna?: IntFieldUpdateOperationsInput | number
  }

  export type TugasPenanamanPenggunaCreateManyInput = {
    id_tugas_penanaman_pengguna?: number
    nama_tugas: string
    id_hari_tanaman_pengguna: number
  }

  export type TugasPenanamanPenggunaUpdateManyMutationInput = {
    nama_tugas?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanPenggunaUncheckedUpdateManyInput = {
    id_tugas_penanaman_pengguna?: IntFieldUpdateOperationsInput | number
    nama_tugas?: StringFieldUpdateOperationsInput | string
    id_hari_tanaman_pengguna?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type KabupatenListRelationFilter = {
    every?: KabupatenWhereInput
    some?: KabupatenWhereInput
    none?: KabupatenWhereInput
  }

  export type KabupatenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProvinsiCountOrderByAggregateInput = {
    id_provinsi?: SortOrder
    nama_provinsi?: SortOrder
  }

  export type ProvinsiAvgOrderByAggregateInput = {
    id_provinsi?: SortOrder
  }

  export type ProvinsiMaxOrderByAggregateInput = {
    id_provinsi?: SortOrder
    nama_provinsi?: SortOrder
  }

  export type ProvinsiMinOrderByAggregateInput = {
    id_provinsi?: SortOrder
    nama_provinsi?: SortOrder
  }

  export type ProvinsiSumOrderByAggregateInput = {
    id_provinsi?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type ProvinsiScalarRelationFilter = {
    is?: ProvinsiWhereInput
    isNot?: ProvinsiWhereInput
  }

  export type FacilitatorListRelationFilter = {
    every?: FacilitatorWhereInput
    some?: FacilitatorWhereInput
    none?: FacilitatorWhereInput
  }

  export type WorkshopListRelationFilter = {
    every?: WorkshopWhereInput
    some?: WorkshopWhereInput
    none?: WorkshopWhereInput
  }

  export type FacilitatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkshopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KabupatenCountOrderByAggregateInput = {
    id_kabupaten?: SortOrder
    nama_kabupaten?: SortOrder
    type?: SortOrder
    id_provinsi?: SortOrder
  }

  export type KabupatenAvgOrderByAggregateInput = {
    id_kabupaten?: SortOrder
    id_provinsi?: SortOrder
  }

  export type KabupatenMaxOrderByAggregateInput = {
    id_kabupaten?: SortOrder
    nama_kabupaten?: SortOrder
    type?: SortOrder
    id_provinsi?: SortOrder
  }

  export type KabupatenMinOrderByAggregateInput = {
    id_kabupaten?: SortOrder
    nama_kabupaten?: SortOrder
    type?: SortOrder
    id_provinsi?: SortOrder
  }

  export type KabupatenSumOrderByAggregateInput = {
    id_kabupaten?: SortOrder
    id_provinsi?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type WorkshopTerdaftarListRelationFilter = {
    every?: WorkshopTerdaftarWhereInput
    some?: WorkshopTerdaftarWhereInput
    none?: WorkshopTerdaftarWhereInput
  }

  export type ArtikelListRelationFilter = {
    every?: ArtikelWhereInput
    some?: ArtikelWhereInput
    none?: ArtikelWhereInput
  }

  export type ArtikelDisimpanListRelationFilter = {
    every?: ArtikelDisimpanWhereInput
    some?: ArtikelDisimpanWhereInput
    none?: ArtikelDisimpanWhereInput
  }

  export type ArtikelDisukaiListRelationFilter = {
    every?: ArtikelDisukaiWhereInput
    some?: ArtikelDisukaiWhereInput
    none?: ArtikelDisukaiWhereInput
  }

  export type KomentarArtikelListRelationFilter = {
    every?: KomentarArtikelWhereInput
    some?: KomentarArtikelWhereInput
    none?: KomentarArtikelWhereInput
  }

  export type TanamanPenggunaListRelationFilter = {
    every?: TanamanPenggunaWhereInput
    some?: TanamanPenggunaWhereInput
    none?: TanamanPenggunaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WorkshopTerdaftarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtikelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtikelDisimpanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtikelDisukaiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KomentarArtikelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TanamanPenggunaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PenggunaCountOrderByAggregateInput = {
    id_pengguna?: SortOrder
    nama_depan_pengguna?: SortOrder
    nama_belakang_pengguna?: SortOrder
    tanggal_lahir_pengguna?: SortOrder
    email_pengguna?: SortOrder
    nomor_telepon_pengguna?: SortOrder
    jenisKelamin?: SortOrder
    password_pengguna?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    kode_verifikasi?: SortOrder
    status_verfikasi?: SortOrder
    avatar?: SortOrder
    status_aktif?: SortOrder
  }

  export type PenggunaAvgOrderByAggregateInput = {
    jenisKelamin?: SortOrder
  }

  export type PenggunaMaxOrderByAggregateInput = {
    id_pengguna?: SortOrder
    nama_depan_pengguna?: SortOrder
    nama_belakang_pengguna?: SortOrder
    tanggal_lahir_pengguna?: SortOrder
    email_pengguna?: SortOrder
    nomor_telepon_pengguna?: SortOrder
    jenisKelamin?: SortOrder
    password_pengguna?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    kode_verifikasi?: SortOrder
    status_verfikasi?: SortOrder
    avatar?: SortOrder
    status_aktif?: SortOrder
  }

  export type PenggunaMinOrderByAggregateInput = {
    id_pengguna?: SortOrder
    nama_depan_pengguna?: SortOrder
    nama_belakang_pengguna?: SortOrder
    tanggal_lahir_pengguna?: SortOrder
    email_pengguna?: SortOrder
    nomor_telepon_pengguna?: SortOrder
    jenisKelamin?: SortOrder
    password_pengguna?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    kode_verifikasi?: SortOrder
    status_verfikasi?: SortOrder
    avatar?: SortOrder
    status_aktif?: SortOrder
  }

  export type PenggunaSumOrderByAggregateInput = {
    jenisKelamin?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type KabupatenScalarRelationFilter = {
    is?: KabupatenWhereInput
    isNot?: KabupatenWhereInput
  }

  export type FacilitatorCountOrderByAggregateInput = {
    id_facilitator?: SortOrder
    nama_facilitator?: SortOrder
    email_facilitator?: SortOrder
    nomor_telepon_facilitator?: SortOrder
    password_facilitator?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    alamat_lengkap_facilitator?: SortOrder
    avatar?: SortOrder
    status_aktif?: SortOrder
    id_kabupaten?: SortOrder
  }

  export type FacilitatorAvgOrderByAggregateInput = {
    id_kabupaten?: SortOrder
  }

  export type FacilitatorMaxOrderByAggregateInput = {
    id_facilitator?: SortOrder
    nama_facilitator?: SortOrder
    email_facilitator?: SortOrder
    nomor_telepon_facilitator?: SortOrder
    password_facilitator?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    alamat_lengkap_facilitator?: SortOrder
    avatar?: SortOrder
    status_aktif?: SortOrder
    id_kabupaten?: SortOrder
  }

  export type FacilitatorMinOrderByAggregateInput = {
    id_facilitator?: SortOrder
    nama_facilitator?: SortOrder
    email_facilitator?: SortOrder
    nomor_telepon_facilitator?: SortOrder
    password_facilitator?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    alamat_lengkap_facilitator?: SortOrder
    avatar?: SortOrder
    status_aktif?: SortOrder
    id_kabupaten?: SortOrder
  }

  export type FacilitatorSumOrderByAggregateInput = {
    id_kabupaten?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id_admin?: SortOrder
    nama_depan_admin?: SortOrder
    nama_belakang_admin?: SortOrder
    email_admin?: SortOrder
    password_admin?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    avatar?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id_admin?: SortOrder
    nama_depan_admin?: SortOrder
    nama_belakang_admin?: SortOrder
    email_admin?: SortOrder
    password_admin?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    avatar?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id_admin?: SortOrder
    nama_depan_admin?: SortOrder
    nama_belakang_admin?: SortOrder
    email_admin?: SortOrder
    password_admin?: SortOrder
    tanggal_pembuatan_akun?: SortOrder
    avatar?: SortOrder
  }

  export type EnumStatusArtikelFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusArtikel | EnumStatusArtikelFieldRefInput<$PrismaModel>
    in?: $Enums.StatusArtikel[] | ListEnumStatusArtikelFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusArtikel[] | ListEnumStatusArtikelFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusArtikelFilter<$PrismaModel> | $Enums.StatusArtikel
  }

  export type KategoriArtikelScalarRelationFilter = {
    is?: KategoriArtikelWhereInput
    isNot?: KategoriArtikelWhereInput
  }

  export type PenggunaScalarRelationFilter = {
    is?: PenggunaWhereInput
    isNot?: PenggunaWhereInput
  }

  export type ArtikelCountOrderByAggregateInput = {
    id_artikel?: SortOrder
    judul_artikel?: SortOrder
    tanggal_artikel?: SortOrder
    deskripsi_artikel?: SortOrder
    isi_artikel?: SortOrder
    status_artikel?: SortOrder
    status_verifikasi?: SortOrder
    gambar_artikel?: SortOrder
    status_aktif?: SortOrder
    id_kategori_artikel?: SortOrder
    id_pengguna?: SortOrder
  }

  export type ArtikelAvgOrderByAggregateInput = {
    id_kategori_artikel?: SortOrder
  }

  export type ArtikelMaxOrderByAggregateInput = {
    id_artikel?: SortOrder
    judul_artikel?: SortOrder
    tanggal_artikel?: SortOrder
    deskripsi_artikel?: SortOrder
    isi_artikel?: SortOrder
    status_artikel?: SortOrder
    status_verifikasi?: SortOrder
    gambar_artikel?: SortOrder
    status_aktif?: SortOrder
    id_kategori_artikel?: SortOrder
    id_pengguna?: SortOrder
  }

  export type ArtikelMinOrderByAggregateInput = {
    id_artikel?: SortOrder
    judul_artikel?: SortOrder
    tanggal_artikel?: SortOrder
    deskripsi_artikel?: SortOrder
    isi_artikel?: SortOrder
    status_artikel?: SortOrder
    status_verifikasi?: SortOrder
    gambar_artikel?: SortOrder
    status_aktif?: SortOrder
    id_kategori_artikel?: SortOrder
    id_pengguna?: SortOrder
  }

  export type ArtikelSumOrderByAggregateInput = {
    id_kategori_artikel?: SortOrder
  }

  export type EnumStatusArtikelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusArtikel | EnumStatusArtikelFieldRefInput<$PrismaModel>
    in?: $Enums.StatusArtikel[] | ListEnumStatusArtikelFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusArtikel[] | ListEnumStatusArtikelFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusArtikelWithAggregatesFilter<$PrismaModel> | $Enums.StatusArtikel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusArtikelFilter<$PrismaModel>
    _max?: NestedEnumStatusArtikelFilter<$PrismaModel>
  }

  export type KategoriArtikelCountOrderByAggregateInput = {
    id_kategori_artikel?: SortOrder
    nama_kategori_artikel?: SortOrder
  }

  export type KategoriArtikelAvgOrderByAggregateInput = {
    id_kategori_artikel?: SortOrder
  }

  export type KategoriArtikelMaxOrderByAggregateInput = {
    id_kategori_artikel?: SortOrder
    nama_kategori_artikel?: SortOrder
  }

  export type KategoriArtikelMinOrderByAggregateInput = {
    id_kategori_artikel?: SortOrder
    nama_kategori_artikel?: SortOrder
  }

  export type KategoriArtikelSumOrderByAggregateInput = {
    id_kategori_artikel?: SortOrder
  }

  export type ArtikelScalarRelationFilter = {
    is?: ArtikelWhereInput
    isNot?: ArtikelWhereInput
  }

  export type ArtikelDisimpanId_artikelId_penggunaCompoundUniqueInput = {
    id_artikel: string
    id_pengguna: string
  }

  export type ArtikelDisimpanCountOrderByAggregateInput = {
    id_penyimpanan?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
  }

  export type ArtikelDisimpanAvgOrderByAggregateInput = {
    id_penyimpanan?: SortOrder
  }

  export type ArtikelDisimpanMaxOrderByAggregateInput = {
    id_penyimpanan?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
  }

  export type ArtikelDisimpanMinOrderByAggregateInput = {
    id_penyimpanan?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
  }

  export type ArtikelDisimpanSumOrderByAggregateInput = {
    id_penyimpanan?: SortOrder
  }

  export type ArtikelDisukaiId_artikelId_penggunaCompoundUniqueInput = {
    id_artikel: string
    id_pengguna: string
  }

  export type ArtikelDisukaiCountOrderByAggregateInput = {
    id_disukai?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    rating?: SortOrder
  }

  export type ArtikelDisukaiAvgOrderByAggregateInput = {
    id_disukai?: SortOrder
    rating?: SortOrder
  }

  export type ArtikelDisukaiMaxOrderByAggregateInput = {
    id_disukai?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    rating?: SortOrder
  }

  export type ArtikelDisukaiMinOrderByAggregateInput = {
    id_disukai?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    rating?: SortOrder
  }

  export type ArtikelDisukaiSumOrderByAggregateInput = {
    id_disukai?: SortOrder
    rating?: SortOrder
  }

  export type KomentarArtikelId_artikelId_penggunaCompoundUniqueInput = {
    id_artikel: string
    id_pengguna: string
  }

  export type KomentarArtikelCountOrderByAggregateInput = {
    id_komentar?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    komentar?: SortOrder
  }

  export type KomentarArtikelAvgOrderByAggregateInput = {
    id_komentar?: SortOrder
  }

  export type KomentarArtikelMaxOrderByAggregateInput = {
    id_komentar?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    komentar?: SortOrder
  }

  export type KomentarArtikelMinOrderByAggregateInput = {
    id_komentar?: SortOrder
    id_artikel?: SortOrder
    id_pengguna?: SortOrder
    komentar?: SortOrder
  }

  export type KomentarArtikelSumOrderByAggregateInput = {
    id_komentar?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FacilitatorScalarRelationFilter = {
    is?: FacilitatorWhereInput
    isNot?: FacilitatorWhereInput
  }

  export type WorkshopCountOrderByAggregateInput = {
    id_workshop?: SortOrder
    judul_workshop?: SortOrder
    tanggal_workshop?: SortOrder
    alaamt_lengkap_workshop?: SortOrder
    deskripsi_workshop?: SortOrder
    harga_workshop?: SortOrder
    kapasitas?: SortOrder
    status_verifikasi?: SortOrder
    lat_lokasi?: SortOrder
    long_lokasi?: SortOrder
    gambar_workshop?: SortOrder
    status_aktif?: SortOrder
    id_facilitator?: SortOrder
    id_kabupaten?: SortOrder
  }

  export type WorkshopAvgOrderByAggregateInput = {
    harga_workshop?: SortOrder
    kapasitas?: SortOrder
    lat_lokasi?: SortOrder
    long_lokasi?: SortOrder
    id_kabupaten?: SortOrder
  }

  export type WorkshopMaxOrderByAggregateInput = {
    id_workshop?: SortOrder
    judul_workshop?: SortOrder
    tanggal_workshop?: SortOrder
    alaamt_lengkap_workshop?: SortOrder
    deskripsi_workshop?: SortOrder
    harga_workshop?: SortOrder
    kapasitas?: SortOrder
    status_verifikasi?: SortOrder
    lat_lokasi?: SortOrder
    long_lokasi?: SortOrder
    gambar_workshop?: SortOrder
    status_aktif?: SortOrder
    id_facilitator?: SortOrder
    id_kabupaten?: SortOrder
  }

  export type WorkshopMinOrderByAggregateInput = {
    id_workshop?: SortOrder
    judul_workshop?: SortOrder
    tanggal_workshop?: SortOrder
    alaamt_lengkap_workshop?: SortOrder
    deskripsi_workshop?: SortOrder
    harga_workshop?: SortOrder
    kapasitas?: SortOrder
    status_verifikasi?: SortOrder
    lat_lokasi?: SortOrder
    long_lokasi?: SortOrder
    gambar_workshop?: SortOrder
    status_aktif?: SortOrder
    id_facilitator?: SortOrder
    id_kabupaten?: SortOrder
  }

  export type WorkshopSumOrderByAggregateInput = {
    harga_workshop?: SortOrder
    kapasitas?: SortOrder
    lat_lokasi?: SortOrder
    long_lokasi?: SortOrder
    id_kabupaten?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type WorkshopScalarRelationFilter = {
    is?: WorkshopWhereInput
    isNot?: WorkshopWhereInput
  }

  export type WorkshopTerdaftarCountOrderByAggregateInput = {
    id_pendaftaran?: SortOrder
    nama_peserta?: SortOrder
    email_peserta?: SortOrder
    nomor_telepon_peserta?: SortOrder
    tanggal_pendaftaran?: SortOrder
    status_pembayaran?: SortOrder
    nomor_tiket?: SortOrder
    id_pengguna?: SortOrder
    id_workshop?: SortOrder
  }

  export type WorkshopTerdaftarAvgOrderByAggregateInput = {
    id_pendaftaran?: SortOrder
  }

  export type WorkshopTerdaftarMaxOrderByAggregateInput = {
    id_pendaftaran?: SortOrder
    nama_peserta?: SortOrder
    email_peserta?: SortOrder
    nomor_telepon_peserta?: SortOrder
    tanggal_pendaftaran?: SortOrder
    status_pembayaran?: SortOrder
    nomor_tiket?: SortOrder
    id_pengguna?: SortOrder
    id_workshop?: SortOrder
  }

  export type WorkshopTerdaftarMinOrderByAggregateInput = {
    id_pendaftaran?: SortOrder
    nama_peserta?: SortOrder
    email_peserta?: SortOrder
    nomor_telepon_peserta?: SortOrder
    tanggal_pendaftaran?: SortOrder
    status_pembayaran?: SortOrder
    nomor_tiket?: SortOrder
    id_pengguna?: SortOrder
    id_workshop?: SortOrder
  }

  export type WorkshopTerdaftarSumOrderByAggregateInput = {
    id_pendaftaran?: SortOrder
  }

  export type TanamanListRelationFilter = {
    every?: TanamanWhereInput
    some?: TanamanWhereInput
    none?: TanamanWhereInput
  }

  export type TanamanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kategoriTanamanCountOrderByAggregateInput = {
    id_kategori_tanaman?: SortOrder
    nama_kategori_tanaman?: SortOrder
  }

  export type kategoriTanamanAvgOrderByAggregateInput = {
    id_kategori_tanaman?: SortOrder
  }

  export type kategoriTanamanMaxOrderByAggregateInput = {
    id_kategori_tanaman?: SortOrder
    nama_kategori_tanaman?: SortOrder
  }

  export type kategoriTanamanMinOrderByAggregateInput = {
    id_kategori_tanaman?: SortOrder
    nama_kategori_tanaman?: SortOrder
  }

  export type kategoriTanamanSumOrderByAggregateInput = {
    id_kategori_tanaman?: SortOrder
  }

  export type KategoriTanamanScalarRelationFilter = {
    is?: kategoriTanamanWhereInput
    isNot?: kategoriTanamanWhereInput
  }

  export type InstruksiTanamanListRelationFilter = {
    every?: InstruksiTanamanWhereInput
    some?: InstruksiTanamanWhereInput
    none?: InstruksiTanamanWhereInput
  }

  export type HariPenanamanListRelationFilter = {
    every?: HariPenanamanWhereInput
    some?: HariPenanamanWhereInput
    none?: HariPenanamanWhereInput
  }

  export type InstruksiTanamanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HariPenanamanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TanamanCountOrderByAggregateInput = {
    id_tanaman?: SortOrder
    nama_tanaman?: SortOrder
    nama_latin?: SortOrder
    durasi_penanaman?: SortOrder
    deskripsi_tanaman?: SortOrder
    id_kategori_tanaman?: SortOrder
  }

  export type TanamanAvgOrderByAggregateInput = {
    durasi_penanaman?: SortOrder
    id_kategori_tanaman?: SortOrder
  }

  export type TanamanMaxOrderByAggregateInput = {
    id_tanaman?: SortOrder
    nama_tanaman?: SortOrder
    nama_latin?: SortOrder
    durasi_penanaman?: SortOrder
    deskripsi_tanaman?: SortOrder
    id_kategori_tanaman?: SortOrder
  }

  export type TanamanMinOrderByAggregateInput = {
    id_tanaman?: SortOrder
    nama_tanaman?: SortOrder
    nama_latin?: SortOrder
    durasi_penanaman?: SortOrder
    deskripsi_tanaman?: SortOrder
    id_kategori_tanaman?: SortOrder
  }

  export type TanamanSumOrderByAggregateInput = {
    durasi_penanaman?: SortOrder
    id_kategori_tanaman?: SortOrder
  }

  export type TanamanScalarRelationFilter = {
    is?: TanamanWhereInput
    isNot?: TanamanWhereInput
  }

  export type InstruksiTanamanCountOrderByAggregateInput = {
    id_instruksi?: SortOrder
    instruksi?: SortOrder
    id_tanaman?: SortOrder
  }

  export type InstruksiTanamanAvgOrderByAggregateInput = {
    id_instruksi?: SortOrder
  }

  export type InstruksiTanamanMaxOrderByAggregateInput = {
    id_instruksi?: SortOrder
    instruksi?: SortOrder
    id_tanaman?: SortOrder
  }

  export type InstruksiTanamanMinOrderByAggregateInput = {
    id_instruksi?: SortOrder
    instruksi?: SortOrder
    id_tanaman?: SortOrder
  }

  export type InstruksiTanamanSumOrderByAggregateInput = {
    id_instruksi?: SortOrder
  }

  export type TugasPenanamanListRelationFilter = {
    every?: TugasPenanamanWhereInput
    some?: TugasPenanamanWhereInput
    none?: TugasPenanamanWhereInput
  }

  export type TugasPenanamanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HariPenanamanCountOrderByAggregateInput = {
    id_hari_penanaman?: SortOrder
    jenis_tugas?: SortOrder
    id_tanaman?: SortOrder
  }

  export type HariPenanamanAvgOrderByAggregateInput = {
    id_hari_penanaman?: SortOrder
    jenis_tugas?: SortOrder
  }

  export type HariPenanamanMaxOrderByAggregateInput = {
    id_hari_penanaman?: SortOrder
    jenis_tugas?: SortOrder
    id_tanaman?: SortOrder
  }

  export type HariPenanamanMinOrderByAggregateInput = {
    id_hari_penanaman?: SortOrder
    jenis_tugas?: SortOrder
    id_tanaman?: SortOrder
  }

  export type HariPenanamanSumOrderByAggregateInput = {
    id_hari_penanaman?: SortOrder
    jenis_tugas?: SortOrder
  }

  export type HariPenanamanScalarRelationFilter = {
    is?: HariPenanamanWhereInput
    isNot?: HariPenanamanWhereInput
  }

  export type TugasPenanamanCountOrderByAggregateInput = {
    id_tugas?: SortOrder
    nama_tugas?: SortOrder
    id_hari_penanaman?: SortOrder
  }

  export type TugasPenanamanAvgOrderByAggregateInput = {
    id_tugas?: SortOrder
    id_hari_penanaman?: SortOrder
  }

  export type TugasPenanamanMaxOrderByAggregateInput = {
    id_tugas?: SortOrder
    nama_tugas?: SortOrder
    id_hari_penanaman?: SortOrder
  }

  export type TugasPenanamanMinOrderByAggregateInput = {
    id_tugas?: SortOrder
    nama_tugas?: SortOrder
    id_hari_penanaman?: SortOrder
  }

  export type TugasPenanamanSumOrderByAggregateInput = {
    id_tugas?: SortOrder
    id_hari_penanaman?: SortOrder
  }

  export type HariTanamanPenggunaListRelationFilter = {
    every?: HariTanamanPenggunaWhereInput
    some?: HariTanamanPenggunaWhereInput
    none?: HariTanamanPenggunaWhereInput
  }

  export type HariTanamanPenggunaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TanamanPenggunaCountOrderByAggregateInput = {
    id_tanaman_pengguna?: SortOrder
    tanggal_penanaman?: SortOrder
    status_penanaman?: SortOrder
    nama_tanaman?: SortOrder
    id_tanaman?: SortOrder
    id_pengguna?: SortOrder
  }

  export type TanamanPenggunaMaxOrderByAggregateInput = {
    id_tanaman_pengguna?: SortOrder
    tanggal_penanaman?: SortOrder
    status_penanaman?: SortOrder
    nama_tanaman?: SortOrder
    id_tanaman?: SortOrder
    id_pengguna?: SortOrder
  }

  export type TanamanPenggunaMinOrderByAggregateInput = {
    id_tanaman_pengguna?: SortOrder
    tanggal_penanaman?: SortOrder
    status_penanaman?: SortOrder
    nama_tanaman?: SortOrder
    id_tanaman?: SortOrder
    id_pengguna?: SortOrder
  }

  export type TugasPenanamanPenggunaListRelationFilter = {
    every?: TugasPenanamanPenggunaWhereInput
    some?: TugasPenanamanPenggunaWhereInput
    none?: TugasPenanamanPenggunaWhereInput
  }

  export type TanamanPenggunaScalarRelationFilter = {
    is?: TanamanPenggunaWhereInput
    isNot?: TanamanPenggunaWhereInput
  }

  export type TugasPenanamanPenggunaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HariTanamanPenggunaCountOrderByAggregateInput = {
    id_hari_tanaman_pengguna?: SortOrder
    catatan?: SortOrder
    id_tanaman_pengguna?: SortOrder
  }

  export type HariTanamanPenggunaAvgOrderByAggregateInput = {
    id_hari_tanaman_pengguna?: SortOrder
  }

  export type HariTanamanPenggunaMaxOrderByAggregateInput = {
    id_hari_tanaman_pengguna?: SortOrder
    catatan?: SortOrder
    id_tanaman_pengguna?: SortOrder
  }

  export type HariTanamanPenggunaMinOrderByAggregateInput = {
    id_hari_tanaman_pengguna?: SortOrder
    catatan?: SortOrder
    id_tanaman_pengguna?: SortOrder
  }

  export type HariTanamanPenggunaSumOrderByAggregateInput = {
    id_hari_tanaman_pengguna?: SortOrder
  }

  export type HariTanamanPenggunaScalarRelationFilter = {
    is?: HariTanamanPenggunaWhereInput
    isNot?: HariTanamanPenggunaWhereInput
  }

  export type TugasPenanamanPenggunaCountOrderByAggregateInput = {
    id_tugas_penanaman_pengguna?: SortOrder
    nama_tugas?: SortOrder
    id_hari_tanaman_pengguna?: SortOrder
  }

  export type TugasPenanamanPenggunaAvgOrderByAggregateInput = {
    id_tugas_penanaman_pengguna?: SortOrder
    id_hari_tanaman_pengguna?: SortOrder
  }

  export type TugasPenanamanPenggunaMaxOrderByAggregateInput = {
    id_tugas_penanaman_pengguna?: SortOrder
    nama_tugas?: SortOrder
    id_hari_tanaman_pengguna?: SortOrder
  }

  export type TugasPenanamanPenggunaMinOrderByAggregateInput = {
    id_tugas_penanaman_pengguna?: SortOrder
    nama_tugas?: SortOrder
    id_hari_tanaman_pengguna?: SortOrder
  }

  export type TugasPenanamanPenggunaSumOrderByAggregateInput = {
    id_tugas_penanaman_pengguna?: SortOrder
    id_hari_tanaman_pengguna?: SortOrder
  }

  export type KabupatenCreateNestedManyWithoutProvinsiInput = {
    create?: XOR<KabupatenCreateWithoutProvinsiInput, KabupatenUncheckedCreateWithoutProvinsiInput> | KabupatenCreateWithoutProvinsiInput[] | KabupatenUncheckedCreateWithoutProvinsiInput[]
    connectOrCreate?: KabupatenCreateOrConnectWithoutProvinsiInput | KabupatenCreateOrConnectWithoutProvinsiInput[]
    createMany?: KabupatenCreateManyProvinsiInputEnvelope
    connect?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
  }

  export type KabupatenUncheckedCreateNestedManyWithoutProvinsiInput = {
    create?: XOR<KabupatenCreateWithoutProvinsiInput, KabupatenUncheckedCreateWithoutProvinsiInput> | KabupatenCreateWithoutProvinsiInput[] | KabupatenUncheckedCreateWithoutProvinsiInput[]
    connectOrCreate?: KabupatenCreateOrConnectWithoutProvinsiInput | KabupatenCreateOrConnectWithoutProvinsiInput[]
    createMany?: KabupatenCreateManyProvinsiInputEnvelope
    connect?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type KabupatenUpdateManyWithoutProvinsiNestedInput = {
    create?: XOR<KabupatenCreateWithoutProvinsiInput, KabupatenUncheckedCreateWithoutProvinsiInput> | KabupatenCreateWithoutProvinsiInput[] | KabupatenUncheckedCreateWithoutProvinsiInput[]
    connectOrCreate?: KabupatenCreateOrConnectWithoutProvinsiInput | KabupatenCreateOrConnectWithoutProvinsiInput[]
    upsert?: KabupatenUpsertWithWhereUniqueWithoutProvinsiInput | KabupatenUpsertWithWhereUniqueWithoutProvinsiInput[]
    createMany?: KabupatenCreateManyProvinsiInputEnvelope
    set?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
    disconnect?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
    delete?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
    connect?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
    update?: KabupatenUpdateWithWhereUniqueWithoutProvinsiInput | KabupatenUpdateWithWhereUniqueWithoutProvinsiInput[]
    updateMany?: KabupatenUpdateManyWithWhereWithoutProvinsiInput | KabupatenUpdateManyWithWhereWithoutProvinsiInput[]
    deleteMany?: KabupatenScalarWhereInput | KabupatenScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KabupatenUncheckedUpdateManyWithoutProvinsiNestedInput = {
    create?: XOR<KabupatenCreateWithoutProvinsiInput, KabupatenUncheckedCreateWithoutProvinsiInput> | KabupatenCreateWithoutProvinsiInput[] | KabupatenUncheckedCreateWithoutProvinsiInput[]
    connectOrCreate?: KabupatenCreateOrConnectWithoutProvinsiInput | KabupatenCreateOrConnectWithoutProvinsiInput[]
    upsert?: KabupatenUpsertWithWhereUniqueWithoutProvinsiInput | KabupatenUpsertWithWhereUniqueWithoutProvinsiInput[]
    createMany?: KabupatenCreateManyProvinsiInputEnvelope
    set?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
    disconnect?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
    delete?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
    connect?: KabupatenWhereUniqueInput | KabupatenWhereUniqueInput[]
    update?: KabupatenUpdateWithWhereUniqueWithoutProvinsiInput | KabupatenUpdateWithWhereUniqueWithoutProvinsiInput[]
    updateMany?: KabupatenUpdateManyWithWhereWithoutProvinsiInput | KabupatenUpdateManyWithWhereWithoutProvinsiInput[]
    deleteMany?: KabupatenScalarWhereInput | KabupatenScalarWhereInput[]
  }

  export type ProvinsiCreateNestedOneWithoutKabupatenInput = {
    create?: XOR<ProvinsiCreateWithoutKabupatenInput, ProvinsiUncheckedCreateWithoutKabupatenInput>
    connectOrCreate?: ProvinsiCreateOrConnectWithoutKabupatenInput
    connect?: ProvinsiWhereUniqueInput
  }

  export type FacilitatorCreateNestedManyWithoutKabupatenInput = {
    create?: XOR<FacilitatorCreateWithoutKabupatenInput, FacilitatorUncheckedCreateWithoutKabupatenInput> | FacilitatorCreateWithoutKabupatenInput[] | FacilitatorUncheckedCreateWithoutKabupatenInput[]
    connectOrCreate?: FacilitatorCreateOrConnectWithoutKabupatenInput | FacilitatorCreateOrConnectWithoutKabupatenInput[]
    createMany?: FacilitatorCreateManyKabupatenInputEnvelope
    connect?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
  }

  export type WorkshopCreateNestedManyWithoutKabupatenInput = {
    create?: XOR<WorkshopCreateWithoutKabupatenInput, WorkshopUncheckedCreateWithoutKabupatenInput> | WorkshopCreateWithoutKabupatenInput[] | WorkshopUncheckedCreateWithoutKabupatenInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutKabupatenInput | WorkshopCreateOrConnectWithoutKabupatenInput[]
    createMany?: WorkshopCreateManyKabupatenInputEnvelope
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
  }

  export type FacilitatorUncheckedCreateNestedManyWithoutKabupatenInput = {
    create?: XOR<FacilitatorCreateWithoutKabupatenInput, FacilitatorUncheckedCreateWithoutKabupatenInput> | FacilitatorCreateWithoutKabupatenInput[] | FacilitatorUncheckedCreateWithoutKabupatenInput[]
    connectOrCreate?: FacilitatorCreateOrConnectWithoutKabupatenInput | FacilitatorCreateOrConnectWithoutKabupatenInput[]
    createMany?: FacilitatorCreateManyKabupatenInputEnvelope
    connect?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
  }

  export type WorkshopUncheckedCreateNestedManyWithoutKabupatenInput = {
    create?: XOR<WorkshopCreateWithoutKabupatenInput, WorkshopUncheckedCreateWithoutKabupatenInput> | WorkshopCreateWithoutKabupatenInput[] | WorkshopUncheckedCreateWithoutKabupatenInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutKabupatenInput | WorkshopCreateOrConnectWithoutKabupatenInput[]
    createMany?: WorkshopCreateManyKabupatenInputEnvelope
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
  }

  export type ProvinsiUpdateOneRequiredWithoutKabupatenNestedInput = {
    create?: XOR<ProvinsiCreateWithoutKabupatenInput, ProvinsiUncheckedCreateWithoutKabupatenInput>
    connectOrCreate?: ProvinsiCreateOrConnectWithoutKabupatenInput
    upsert?: ProvinsiUpsertWithoutKabupatenInput
    connect?: ProvinsiWhereUniqueInput
    update?: XOR<XOR<ProvinsiUpdateToOneWithWhereWithoutKabupatenInput, ProvinsiUpdateWithoutKabupatenInput>, ProvinsiUncheckedUpdateWithoutKabupatenInput>
  }

  export type FacilitatorUpdateManyWithoutKabupatenNestedInput = {
    create?: XOR<FacilitatorCreateWithoutKabupatenInput, FacilitatorUncheckedCreateWithoutKabupatenInput> | FacilitatorCreateWithoutKabupatenInput[] | FacilitatorUncheckedCreateWithoutKabupatenInput[]
    connectOrCreate?: FacilitatorCreateOrConnectWithoutKabupatenInput | FacilitatorCreateOrConnectWithoutKabupatenInput[]
    upsert?: FacilitatorUpsertWithWhereUniqueWithoutKabupatenInput | FacilitatorUpsertWithWhereUniqueWithoutKabupatenInput[]
    createMany?: FacilitatorCreateManyKabupatenInputEnvelope
    set?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
    disconnect?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
    delete?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
    connect?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
    update?: FacilitatorUpdateWithWhereUniqueWithoutKabupatenInput | FacilitatorUpdateWithWhereUniqueWithoutKabupatenInput[]
    updateMany?: FacilitatorUpdateManyWithWhereWithoutKabupatenInput | FacilitatorUpdateManyWithWhereWithoutKabupatenInput[]
    deleteMany?: FacilitatorScalarWhereInput | FacilitatorScalarWhereInput[]
  }

  export type WorkshopUpdateManyWithoutKabupatenNestedInput = {
    create?: XOR<WorkshopCreateWithoutKabupatenInput, WorkshopUncheckedCreateWithoutKabupatenInput> | WorkshopCreateWithoutKabupatenInput[] | WorkshopUncheckedCreateWithoutKabupatenInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutKabupatenInput | WorkshopCreateOrConnectWithoutKabupatenInput[]
    upsert?: WorkshopUpsertWithWhereUniqueWithoutKabupatenInput | WorkshopUpsertWithWhereUniqueWithoutKabupatenInput[]
    createMany?: WorkshopCreateManyKabupatenInputEnvelope
    set?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    disconnect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    delete?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    update?: WorkshopUpdateWithWhereUniqueWithoutKabupatenInput | WorkshopUpdateWithWhereUniqueWithoutKabupatenInput[]
    updateMany?: WorkshopUpdateManyWithWhereWithoutKabupatenInput | WorkshopUpdateManyWithWhereWithoutKabupatenInput[]
    deleteMany?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
  }

  export type FacilitatorUncheckedUpdateManyWithoutKabupatenNestedInput = {
    create?: XOR<FacilitatorCreateWithoutKabupatenInput, FacilitatorUncheckedCreateWithoutKabupatenInput> | FacilitatorCreateWithoutKabupatenInput[] | FacilitatorUncheckedCreateWithoutKabupatenInput[]
    connectOrCreate?: FacilitatorCreateOrConnectWithoutKabupatenInput | FacilitatorCreateOrConnectWithoutKabupatenInput[]
    upsert?: FacilitatorUpsertWithWhereUniqueWithoutKabupatenInput | FacilitatorUpsertWithWhereUniqueWithoutKabupatenInput[]
    createMany?: FacilitatorCreateManyKabupatenInputEnvelope
    set?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
    disconnect?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
    delete?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
    connect?: FacilitatorWhereUniqueInput | FacilitatorWhereUniqueInput[]
    update?: FacilitatorUpdateWithWhereUniqueWithoutKabupatenInput | FacilitatorUpdateWithWhereUniqueWithoutKabupatenInput[]
    updateMany?: FacilitatorUpdateManyWithWhereWithoutKabupatenInput | FacilitatorUpdateManyWithWhereWithoutKabupatenInput[]
    deleteMany?: FacilitatorScalarWhereInput | FacilitatorScalarWhereInput[]
  }

  export type WorkshopUncheckedUpdateManyWithoutKabupatenNestedInput = {
    create?: XOR<WorkshopCreateWithoutKabupatenInput, WorkshopUncheckedCreateWithoutKabupatenInput> | WorkshopCreateWithoutKabupatenInput[] | WorkshopUncheckedCreateWithoutKabupatenInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutKabupatenInput | WorkshopCreateOrConnectWithoutKabupatenInput[]
    upsert?: WorkshopUpsertWithWhereUniqueWithoutKabupatenInput | WorkshopUpsertWithWhereUniqueWithoutKabupatenInput[]
    createMany?: WorkshopCreateManyKabupatenInputEnvelope
    set?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    disconnect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    delete?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    update?: WorkshopUpdateWithWhereUniqueWithoutKabupatenInput | WorkshopUpdateWithWhereUniqueWithoutKabupatenInput[]
    updateMany?: WorkshopUpdateManyWithWhereWithoutKabupatenInput | WorkshopUpdateManyWithWhereWithoutKabupatenInput[]
    deleteMany?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
  }

  export type WorkshopTerdaftarCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<WorkshopTerdaftarCreateWithoutPenggunaInput, WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput> | WorkshopTerdaftarCreateWithoutPenggunaInput[] | WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: WorkshopTerdaftarCreateOrConnectWithoutPenggunaInput | WorkshopTerdaftarCreateOrConnectWithoutPenggunaInput[]
    createMany?: WorkshopTerdaftarCreateManyPenggunaInputEnvelope
    connect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
  }

  export type ArtikelCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<ArtikelCreateWithoutPenggunaInput, ArtikelUncheckedCreateWithoutPenggunaInput> | ArtikelCreateWithoutPenggunaInput[] | ArtikelUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelCreateOrConnectWithoutPenggunaInput | ArtikelCreateOrConnectWithoutPenggunaInput[]
    createMany?: ArtikelCreateManyPenggunaInputEnvelope
    connect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
  }

  export type ArtikelDisimpanCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<ArtikelDisimpanCreateWithoutPenggunaInput, ArtikelDisimpanUncheckedCreateWithoutPenggunaInput> | ArtikelDisimpanCreateWithoutPenggunaInput[] | ArtikelDisimpanUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelDisimpanCreateOrConnectWithoutPenggunaInput | ArtikelDisimpanCreateOrConnectWithoutPenggunaInput[]
    createMany?: ArtikelDisimpanCreateManyPenggunaInputEnvelope
    connect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
  }

  export type ArtikelDisukaiCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<ArtikelDisukaiCreateWithoutPenggunaInput, ArtikelDisukaiUncheckedCreateWithoutPenggunaInput> | ArtikelDisukaiCreateWithoutPenggunaInput[] | ArtikelDisukaiUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelDisukaiCreateOrConnectWithoutPenggunaInput | ArtikelDisukaiCreateOrConnectWithoutPenggunaInput[]
    createMany?: ArtikelDisukaiCreateManyPenggunaInputEnvelope
    connect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
  }

  export type KomentarArtikelCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<KomentarArtikelCreateWithoutPenggunaInput, KomentarArtikelUncheckedCreateWithoutPenggunaInput> | KomentarArtikelCreateWithoutPenggunaInput[] | KomentarArtikelUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: KomentarArtikelCreateOrConnectWithoutPenggunaInput | KomentarArtikelCreateOrConnectWithoutPenggunaInput[]
    createMany?: KomentarArtikelCreateManyPenggunaInputEnvelope
    connect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
  }

  export type TanamanPenggunaCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<TanamanPenggunaCreateWithoutPenggunaInput, TanamanPenggunaUncheckedCreateWithoutPenggunaInput> | TanamanPenggunaCreateWithoutPenggunaInput[] | TanamanPenggunaUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutPenggunaInput | TanamanPenggunaCreateOrConnectWithoutPenggunaInput[]
    createMany?: TanamanPenggunaCreateManyPenggunaInputEnvelope
    connect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
  }

  export type WorkshopTerdaftarUncheckedCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<WorkshopTerdaftarCreateWithoutPenggunaInput, WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput> | WorkshopTerdaftarCreateWithoutPenggunaInput[] | WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: WorkshopTerdaftarCreateOrConnectWithoutPenggunaInput | WorkshopTerdaftarCreateOrConnectWithoutPenggunaInput[]
    createMany?: WorkshopTerdaftarCreateManyPenggunaInputEnvelope
    connect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
  }

  export type ArtikelUncheckedCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<ArtikelCreateWithoutPenggunaInput, ArtikelUncheckedCreateWithoutPenggunaInput> | ArtikelCreateWithoutPenggunaInput[] | ArtikelUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelCreateOrConnectWithoutPenggunaInput | ArtikelCreateOrConnectWithoutPenggunaInput[]
    createMany?: ArtikelCreateManyPenggunaInputEnvelope
    connect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
  }

  export type ArtikelDisimpanUncheckedCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<ArtikelDisimpanCreateWithoutPenggunaInput, ArtikelDisimpanUncheckedCreateWithoutPenggunaInput> | ArtikelDisimpanCreateWithoutPenggunaInput[] | ArtikelDisimpanUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelDisimpanCreateOrConnectWithoutPenggunaInput | ArtikelDisimpanCreateOrConnectWithoutPenggunaInput[]
    createMany?: ArtikelDisimpanCreateManyPenggunaInputEnvelope
    connect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
  }

  export type ArtikelDisukaiUncheckedCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<ArtikelDisukaiCreateWithoutPenggunaInput, ArtikelDisukaiUncheckedCreateWithoutPenggunaInput> | ArtikelDisukaiCreateWithoutPenggunaInput[] | ArtikelDisukaiUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelDisukaiCreateOrConnectWithoutPenggunaInput | ArtikelDisukaiCreateOrConnectWithoutPenggunaInput[]
    createMany?: ArtikelDisukaiCreateManyPenggunaInputEnvelope
    connect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
  }

  export type KomentarArtikelUncheckedCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<KomentarArtikelCreateWithoutPenggunaInput, KomentarArtikelUncheckedCreateWithoutPenggunaInput> | KomentarArtikelCreateWithoutPenggunaInput[] | KomentarArtikelUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: KomentarArtikelCreateOrConnectWithoutPenggunaInput | KomentarArtikelCreateOrConnectWithoutPenggunaInput[]
    createMany?: KomentarArtikelCreateManyPenggunaInputEnvelope
    connect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
  }

  export type TanamanPenggunaUncheckedCreateNestedManyWithoutPenggunaInput = {
    create?: XOR<TanamanPenggunaCreateWithoutPenggunaInput, TanamanPenggunaUncheckedCreateWithoutPenggunaInput> | TanamanPenggunaCreateWithoutPenggunaInput[] | TanamanPenggunaUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutPenggunaInput | TanamanPenggunaCreateOrConnectWithoutPenggunaInput[]
    createMany?: TanamanPenggunaCreateManyPenggunaInputEnvelope
    connect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type WorkshopTerdaftarUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<WorkshopTerdaftarCreateWithoutPenggunaInput, WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput> | WorkshopTerdaftarCreateWithoutPenggunaInput[] | WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: WorkshopTerdaftarCreateOrConnectWithoutPenggunaInput | WorkshopTerdaftarCreateOrConnectWithoutPenggunaInput[]
    upsert?: WorkshopTerdaftarUpsertWithWhereUniqueWithoutPenggunaInput | WorkshopTerdaftarUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: WorkshopTerdaftarCreateManyPenggunaInputEnvelope
    set?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    disconnect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    delete?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    connect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    update?: WorkshopTerdaftarUpdateWithWhereUniqueWithoutPenggunaInput | WorkshopTerdaftarUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: WorkshopTerdaftarUpdateManyWithWhereWithoutPenggunaInput | WorkshopTerdaftarUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: WorkshopTerdaftarScalarWhereInput | WorkshopTerdaftarScalarWhereInput[]
  }

  export type ArtikelUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<ArtikelCreateWithoutPenggunaInput, ArtikelUncheckedCreateWithoutPenggunaInput> | ArtikelCreateWithoutPenggunaInput[] | ArtikelUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelCreateOrConnectWithoutPenggunaInput | ArtikelCreateOrConnectWithoutPenggunaInput[]
    upsert?: ArtikelUpsertWithWhereUniqueWithoutPenggunaInput | ArtikelUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: ArtikelCreateManyPenggunaInputEnvelope
    set?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    disconnect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    delete?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    connect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    update?: ArtikelUpdateWithWhereUniqueWithoutPenggunaInput | ArtikelUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: ArtikelUpdateManyWithWhereWithoutPenggunaInput | ArtikelUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: ArtikelScalarWhereInput | ArtikelScalarWhereInput[]
  }

  export type ArtikelDisimpanUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<ArtikelDisimpanCreateWithoutPenggunaInput, ArtikelDisimpanUncheckedCreateWithoutPenggunaInput> | ArtikelDisimpanCreateWithoutPenggunaInput[] | ArtikelDisimpanUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelDisimpanCreateOrConnectWithoutPenggunaInput | ArtikelDisimpanCreateOrConnectWithoutPenggunaInput[]
    upsert?: ArtikelDisimpanUpsertWithWhereUniqueWithoutPenggunaInput | ArtikelDisimpanUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: ArtikelDisimpanCreateManyPenggunaInputEnvelope
    set?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    disconnect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    delete?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    connect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    update?: ArtikelDisimpanUpdateWithWhereUniqueWithoutPenggunaInput | ArtikelDisimpanUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: ArtikelDisimpanUpdateManyWithWhereWithoutPenggunaInput | ArtikelDisimpanUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: ArtikelDisimpanScalarWhereInput | ArtikelDisimpanScalarWhereInput[]
  }

  export type ArtikelDisukaiUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<ArtikelDisukaiCreateWithoutPenggunaInput, ArtikelDisukaiUncheckedCreateWithoutPenggunaInput> | ArtikelDisukaiCreateWithoutPenggunaInput[] | ArtikelDisukaiUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelDisukaiCreateOrConnectWithoutPenggunaInput | ArtikelDisukaiCreateOrConnectWithoutPenggunaInput[]
    upsert?: ArtikelDisukaiUpsertWithWhereUniqueWithoutPenggunaInput | ArtikelDisukaiUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: ArtikelDisukaiCreateManyPenggunaInputEnvelope
    set?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    disconnect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    delete?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    connect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    update?: ArtikelDisukaiUpdateWithWhereUniqueWithoutPenggunaInput | ArtikelDisukaiUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: ArtikelDisukaiUpdateManyWithWhereWithoutPenggunaInput | ArtikelDisukaiUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: ArtikelDisukaiScalarWhereInput | ArtikelDisukaiScalarWhereInput[]
  }

  export type KomentarArtikelUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<KomentarArtikelCreateWithoutPenggunaInput, KomentarArtikelUncheckedCreateWithoutPenggunaInput> | KomentarArtikelCreateWithoutPenggunaInput[] | KomentarArtikelUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: KomentarArtikelCreateOrConnectWithoutPenggunaInput | KomentarArtikelCreateOrConnectWithoutPenggunaInput[]
    upsert?: KomentarArtikelUpsertWithWhereUniqueWithoutPenggunaInput | KomentarArtikelUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: KomentarArtikelCreateManyPenggunaInputEnvelope
    set?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    disconnect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    delete?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    connect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    update?: KomentarArtikelUpdateWithWhereUniqueWithoutPenggunaInput | KomentarArtikelUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: KomentarArtikelUpdateManyWithWhereWithoutPenggunaInput | KomentarArtikelUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: KomentarArtikelScalarWhereInput | KomentarArtikelScalarWhereInput[]
  }

  export type TanamanPenggunaUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<TanamanPenggunaCreateWithoutPenggunaInput, TanamanPenggunaUncheckedCreateWithoutPenggunaInput> | TanamanPenggunaCreateWithoutPenggunaInput[] | TanamanPenggunaUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutPenggunaInput | TanamanPenggunaCreateOrConnectWithoutPenggunaInput[]
    upsert?: TanamanPenggunaUpsertWithWhereUniqueWithoutPenggunaInput | TanamanPenggunaUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: TanamanPenggunaCreateManyPenggunaInputEnvelope
    set?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    disconnect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    delete?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    connect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    update?: TanamanPenggunaUpdateWithWhereUniqueWithoutPenggunaInput | TanamanPenggunaUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: TanamanPenggunaUpdateManyWithWhereWithoutPenggunaInput | TanamanPenggunaUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: TanamanPenggunaScalarWhereInput | TanamanPenggunaScalarWhereInput[]
  }

  export type WorkshopTerdaftarUncheckedUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<WorkshopTerdaftarCreateWithoutPenggunaInput, WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput> | WorkshopTerdaftarCreateWithoutPenggunaInput[] | WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: WorkshopTerdaftarCreateOrConnectWithoutPenggunaInput | WorkshopTerdaftarCreateOrConnectWithoutPenggunaInput[]
    upsert?: WorkshopTerdaftarUpsertWithWhereUniqueWithoutPenggunaInput | WorkshopTerdaftarUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: WorkshopTerdaftarCreateManyPenggunaInputEnvelope
    set?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    disconnect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    delete?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    connect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    update?: WorkshopTerdaftarUpdateWithWhereUniqueWithoutPenggunaInput | WorkshopTerdaftarUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: WorkshopTerdaftarUpdateManyWithWhereWithoutPenggunaInput | WorkshopTerdaftarUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: WorkshopTerdaftarScalarWhereInput | WorkshopTerdaftarScalarWhereInput[]
  }

  export type ArtikelUncheckedUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<ArtikelCreateWithoutPenggunaInput, ArtikelUncheckedCreateWithoutPenggunaInput> | ArtikelCreateWithoutPenggunaInput[] | ArtikelUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelCreateOrConnectWithoutPenggunaInput | ArtikelCreateOrConnectWithoutPenggunaInput[]
    upsert?: ArtikelUpsertWithWhereUniqueWithoutPenggunaInput | ArtikelUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: ArtikelCreateManyPenggunaInputEnvelope
    set?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    disconnect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    delete?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    connect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    update?: ArtikelUpdateWithWhereUniqueWithoutPenggunaInput | ArtikelUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: ArtikelUpdateManyWithWhereWithoutPenggunaInput | ArtikelUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: ArtikelScalarWhereInput | ArtikelScalarWhereInput[]
  }

  export type ArtikelDisimpanUncheckedUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<ArtikelDisimpanCreateWithoutPenggunaInput, ArtikelDisimpanUncheckedCreateWithoutPenggunaInput> | ArtikelDisimpanCreateWithoutPenggunaInput[] | ArtikelDisimpanUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelDisimpanCreateOrConnectWithoutPenggunaInput | ArtikelDisimpanCreateOrConnectWithoutPenggunaInput[]
    upsert?: ArtikelDisimpanUpsertWithWhereUniqueWithoutPenggunaInput | ArtikelDisimpanUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: ArtikelDisimpanCreateManyPenggunaInputEnvelope
    set?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    disconnect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    delete?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    connect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    update?: ArtikelDisimpanUpdateWithWhereUniqueWithoutPenggunaInput | ArtikelDisimpanUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: ArtikelDisimpanUpdateManyWithWhereWithoutPenggunaInput | ArtikelDisimpanUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: ArtikelDisimpanScalarWhereInput | ArtikelDisimpanScalarWhereInput[]
  }

  export type ArtikelDisukaiUncheckedUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<ArtikelDisukaiCreateWithoutPenggunaInput, ArtikelDisukaiUncheckedCreateWithoutPenggunaInput> | ArtikelDisukaiCreateWithoutPenggunaInput[] | ArtikelDisukaiUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: ArtikelDisukaiCreateOrConnectWithoutPenggunaInput | ArtikelDisukaiCreateOrConnectWithoutPenggunaInput[]
    upsert?: ArtikelDisukaiUpsertWithWhereUniqueWithoutPenggunaInput | ArtikelDisukaiUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: ArtikelDisukaiCreateManyPenggunaInputEnvelope
    set?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    disconnect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    delete?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    connect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    update?: ArtikelDisukaiUpdateWithWhereUniqueWithoutPenggunaInput | ArtikelDisukaiUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: ArtikelDisukaiUpdateManyWithWhereWithoutPenggunaInput | ArtikelDisukaiUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: ArtikelDisukaiScalarWhereInput | ArtikelDisukaiScalarWhereInput[]
  }

  export type KomentarArtikelUncheckedUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<KomentarArtikelCreateWithoutPenggunaInput, KomentarArtikelUncheckedCreateWithoutPenggunaInput> | KomentarArtikelCreateWithoutPenggunaInput[] | KomentarArtikelUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: KomentarArtikelCreateOrConnectWithoutPenggunaInput | KomentarArtikelCreateOrConnectWithoutPenggunaInput[]
    upsert?: KomentarArtikelUpsertWithWhereUniqueWithoutPenggunaInput | KomentarArtikelUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: KomentarArtikelCreateManyPenggunaInputEnvelope
    set?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    disconnect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    delete?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    connect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    update?: KomentarArtikelUpdateWithWhereUniqueWithoutPenggunaInput | KomentarArtikelUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: KomentarArtikelUpdateManyWithWhereWithoutPenggunaInput | KomentarArtikelUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: KomentarArtikelScalarWhereInput | KomentarArtikelScalarWhereInput[]
  }

  export type TanamanPenggunaUncheckedUpdateManyWithoutPenggunaNestedInput = {
    create?: XOR<TanamanPenggunaCreateWithoutPenggunaInput, TanamanPenggunaUncheckedCreateWithoutPenggunaInput> | TanamanPenggunaCreateWithoutPenggunaInput[] | TanamanPenggunaUncheckedCreateWithoutPenggunaInput[]
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutPenggunaInput | TanamanPenggunaCreateOrConnectWithoutPenggunaInput[]
    upsert?: TanamanPenggunaUpsertWithWhereUniqueWithoutPenggunaInput | TanamanPenggunaUpsertWithWhereUniqueWithoutPenggunaInput[]
    createMany?: TanamanPenggunaCreateManyPenggunaInputEnvelope
    set?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    disconnect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    delete?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    connect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    update?: TanamanPenggunaUpdateWithWhereUniqueWithoutPenggunaInput | TanamanPenggunaUpdateWithWhereUniqueWithoutPenggunaInput[]
    updateMany?: TanamanPenggunaUpdateManyWithWhereWithoutPenggunaInput | TanamanPenggunaUpdateManyWithWhereWithoutPenggunaInput[]
    deleteMany?: TanamanPenggunaScalarWhereInput | TanamanPenggunaScalarWhereInput[]
  }

  export type KabupatenCreateNestedOneWithoutFacilitatorsInput = {
    create?: XOR<KabupatenCreateWithoutFacilitatorsInput, KabupatenUncheckedCreateWithoutFacilitatorsInput>
    connectOrCreate?: KabupatenCreateOrConnectWithoutFacilitatorsInput
    connect?: KabupatenWhereUniqueInput
  }

  export type WorkshopCreateNestedManyWithoutFacilitatorInput = {
    create?: XOR<WorkshopCreateWithoutFacilitatorInput, WorkshopUncheckedCreateWithoutFacilitatorInput> | WorkshopCreateWithoutFacilitatorInput[] | WorkshopUncheckedCreateWithoutFacilitatorInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutFacilitatorInput | WorkshopCreateOrConnectWithoutFacilitatorInput[]
    createMany?: WorkshopCreateManyFacilitatorInputEnvelope
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
  }

  export type WorkshopUncheckedCreateNestedManyWithoutFacilitatorInput = {
    create?: XOR<WorkshopCreateWithoutFacilitatorInput, WorkshopUncheckedCreateWithoutFacilitatorInput> | WorkshopCreateWithoutFacilitatorInput[] | WorkshopUncheckedCreateWithoutFacilitatorInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutFacilitatorInput | WorkshopCreateOrConnectWithoutFacilitatorInput[]
    createMany?: WorkshopCreateManyFacilitatorInputEnvelope
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
  }

  export type KabupatenUpdateOneRequiredWithoutFacilitatorsNestedInput = {
    create?: XOR<KabupatenCreateWithoutFacilitatorsInput, KabupatenUncheckedCreateWithoutFacilitatorsInput>
    connectOrCreate?: KabupatenCreateOrConnectWithoutFacilitatorsInput
    upsert?: KabupatenUpsertWithoutFacilitatorsInput
    connect?: KabupatenWhereUniqueInput
    update?: XOR<XOR<KabupatenUpdateToOneWithWhereWithoutFacilitatorsInput, KabupatenUpdateWithoutFacilitatorsInput>, KabupatenUncheckedUpdateWithoutFacilitatorsInput>
  }

  export type WorkshopUpdateManyWithoutFacilitatorNestedInput = {
    create?: XOR<WorkshopCreateWithoutFacilitatorInput, WorkshopUncheckedCreateWithoutFacilitatorInput> | WorkshopCreateWithoutFacilitatorInput[] | WorkshopUncheckedCreateWithoutFacilitatorInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutFacilitatorInput | WorkshopCreateOrConnectWithoutFacilitatorInput[]
    upsert?: WorkshopUpsertWithWhereUniqueWithoutFacilitatorInput | WorkshopUpsertWithWhereUniqueWithoutFacilitatorInput[]
    createMany?: WorkshopCreateManyFacilitatorInputEnvelope
    set?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    disconnect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    delete?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    update?: WorkshopUpdateWithWhereUniqueWithoutFacilitatorInput | WorkshopUpdateWithWhereUniqueWithoutFacilitatorInput[]
    updateMany?: WorkshopUpdateManyWithWhereWithoutFacilitatorInput | WorkshopUpdateManyWithWhereWithoutFacilitatorInput[]
    deleteMany?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
  }

  export type WorkshopUncheckedUpdateManyWithoutFacilitatorNestedInput = {
    create?: XOR<WorkshopCreateWithoutFacilitatorInput, WorkshopUncheckedCreateWithoutFacilitatorInput> | WorkshopCreateWithoutFacilitatorInput[] | WorkshopUncheckedCreateWithoutFacilitatorInput[]
    connectOrCreate?: WorkshopCreateOrConnectWithoutFacilitatorInput | WorkshopCreateOrConnectWithoutFacilitatorInput[]
    upsert?: WorkshopUpsertWithWhereUniqueWithoutFacilitatorInput | WorkshopUpsertWithWhereUniqueWithoutFacilitatorInput[]
    createMany?: WorkshopCreateManyFacilitatorInputEnvelope
    set?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    disconnect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    delete?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    connect?: WorkshopWhereUniqueInput | WorkshopWhereUniqueInput[]
    update?: WorkshopUpdateWithWhereUniqueWithoutFacilitatorInput | WorkshopUpdateWithWhereUniqueWithoutFacilitatorInput[]
    updateMany?: WorkshopUpdateManyWithWhereWithoutFacilitatorInput | WorkshopUpdateManyWithWhereWithoutFacilitatorInput[]
    deleteMany?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
  }

  export type KategoriArtikelCreateNestedOneWithoutArtikelInput = {
    create?: XOR<KategoriArtikelCreateWithoutArtikelInput, KategoriArtikelUncheckedCreateWithoutArtikelInput>
    connectOrCreate?: KategoriArtikelCreateOrConnectWithoutArtikelInput
    connect?: KategoriArtikelWhereUniqueInput
  }

  export type PenggunaCreateNestedOneWithoutArtikelInput = {
    create?: XOR<PenggunaCreateWithoutArtikelInput, PenggunaUncheckedCreateWithoutArtikelInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutArtikelInput
    connect?: PenggunaWhereUniqueInput
  }

  export type ArtikelDisimpanCreateNestedManyWithoutArtikelInput = {
    create?: XOR<ArtikelDisimpanCreateWithoutArtikelInput, ArtikelDisimpanUncheckedCreateWithoutArtikelInput> | ArtikelDisimpanCreateWithoutArtikelInput[] | ArtikelDisimpanUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: ArtikelDisimpanCreateOrConnectWithoutArtikelInput | ArtikelDisimpanCreateOrConnectWithoutArtikelInput[]
    createMany?: ArtikelDisimpanCreateManyArtikelInputEnvelope
    connect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
  }

  export type ArtikelDisukaiCreateNestedManyWithoutArtikelInput = {
    create?: XOR<ArtikelDisukaiCreateWithoutArtikelInput, ArtikelDisukaiUncheckedCreateWithoutArtikelInput> | ArtikelDisukaiCreateWithoutArtikelInput[] | ArtikelDisukaiUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: ArtikelDisukaiCreateOrConnectWithoutArtikelInput | ArtikelDisukaiCreateOrConnectWithoutArtikelInput[]
    createMany?: ArtikelDisukaiCreateManyArtikelInputEnvelope
    connect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
  }

  export type KomentarArtikelCreateNestedManyWithoutArtikelInput = {
    create?: XOR<KomentarArtikelCreateWithoutArtikelInput, KomentarArtikelUncheckedCreateWithoutArtikelInput> | KomentarArtikelCreateWithoutArtikelInput[] | KomentarArtikelUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: KomentarArtikelCreateOrConnectWithoutArtikelInput | KomentarArtikelCreateOrConnectWithoutArtikelInput[]
    createMany?: KomentarArtikelCreateManyArtikelInputEnvelope
    connect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
  }

  export type ArtikelDisimpanUncheckedCreateNestedManyWithoutArtikelInput = {
    create?: XOR<ArtikelDisimpanCreateWithoutArtikelInput, ArtikelDisimpanUncheckedCreateWithoutArtikelInput> | ArtikelDisimpanCreateWithoutArtikelInput[] | ArtikelDisimpanUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: ArtikelDisimpanCreateOrConnectWithoutArtikelInput | ArtikelDisimpanCreateOrConnectWithoutArtikelInput[]
    createMany?: ArtikelDisimpanCreateManyArtikelInputEnvelope
    connect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
  }

  export type ArtikelDisukaiUncheckedCreateNestedManyWithoutArtikelInput = {
    create?: XOR<ArtikelDisukaiCreateWithoutArtikelInput, ArtikelDisukaiUncheckedCreateWithoutArtikelInput> | ArtikelDisukaiCreateWithoutArtikelInput[] | ArtikelDisukaiUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: ArtikelDisukaiCreateOrConnectWithoutArtikelInput | ArtikelDisukaiCreateOrConnectWithoutArtikelInput[]
    createMany?: ArtikelDisukaiCreateManyArtikelInputEnvelope
    connect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
  }

  export type KomentarArtikelUncheckedCreateNestedManyWithoutArtikelInput = {
    create?: XOR<KomentarArtikelCreateWithoutArtikelInput, KomentarArtikelUncheckedCreateWithoutArtikelInput> | KomentarArtikelCreateWithoutArtikelInput[] | KomentarArtikelUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: KomentarArtikelCreateOrConnectWithoutArtikelInput | KomentarArtikelCreateOrConnectWithoutArtikelInput[]
    createMany?: KomentarArtikelCreateManyArtikelInputEnvelope
    connect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
  }

  export type EnumStatusArtikelFieldUpdateOperationsInput = {
    set?: $Enums.StatusArtikel
  }

  export type KategoriArtikelUpdateOneRequiredWithoutArtikelNestedInput = {
    create?: XOR<KategoriArtikelCreateWithoutArtikelInput, KategoriArtikelUncheckedCreateWithoutArtikelInput>
    connectOrCreate?: KategoriArtikelCreateOrConnectWithoutArtikelInput
    upsert?: KategoriArtikelUpsertWithoutArtikelInput
    connect?: KategoriArtikelWhereUniqueInput
    update?: XOR<XOR<KategoriArtikelUpdateToOneWithWhereWithoutArtikelInput, KategoriArtikelUpdateWithoutArtikelInput>, KategoriArtikelUncheckedUpdateWithoutArtikelInput>
  }

  export type PenggunaUpdateOneRequiredWithoutArtikelNestedInput = {
    create?: XOR<PenggunaCreateWithoutArtikelInput, PenggunaUncheckedCreateWithoutArtikelInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutArtikelInput
    upsert?: PenggunaUpsertWithoutArtikelInput
    connect?: PenggunaWhereUniqueInput
    update?: XOR<XOR<PenggunaUpdateToOneWithWhereWithoutArtikelInput, PenggunaUpdateWithoutArtikelInput>, PenggunaUncheckedUpdateWithoutArtikelInput>
  }

  export type ArtikelDisimpanUpdateManyWithoutArtikelNestedInput = {
    create?: XOR<ArtikelDisimpanCreateWithoutArtikelInput, ArtikelDisimpanUncheckedCreateWithoutArtikelInput> | ArtikelDisimpanCreateWithoutArtikelInput[] | ArtikelDisimpanUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: ArtikelDisimpanCreateOrConnectWithoutArtikelInput | ArtikelDisimpanCreateOrConnectWithoutArtikelInput[]
    upsert?: ArtikelDisimpanUpsertWithWhereUniqueWithoutArtikelInput | ArtikelDisimpanUpsertWithWhereUniqueWithoutArtikelInput[]
    createMany?: ArtikelDisimpanCreateManyArtikelInputEnvelope
    set?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    disconnect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    delete?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    connect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    update?: ArtikelDisimpanUpdateWithWhereUniqueWithoutArtikelInput | ArtikelDisimpanUpdateWithWhereUniqueWithoutArtikelInput[]
    updateMany?: ArtikelDisimpanUpdateManyWithWhereWithoutArtikelInput | ArtikelDisimpanUpdateManyWithWhereWithoutArtikelInput[]
    deleteMany?: ArtikelDisimpanScalarWhereInput | ArtikelDisimpanScalarWhereInput[]
  }

  export type ArtikelDisukaiUpdateManyWithoutArtikelNestedInput = {
    create?: XOR<ArtikelDisukaiCreateWithoutArtikelInput, ArtikelDisukaiUncheckedCreateWithoutArtikelInput> | ArtikelDisukaiCreateWithoutArtikelInput[] | ArtikelDisukaiUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: ArtikelDisukaiCreateOrConnectWithoutArtikelInput | ArtikelDisukaiCreateOrConnectWithoutArtikelInput[]
    upsert?: ArtikelDisukaiUpsertWithWhereUniqueWithoutArtikelInput | ArtikelDisukaiUpsertWithWhereUniqueWithoutArtikelInput[]
    createMany?: ArtikelDisukaiCreateManyArtikelInputEnvelope
    set?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    disconnect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    delete?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    connect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    update?: ArtikelDisukaiUpdateWithWhereUniqueWithoutArtikelInput | ArtikelDisukaiUpdateWithWhereUniqueWithoutArtikelInput[]
    updateMany?: ArtikelDisukaiUpdateManyWithWhereWithoutArtikelInput | ArtikelDisukaiUpdateManyWithWhereWithoutArtikelInput[]
    deleteMany?: ArtikelDisukaiScalarWhereInput | ArtikelDisukaiScalarWhereInput[]
  }

  export type KomentarArtikelUpdateManyWithoutArtikelNestedInput = {
    create?: XOR<KomentarArtikelCreateWithoutArtikelInput, KomentarArtikelUncheckedCreateWithoutArtikelInput> | KomentarArtikelCreateWithoutArtikelInput[] | KomentarArtikelUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: KomentarArtikelCreateOrConnectWithoutArtikelInput | KomentarArtikelCreateOrConnectWithoutArtikelInput[]
    upsert?: KomentarArtikelUpsertWithWhereUniqueWithoutArtikelInput | KomentarArtikelUpsertWithWhereUniqueWithoutArtikelInput[]
    createMany?: KomentarArtikelCreateManyArtikelInputEnvelope
    set?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    disconnect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    delete?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    connect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    update?: KomentarArtikelUpdateWithWhereUniqueWithoutArtikelInput | KomentarArtikelUpdateWithWhereUniqueWithoutArtikelInput[]
    updateMany?: KomentarArtikelUpdateManyWithWhereWithoutArtikelInput | KomentarArtikelUpdateManyWithWhereWithoutArtikelInput[]
    deleteMany?: KomentarArtikelScalarWhereInput | KomentarArtikelScalarWhereInput[]
  }

  export type ArtikelDisimpanUncheckedUpdateManyWithoutArtikelNestedInput = {
    create?: XOR<ArtikelDisimpanCreateWithoutArtikelInput, ArtikelDisimpanUncheckedCreateWithoutArtikelInput> | ArtikelDisimpanCreateWithoutArtikelInput[] | ArtikelDisimpanUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: ArtikelDisimpanCreateOrConnectWithoutArtikelInput | ArtikelDisimpanCreateOrConnectWithoutArtikelInput[]
    upsert?: ArtikelDisimpanUpsertWithWhereUniqueWithoutArtikelInput | ArtikelDisimpanUpsertWithWhereUniqueWithoutArtikelInput[]
    createMany?: ArtikelDisimpanCreateManyArtikelInputEnvelope
    set?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    disconnect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    delete?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    connect?: ArtikelDisimpanWhereUniqueInput | ArtikelDisimpanWhereUniqueInput[]
    update?: ArtikelDisimpanUpdateWithWhereUniqueWithoutArtikelInput | ArtikelDisimpanUpdateWithWhereUniqueWithoutArtikelInput[]
    updateMany?: ArtikelDisimpanUpdateManyWithWhereWithoutArtikelInput | ArtikelDisimpanUpdateManyWithWhereWithoutArtikelInput[]
    deleteMany?: ArtikelDisimpanScalarWhereInput | ArtikelDisimpanScalarWhereInput[]
  }

  export type ArtikelDisukaiUncheckedUpdateManyWithoutArtikelNestedInput = {
    create?: XOR<ArtikelDisukaiCreateWithoutArtikelInput, ArtikelDisukaiUncheckedCreateWithoutArtikelInput> | ArtikelDisukaiCreateWithoutArtikelInput[] | ArtikelDisukaiUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: ArtikelDisukaiCreateOrConnectWithoutArtikelInput | ArtikelDisukaiCreateOrConnectWithoutArtikelInput[]
    upsert?: ArtikelDisukaiUpsertWithWhereUniqueWithoutArtikelInput | ArtikelDisukaiUpsertWithWhereUniqueWithoutArtikelInput[]
    createMany?: ArtikelDisukaiCreateManyArtikelInputEnvelope
    set?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    disconnect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    delete?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    connect?: ArtikelDisukaiWhereUniqueInput | ArtikelDisukaiWhereUniqueInput[]
    update?: ArtikelDisukaiUpdateWithWhereUniqueWithoutArtikelInput | ArtikelDisukaiUpdateWithWhereUniqueWithoutArtikelInput[]
    updateMany?: ArtikelDisukaiUpdateManyWithWhereWithoutArtikelInput | ArtikelDisukaiUpdateManyWithWhereWithoutArtikelInput[]
    deleteMany?: ArtikelDisukaiScalarWhereInput | ArtikelDisukaiScalarWhereInput[]
  }

  export type KomentarArtikelUncheckedUpdateManyWithoutArtikelNestedInput = {
    create?: XOR<KomentarArtikelCreateWithoutArtikelInput, KomentarArtikelUncheckedCreateWithoutArtikelInput> | KomentarArtikelCreateWithoutArtikelInput[] | KomentarArtikelUncheckedCreateWithoutArtikelInput[]
    connectOrCreate?: KomentarArtikelCreateOrConnectWithoutArtikelInput | KomentarArtikelCreateOrConnectWithoutArtikelInput[]
    upsert?: KomentarArtikelUpsertWithWhereUniqueWithoutArtikelInput | KomentarArtikelUpsertWithWhereUniqueWithoutArtikelInput[]
    createMany?: KomentarArtikelCreateManyArtikelInputEnvelope
    set?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    disconnect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    delete?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    connect?: KomentarArtikelWhereUniqueInput | KomentarArtikelWhereUniqueInput[]
    update?: KomentarArtikelUpdateWithWhereUniqueWithoutArtikelInput | KomentarArtikelUpdateWithWhereUniqueWithoutArtikelInput[]
    updateMany?: KomentarArtikelUpdateManyWithWhereWithoutArtikelInput | KomentarArtikelUpdateManyWithWhereWithoutArtikelInput[]
    deleteMany?: KomentarArtikelScalarWhereInput | KomentarArtikelScalarWhereInput[]
  }

  export type ArtikelCreateNestedManyWithoutKategoriInput = {
    create?: XOR<ArtikelCreateWithoutKategoriInput, ArtikelUncheckedCreateWithoutKategoriInput> | ArtikelCreateWithoutKategoriInput[] | ArtikelUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: ArtikelCreateOrConnectWithoutKategoriInput | ArtikelCreateOrConnectWithoutKategoriInput[]
    createMany?: ArtikelCreateManyKategoriInputEnvelope
    connect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
  }

  export type ArtikelUncheckedCreateNestedManyWithoutKategoriInput = {
    create?: XOR<ArtikelCreateWithoutKategoriInput, ArtikelUncheckedCreateWithoutKategoriInput> | ArtikelCreateWithoutKategoriInput[] | ArtikelUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: ArtikelCreateOrConnectWithoutKategoriInput | ArtikelCreateOrConnectWithoutKategoriInput[]
    createMany?: ArtikelCreateManyKategoriInputEnvelope
    connect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
  }

  export type ArtikelUpdateManyWithoutKategoriNestedInput = {
    create?: XOR<ArtikelCreateWithoutKategoriInput, ArtikelUncheckedCreateWithoutKategoriInput> | ArtikelCreateWithoutKategoriInput[] | ArtikelUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: ArtikelCreateOrConnectWithoutKategoriInput | ArtikelCreateOrConnectWithoutKategoriInput[]
    upsert?: ArtikelUpsertWithWhereUniqueWithoutKategoriInput | ArtikelUpsertWithWhereUniqueWithoutKategoriInput[]
    createMany?: ArtikelCreateManyKategoriInputEnvelope
    set?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    disconnect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    delete?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    connect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    update?: ArtikelUpdateWithWhereUniqueWithoutKategoriInput | ArtikelUpdateWithWhereUniqueWithoutKategoriInput[]
    updateMany?: ArtikelUpdateManyWithWhereWithoutKategoriInput | ArtikelUpdateManyWithWhereWithoutKategoriInput[]
    deleteMany?: ArtikelScalarWhereInput | ArtikelScalarWhereInput[]
  }

  export type ArtikelUncheckedUpdateManyWithoutKategoriNestedInput = {
    create?: XOR<ArtikelCreateWithoutKategoriInput, ArtikelUncheckedCreateWithoutKategoriInput> | ArtikelCreateWithoutKategoriInput[] | ArtikelUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: ArtikelCreateOrConnectWithoutKategoriInput | ArtikelCreateOrConnectWithoutKategoriInput[]
    upsert?: ArtikelUpsertWithWhereUniqueWithoutKategoriInput | ArtikelUpsertWithWhereUniqueWithoutKategoriInput[]
    createMany?: ArtikelCreateManyKategoriInputEnvelope
    set?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    disconnect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    delete?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    connect?: ArtikelWhereUniqueInput | ArtikelWhereUniqueInput[]
    update?: ArtikelUpdateWithWhereUniqueWithoutKategoriInput | ArtikelUpdateWithWhereUniqueWithoutKategoriInput[]
    updateMany?: ArtikelUpdateManyWithWhereWithoutKategoriInput | ArtikelUpdateManyWithWhereWithoutKategoriInput[]
    deleteMany?: ArtikelScalarWhereInput | ArtikelScalarWhereInput[]
  }

  export type ArtikelCreateNestedOneWithoutArtikel_disimpanInput = {
    create?: XOR<ArtikelCreateWithoutArtikel_disimpanInput, ArtikelUncheckedCreateWithoutArtikel_disimpanInput>
    connectOrCreate?: ArtikelCreateOrConnectWithoutArtikel_disimpanInput
    connect?: ArtikelWhereUniqueInput
  }

  export type PenggunaCreateNestedOneWithoutArtikel_disimpanInput = {
    create?: XOR<PenggunaCreateWithoutArtikel_disimpanInput, PenggunaUncheckedCreateWithoutArtikel_disimpanInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutArtikel_disimpanInput
    connect?: PenggunaWhereUniqueInput
  }

  export type ArtikelUpdateOneRequiredWithoutArtikel_disimpanNestedInput = {
    create?: XOR<ArtikelCreateWithoutArtikel_disimpanInput, ArtikelUncheckedCreateWithoutArtikel_disimpanInput>
    connectOrCreate?: ArtikelCreateOrConnectWithoutArtikel_disimpanInput
    upsert?: ArtikelUpsertWithoutArtikel_disimpanInput
    connect?: ArtikelWhereUniqueInput
    update?: XOR<XOR<ArtikelUpdateToOneWithWhereWithoutArtikel_disimpanInput, ArtikelUpdateWithoutArtikel_disimpanInput>, ArtikelUncheckedUpdateWithoutArtikel_disimpanInput>
  }

  export type PenggunaUpdateOneRequiredWithoutArtikel_disimpanNestedInput = {
    create?: XOR<PenggunaCreateWithoutArtikel_disimpanInput, PenggunaUncheckedCreateWithoutArtikel_disimpanInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutArtikel_disimpanInput
    upsert?: PenggunaUpsertWithoutArtikel_disimpanInput
    connect?: PenggunaWhereUniqueInput
    update?: XOR<XOR<PenggunaUpdateToOneWithWhereWithoutArtikel_disimpanInput, PenggunaUpdateWithoutArtikel_disimpanInput>, PenggunaUncheckedUpdateWithoutArtikel_disimpanInput>
  }

  export type ArtikelCreateNestedOneWithoutArtikel_disukaiInput = {
    create?: XOR<ArtikelCreateWithoutArtikel_disukaiInput, ArtikelUncheckedCreateWithoutArtikel_disukaiInput>
    connectOrCreate?: ArtikelCreateOrConnectWithoutArtikel_disukaiInput
    connect?: ArtikelWhereUniqueInput
  }

  export type PenggunaCreateNestedOneWithoutArtikel_disukaiInput = {
    create?: XOR<PenggunaCreateWithoutArtikel_disukaiInput, PenggunaUncheckedCreateWithoutArtikel_disukaiInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutArtikel_disukaiInput
    connect?: PenggunaWhereUniqueInput
  }

  export type ArtikelUpdateOneRequiredWithoutArtikel_disukaiNestedInput = {
    create?: XOR<ArtikelCreateWithoutArtikel_disukaiInput, ArtikelUncheckedCreateWithoutArtikel_disukaiInput>
    connectOrCreate?: ArtikelCreateOrConnectWithoutArtikel_disukaiInput
    upsert?: ArtikelUpsertWithoutArtikel_disukaiInput
    connect?: ArtikelWhereUniqueInput
    update?: XOR<XOR<ArtikelUpdateToOneWithWhereWithoutArtikel_disukaiInput, ArtikelUpdateWithoutArtikel_disukaiInput>, ArtikelUncheckedUpdateWithoutArtikel_disukaiInput>
  }

  export type PenggunaUpdateOneRequiredWithoutArtikel_disukaiNestedInput = {
    create?: XOR<PenggunaCreateWithoutArtikel_disukaiInput, PenggunaUncheckedCreateWithoutArtikel_disukaiInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutArtikel_disukaiInput
    upsert?: PenggunaUpsertWithoutArtikel_disukaiInput
    connect?: PenggunaWhereUniqueInput
    update?: XOR<XOR<PenggunaUpdateToOneWithWhereWithoutArtikel_disukaiInput, PenggunaUpdateWithoutArtikel_disukaiInput>, PenggunaUncheckedUpdateWithoutArtikel_disukaiInput>
  }

  export type ArtikelCreateNestedOneWithoutKomentar_artikelInput = {
    create?: XOR<ArtikelCreateWithoutKomentar_artikelInput, ArtikelUncheckedCreateWithoutKomentar_artikelInput>
    connectOrCreate?: ArtikelCreateOrConnectWithoutKomentar_artikelInput
    connect?: ArtikelWhereUniqueInput
  }

  export type PenggunaCreateNestedOneWithoutKomentar_artikelInput = {
    create?: XOR<PenggunaCreateWithoutKomentar_artikelInput, PenggunaUncheckedCreateWithoutKomentar_artikelInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutKomentar_artikelInput
    connect?: PenggunaWhereUniqueInput
  }

  export type ArtikelUpdateOneRequiredWithoutKomentar_artikelNestedInput = {
    create?: XOR<ArtikelCreateWithoutKomentar_artikelInput, ArtikelUncheckedCreateWithoutKomentar_artikelInput>
    connectOrCreate?: ArtikelCreateOrConnectWithoutKomentar_artikelInput
    upsert?: ArtikelUpsertWithoutKomentar_artikelInput
    connect?: ArtikelWhereUniqueInput
    update?: XOR<XOR<ArtikelUpdateToOneWithWhereWithoutKomentar_artikelInput, ArtikelUpdateWithoutKomentar_artikelInput>, ArtikelUncheckedUpdateWithoutKomentar_artikelInput>
  }

  export type PenggunaUpdateOneRequiredWithoutKomentar_artikelNestedInput = {
    create?: XOR<PenggunaCreateWithoutKomentar_artikelInput, PenggunaUncheckedCreateWithoutKomentar_artikelInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutKomentar_artikelInput
    upsert?: PenggunaUpsertWithoutKomentar_artikelInput
    connect?: PenggunaWhereUniqueInput
    update?: XOR<XOR<PenggunaUpdateToOneWithWhereWithoutKomentar_artikelInput, PenggunaUpdateWithoutKomentar_artikelInput>, PenggunaUncheckedUpdateWithoutKomentar_artikelInput>
  }

  export type FacilitatorCreateNestedOneWithoutWorkshopsInput = {
    create?: XOR<FacilitatorCreateWithoutWorkshopsInput, FacilitatorUncheckedCreateWithoutWorkshopsInput>
    connectOrCreate?: FacilitatorCreateOrConnectWithoutWorkshopsInput
    connect?: FacilitatorWhereUniqueInput
  }

  export type KabupatenCreateNestedOneWithoutWorkshopInput = {
    create?: XOR<KabupatenCreateWithoutWorkshopInput, KabupatenUncheckedCreateWithoutWorkshopInput>
    connectOrCreate?: KabupatenCreateOrConnectWithoutWorkshopInput
    connect?: KabupatenWhereUniqueInput
  }

  export type WorkshopTerdaftarCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopTerdaftarCreateWithoutWorkshopInput, WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput> | WorkshopTerdaftarCreateWithoutWorkshopInput[] | WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopTerdaftarCreateOrConnectWithoutWorkshopInput | WorkshopTerdaftarCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopTerdaftarCreateManyWorkshopInputEnvelope
    connect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
  }

  export type WorkshopTerdaftarUncheckedCreateNestedManyWithoutWorkshopInput = {
    create?: XOR<WorkshopTerdaftarCreateWithoutWorkshopInput, WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput> | WorkshopTerdaftarCreateWithoutWorkshopInput[] | WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopTerdaftarCreateOrConnectWithoutWorkshopInput | WorkshopTerdaftarCreateOrConnectWithoutWorkshopInput[]
    createMany?: WorkshopTerdaftarCreateManyWorkshopInputEnvelope
    connect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FacilitatorUpdateOneRequiredWithoutWorkshopsNestedInput = {
    create?: XOR<FacilitatorCreateWithoutWorkshopsInput, FacilitatorUncheckedCreateWithoutWorkshopsInput>
    connectOrCreate?: FacilitatorCreateOrConnectWithoutWorkshopsInput
    upsert?: FacilitatorUpsertWithoutWorkshopsInput
    connect?: FacilitatorWhereUniqueInput
    update?: XOR<XOR<FacilitatorUpdateToOneWithWhereWithoutWorkshopsInput, FacilitatorUpdateWithoutWorkshopsInput>, FacilitatorUncheckedUpdateWithoutWorkshopsInput>
  }

  export type KabupatenUpdateOneRequiredWithoutWorkshopNestedInput = {
    create?: XOR<KabupatenCreateWithoutWorkshopInput, KabupatenUncheckedCreateWithoutWorkshopInput>
    connectOrCreate?: KabupatenCreateOrConnectWithoutWorkshopInput
    upsert?: KabupatenUpsertWithoutWorkshopInput
    connect?: KabupatenWhereUniqueInput
    update?: XOR<XOR<KabupatenUpdateToOneWithWhereWithoutWorkshopInput, KabupatenUpdateWithoutWorkshopInput>, KabupatenUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkshopTerdaftarUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopTerdaftarCreateWithoutWorkshopInput, WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput> | WorkshopTerdaftarCreateWithoutWorkshopInput[] | WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopTerdaftarCreateOrConnectWithoutWorkshopInput | WorkshopTerdaftarCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopTerdaftarUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopTerdaftarUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopTerdaftarCreateManyWorkshopInputEnvelope
    set?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    disconnect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    delete?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    connect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    update?: WorkshopTerdaftarUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopTerdaftarUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopTerdaftarUpdateManyWithWhereWithoutWorkshopInput | WorkshopTerdaftarUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopTerdaftarScalarWhereInput | WorkshopTerdaftarScalarWhereInput[]
  }

  export type WorkshopTerdaftarUncheckedUpdateManyWithoutWorkshopNestedInput = {
    create?: XOR<WorkshopTerdaftarCreateWithoutWorkshopInput, WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput> | WorkshopTerdaftarCreateWithoutWorkshopInput[] | WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput[]
    connectOrCreate?: WorkshopTerdaftarCreateOrConnectWithoutWorkshopInput | WorkshopTerdaftarCreateOrConnectWithoutWorkshopInput[]
    upsert?: WorkshopTerdaftarUpsertWithWhereUniqueWithoutWorkshopInput | WorkshopTerdaftarUpsertWithWhereUniqueWithoutWorkshopInput[]
    createMany?: WorkshopTerdaftarCreateManyWorkshopInputEnvelope
    set?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    disconnect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    delete?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    connect?: WorkshopTerdaftarWhereUniqueInput | WorkshopTerdaftarWhereUniqueInput[]
    update?: WorkshopTerdaftarUpdateWithWhereUniqueWithoutWorkshopInput | WorkshopTerdaftarUpdateWithWhereUniqueWithoutWorkshopInput[]
    updateMany?: WorkshopTerdaftarUpdateManyWithWhereWithoutWorkshopInput | WorkshopTerdaftarUpdateManyWithWhereWithoutWorkshopInput[]
    deleteMany?: WorkshopTerdaftarScalarWhereInput | WorkshopTerdaftarScalarWhereInput[]
  }

  export type PenggunaCreateNestedOneWithoutWorkshop_terdaftarInput = {
    create?: XOR<PenggunaCreateWithoutWorkshop_terdaftarInput, PenggunaUncheckedCreateWithoutWorkshop_terdaftarInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutWorkshop_terdaftarInput
    connect?: PenggunaWhereUniqueInput
  }

  export type WorkshopCreateNestedOneWithoutPendaftaranInput = {
    create?: XOR<WorkshopCreateWithoutPendaftaranInput, WorkshopUncheckedCreateWithoutPendaftaranInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutPendaftaranInput
    connect?: WorkshopWhereUniqueInput
  }

  export type PenggunaUpdateOneRequiredWithoutWorkshop_terdaftarNestedInput = {
    create?: XOR<PenggunaCreateWithoutWorkshop_terdaftarInput, PenggunaUncheckedCreateWithoutWorkshop_terdaftarInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutWorkshop_terdaftarInput
    upsert?: PenggunaUpsertWithoutWorkshop_terdaftarInput
    connect?: PenggunaWhereUniqueInput
    update?: XOR<XOR<PenggunaUpdateToOneWithWhereWithoutWorkshop_terdaftarInput, PenggunaUpdateWithoutWorkshop_terdaftarInput>, PenggunaUncheckedUpdateWithoutWorkshop_terdaftarInput>
  }

  export type WorkshopUpdateOneRequiredWithoutPendaftaranNestedInput = {
    create?: XOR<WorkshopCreateWithoutPendaftaranInput, WorkshopUncheckedCreateWithoutPendaftaranInput>
    connectOrCreate?: WorkshopCreateOrConnectWithoutPendaftaranInput
    upsert?: WorkshopUpsertWithoutPendaftaranInput
    connect?: WorkshopWhereUniqueInput
    update?: XOR<XOR<WorkshopUpdateToOneWithWhereWithoutPendaftaranInput, WorkshopUpdateWithoutPendaftaranInput>, WorkshopUncheckedUpdateWithoutPendaftaranInput>
  }

  export type TanamanCreateNestedManyWithoutKategoriInput = {
    create?: XOR<TanamanCreateWithoutKategoriInput, TanamanUncheckedCreateWithoutKategoriInput> | TanamanCreateWithoutKategoriInput[] | TanamanUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: TanamanCreateOrConnectWithoutKategoriInput | TanamanCreateOrConnectWithoutKategoriInput[]
    createMany?: TanamanCreateManyKategoriInputEnvelope
    connect?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
  }

  export type TanamanUncheckedCreateNestedManyWithoutKategoriInput = {
    create?: XOR<TanamanCreateWithoutKategoriInput, TanamanUncheckedCreateWithoutKategoriInput> | TanamanCreateWithoutKategoriInput[] | TanamanUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: TanamanCreateOrConnectWithoutKategoriInput | TanamanCreateOrConnectWithoutKategoriInput[]
    createMany?: TanamanCreateManyKategoriInputEnvelope
    connect?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
  }

  export type TanamanUpdateManyWithoutKategoriNestedInput = {
    create?: XOR<TanamanCreateWithoutKategoriInput, TanamanUncheckedCreateWithoutKategoriInput> | TanamanCreateWithoutKategoriInput[] | TanamanUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: TanamanCreateOrConnectWithoutKategoriInput | TanamanCreateOrConnectWithoutKategoriInput[]
    upsert?: TanamanUpsertWithWhereUniqueWithoutKategoriInput | TanamanUpsertWithWhereUniqueWithoutKategoriInput[]
    createMany?: TanamanCreateManyKategoriInputEnvelope
    set?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
    disconnect?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
    delete?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
    connect?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
    update?: TanamanUpdateWithWhereUniqueWithoutKategoriInput | TanamanUpdateWithWhereUniqueWithoutKategoriInput[]
    updateMany?: TanamanUpdateManyWithWhereWithoutKategoriInput | TanamanUpdateManyWithWhereWithoutKategoriInput[]
    deleteMany?: TanamanScalarWhereInput | TanamanScalarWhereInput[]
  }

  export type TanamanUncheckedUpdateManyWithoutKategoriNestedInput = {
    create?: XOR<TanamanCreateWithoutKategoriInput, TanamanUncheckedCreateWithoutKategoriInput> | TanamanCreateWithoutKategoriInput[] | TanamanUncheckedCreateWithoutKategoriInput[]
    connectOrCreate?: TanamanCreateOrConnectWithoutKategoriInput | TanamanCreateOrConnectWithoutKategoriInput[]
    upsert?: TanamanUpsertWithWhereUniqueWithoutKategoriInput | TanamanUpsertWithWhereUniqueWithoutKategoriInput[]
    createMany?: TanamanCreateManyKategoriInputEnvelope
    set?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
    disconnect?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
    delete?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
    connect?: TanamanWhereUniqueInput | TanamanWhereUniqueInput[]
    update?: TanamanUpdateWithWhereUniqueWithoutKategoriInput | TanamanUpdateWithWhereUniqueWithoutKategoriInput[]
    updateMany?: TanamanUpdateManyWithWhereWithoutKategoriInput | TanamanUpdateManyWithWhereWithoutKategoriInput[]
    deleteMany?: TanamanScalarWhereInput | TanamanScalarWhereInput[]
  }

  export type kategoriTanamanCreateNestedOneWithoutTanamanInput = {
    create?: XOR<kategoriTanamanCreateWithoutTanamanInput, kategoriTanamanUncheckedCreateWithoutTanamanInput>
    connectOrCreate?: kategoriTanamanCreateOrConnectWithoutTanamanInput
    connect?: kategoriTanamanWhereUniqueInput
  }

  export type InstruksiTanamanCreateNestedManyWithoutTanamanInput = {
    create?: XOR<InstruksiTanamanCreateWithoutTanamanInput, InstruksiTanamanUncheckedCreateWithoutTanamanInput> | InstruksiTanamanCreateWithoutTanamanInput[] | InstruksiTanamanUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: InstruksiTanamanCreateOrConnectWithoutTanamanInput | InstruksiTanamanCreateOrConnectWithoutTanamanInput[]
    createMany?: InstruksiTanamanCreateManyTanamanInputEnvelope
    connect?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
  }

  export type HariPenanamanCreateNestedManyWithoutTanamanInput = {
    create?: XOR<HariPenanamanCreateWithoutTanamanInput, HariPenanamanUncheckedCreateWithoutTanamanInput> | HariPenanamanCreateWithoutTanamanInput[] | HariPenanamanUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: HariPenanamanCreateOrConnectWithoutTanamanInput | HariPenanamanCreateOrConnectWithoutTanamanInput[]
    createMany?: HariPenanamanCreateManyTanamanInputEnvelope
    connect?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
  }

  export type TanamanPenggunaCreateNestedManyWithoutTanamanInput = {
    create?: XOR<TanamanPenggunaCreateWithoutTanamanInput, TanamanPenggunaUncheckedCreateWithoutTanamanInput> | TanamanPenggunaCreateWithoutTanamanInput[] | TanamanPenggunaUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutTanamanInput | TanamanPenggunaCreateOrConnectWithoutTanamanInput[]
    createMany?: TanamanPenggunaCreateManyTanamanInputEnvelope
    connect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
  }

  export type InstruksiTanamanUncheckedCreateNestedManyWithoutTanamanInput = {
    create?: XOR<InstruksiTanamanCreateWithoutTanamanInput, InstruksiTanamanUncheckedCreateWithoutTanamanInput> | InstruksiTanamanCreateWithoutTanamanInput[] | InstruksiTanamanUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: InstruksiTanamanCreateOrConnectWithoutTanamanInput | InstruksiTanamanCreateOrConnectWithoutTanamanInput[]
    createMany?: InstruksiTanamanCreateManyTanamanInputEnvelope
    connect?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
  }

  export type HariPenanamanUncheckedCreateNestedManyWithoutTanamanInput = {
    create?: XOR<HariPenanamanCreateWithoutTanamanInput, HariPenanamanUncheckedCreateWithoutTanamanInput> | HariPenanamanCreateWithoutTanamanInput[] | HariPenanamanUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: HariPenanamanCreateOrConnectWithoutTanamanInput | HariPenanamanCreateOrConnectWithoutTanamanInput[]
    createMany?: HariPenanamanCreateManyTanamanInputEnvelope
    connect?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
  }

  export type TanamanPenggunaUncheckedCreateNestedManyWithoutTanamanInput = {
    create?: XOR<TanamanPenggunaCreateWithoutTanamanInput, TanamanPenggunaUncheckedCreateWithoutTanamanInput> | TanamanPenggunaCreateWithoutTanamanInput[] | TanamanPenggunaUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutTanamanInput | TanamanPenggunaCreateOrConnectWithoutTanamanInput[]
    createMany?: TanamanPenggunaCreateManyTanamanInputEnvelope
    connect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
  }

  export type kategoriTanamanUpdateOneRequiredWithoutTanamanNestedInput = {
    create?: XOR<kategoriTanamanCreateWithoutTanamanInput, kategoriTanamanUncheckedCreateWithoutTanamanInput>
    connectOrCreate?: kategoriTanamanCreateOrConnectWithoutTanamanInput
    upsert?: kategoriTanamanUpsertWithoutTanamanInput
    connect?: kategoriTanamanWhereUniqueInput
    update?: XOR<XOR<kategoriTanamanUpdateToOneWithWhereWithoutTanamanInput, kategoriTanamanUpdateWithoutTanamanInput>, kategoriTanamanUncheckedUpdateWithoutTanamanInput>
  }

  export type InstruksiTanamanUpdateManyWithoutTanamanNestedInput = {
    create?: XOR<InstruksiTanamanCreateWithoutTanamanInput, InstruksiTanamanUncheckedCreateWithoutTanamanInput> | InstruksiTanamanCreateWithoutTanamanInput[] | InstruksiTanamanUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: InstruksiTanamanCreateOrConnectWithoutTanamanInput | InstruksiTanamanCreateOrConnectWithoutTanamanInput[]
    upsert?: InstruksiTanamanUpsertWithWhereUniqueWithoutTanamanInput | InstruksiTanamanUpsertWithWhereUniqueWithoutTanamanInput[]
    createMany?: InstruksiTanamanCreateManyTanamanInputEnvelope
    set?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
    disconnect?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
    delete?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
    connect?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
    update?: InstruksiTanamanUpdateWithWhereUniqueWithoutTanamanInput | InstruksiTanamanUpdateWithWhereUniqueWithoutTanamanInput[]
    updateMany?: InstruksiTanamanUpdateManyWithWhereWithoutTanamanInput | InstruksiTanamanUpdateManyWithWhereWithoutTanamanInput[]
    deleteMany?: InstruksiTanamanScalarWhereInput | InstruksiTanamanScalarWhereInput[]
  }

  export type HariPenanamanUpdateManyWithoutTanamanNestedInput = {
    create?: XOR<HariPenanamanCreateWithoutTanamanInput, HariPenanamanUncheckedCreateWithoutTanamanInput> | HariPenanamanCreateWithoutTanamanInput[] | HariPenanamanUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: HariPenanamanCreateOrConnectWithoutTanamanInput | HariPenanamanCreateOrConnectWithoutTanamanInput[]
    upsert?: HariPenanamanUpsertWithWhereUniqueWithoutTanamanInput | HariPenanamanUpsertWithWhereUniqueWithoutTanamanInput[]
    createMany?: HariPenanamanCreateManyTanamanInputEnvelope
    set?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
    disconnect?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
    delete?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
    connect?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
    update?: HariPenanamanUpdateWithWhereUniqueWithoutTanamanInput | HariPenanamanUpdateWithWhereUniqueWithoutTanamanInput[]
    updateMany?: HariPenanamanUpdateManyWithWhereWithoutTanamanInput | HariPenanamanUpdateManyWithWhereWithoutTanamanInput[]
    deleteMany?: HariPenanamanScalarWhereInput | HariPenanamanScalarWhereInput[]
  }

  export type TanamanPenggunaUpdateManyWithoutTanamanNestedInput = {
    create?: XOR<TanamanPenggunaCreateWithoutTanamanInput, TanamanPenggunaUncheckedCreateWithoutTanamanInput> | TanamanPenggunaCreateWithoutTanamanInput[] | TanamanPenggunaUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutTanamanInput | TanamanPenggunaCreateOrConnectWithoutTanamanInput[]
    upsert?: TanamanPenggunaUpsertWithWhereUniqueWithoutTanamanInput | TanamanPenggunaUpsertWithWhereUniqueWithoutTanamanInput[]
    createMany?: TanamanPenggunaCreateManyTanamanInputEnvelope
    set?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    disconnect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    delete?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    connect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    update?: TanamanPenggunaUpdateWithWhereUniqueWithoutTanamanInput | TanamanPenggunaUpdateWithWhereUniqueWithoutTanamanInput[]
    updateMany?: TanamanPenggunaUpdateManyWithWhereWithoutTanamanInput | TanamanPenggunaUpdateManyWithWhereWithoutTanamanInput[]
    deleteMany?: TanamanPenggunaScalarWhereInput | TanamanPenggunaScalarWhereInput[]
  }

  export type InstruksiTanamanUncheckedUpdateManyWithoutTanamanNestedInput = {
    create?: XOR<InstruksiTanamanCreateWithoutTanamanInput, InstruksiTanamanUncheckedCreateWithoutTanamanInput> | InstruksiTanamanCreateWithoutTanamanInput[] | InstruksiTanamanUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: InstruksiTanamanCreateOrConnectWithoutTanamanInput | InstruksiTanamanCreateOrConnectWithoutTanamanInput[]
    upsert?: InstruksiTanamanUpsertWithWhereUniqueWithoutTanamanInput | InstruksiTanamanUpsertWithWhereUniqueWithoutTanamanInput[]
    createMany?: InstruksiTanamanCreateManyTanamanInputEnvelope
    set?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
    disconnect?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
    delete?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
    connect?: InstruksiTanamanWhereUniqueInput | InstruksiTanamanWhereUniqueInput[]
    update?: InstruksiTanamanUpdateWithWhereUniqueWithoutTanamanInput | InstruksiTanamanUpdateWithWhereUniqueWithoutTanamanInput[]
    updateMany?: InstruksiTanamanUpdateManyWithWhereWithoutTanamanInput | InstruksiTanamanUpdateManyWithWhereWithoutTanamanInput[]
    deleteMany?: InstruksiTanamanScalarWhereInput | InstruksiTanamanScalarWhereInput[]
  }

  export type HariPenanamanUncheckedUpdateManyWithoutTanamanNestedInput = {
    create?: XOR<HariPenanamanCreateWithoutTanamanInput, HariPenanamanUncheckedCreateWithoutTanamanInput> | HariPenanamanCreateWithoutTanamanInput[] | HariPenanamanUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: HariPenanamanCreateOrConnectWithoutTanamanInput | HariPenanamanCreateOrConnectWithoutTanamanInput[]
    upsert?: HariPenanamanUpsertWithWhereUniqueWithoutTanamanInput | HariPenanamanUpsertWithWhereUniqueWithoutTanamanInput[]
    createMany?: HariPenanamanCreateManyTanamanInputEnvelope
    set?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
    disconnect?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
    delete?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
    connect?: HariPenanamanWhereUniqueInput | HariPenanamanWhereUniqueInput[]
    update?: HariPenanamanUpdateWithWhereUniqueWithoutTanamanInput | HariPenanamanUpdateWithWhereUniqueWithoutTanamanInput[]
    updateMany?: HariPenanamanUpdateManyWithWhereWithoutTanamanInput | HariPenanamanUpdateManyWithWhereWithoutTanamanInput[]
    deleteMany?: HariPenanamanScalarWhereInput | HariPenanamanScalarWhereInput[]
  }

  export type TanamanPenggunaUncheckedUpdateManyWithoutTanamanNestedInput = {
    create?: XOR<TanamanPenggunaCreateWithoutTanamanInput, TanamanPenggunaUncheckedCreateWithoutTanamanInput> | TanamanPenggunaCreateWithoutTanamanInput[] | TanamanPenggunaUncheckedCreateWithoutTanamanInput[]
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutTanamanInput | TanamanPenggunaCreateOrConnectWithoutTanamanInput[]
    upsert?: TanamanPenggunaUpsertWithWhereUniqueWithoutTanamanInput | TanamanPenggunaUpsertWithWhereUniqueWithoutTanamanInput[]
    createMany?: TanamanPenggunaCreateManyTanamanInputEnvelope
    set?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    disconnect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    delete?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    connect?: TanamanPenggunaWhereUniqueInput | TanamanPenggunaWhereUniqueInput[]
    update?: TanamanPenggunaUpdateWithWhereUniqueWithoutTanamanInput | TanamanPenggunaUpdateWithWhereUniqueWithoutTanamanInput[]
    updateMany?: TanamanPenggunaUpdateManyWithWhereWithoutTanamanInput | TanamanPenggunaUpdateManyWithWhereWithoutTanamanInput[]
    deleteMany?: TanamanPenggunaScalarWhereInput | TanamanPenggunaScalarWhereInput[]
  }

  export type TanamanCreateNestedOneWithoutInstruksi_tanamanInput = {
    create?: XOR<TanamanCreateWithoutInstruksi_tanamanInput, TanamanUncheckedCreateWithoutInstruksi_tanamanInput>
    connectOrCreate?: TanamanCreateOrConnectWithoutInstruksi_tanamanInput
    connect?: TanamanWhereUniqueInput
  }

  export type TanamanUpdateOneRequiredWithoutInstruksi_tanamanNestedInput = {
    create?: XOR<TanamanCreateWithoutInstruksi_tanamanInput, TanamanUncheckedCreateWithoutInstruksi_tanamanInput>
    connectOrCreate?: TanamanCreateOrConnectWithoutInstruksi_tanamanInput
    upsert?: TanamanUpsertWithoutInstruksi_tanamanInput
    connect?: TanamanWhereUniqueInput
    update?: XOR<XOR<TanamanUpdateToOneWithWhereWithoutInstruksi_tanamanInput, TanamanUpdateWithoutInstruksi_tanamanInput>, TanamanUncheckedUpdateWithoutInstruksi_tanamanInput>
  }

  export type TanamanCreateNestedOneWithoutHari_penanamanInput = {
    create?: XOR<TanamanCreateWithoutHari_penanamanInput, TanamanUncheckedCreateWithoutHari_penanamanInput>
    connectOrCreate?: TanamanCreateOrConnectWithoutHari_penanamanInput
    connect?: TanamanWhereUniqueInput
  }

  export type TugasPenanamanCreateNestedManyWithoutHari_penanamanInput = {
    create?: XOR<TugasPenanamanCreateWithoutHari_penanamanInput, TugasPenanamanUncheckedCreateWithoutHari_penanamanInput> | TugasPenanamanCreateWithoutHari_penanamanInput[] | TugasPenanamanUncheckedCreateWithoutHari_penanamanInput[]
    connectOrCreate?: TugasPenanamanCreateOrConnectWithoutHari_penanamanInput | TugasPenanamanCreateOrConnectWithoutHari_penanamanInput[]
    createMany?: TugasPenanamanCreateManyHari_penanamanInputEnvelope
    connect?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
  }

  export type TugasPenanamanUncheckedCreateNestedManyWithoutHari_penanamanInput = {
    create?: XOR<TugasPenanamanCreateWithoutHari_penanamanInput, TugasPenanamanUncheckedCreateWithoutHari_penanamanInput> | TugasPenanamanCreateWithoutHari_penanamanInput[] | TugasPenanamanUncheckedCreateWithoutHari_penanamanInput[]
    connectOrCreate?: TugasPenanamanCreateOrConnectWithoutHari_penanamanInput | TugasPenanamanCreateOrConnectWithoutHari_penanamanInput[]
    createMany?: TugasPenanamanCreateManyHari_penanamanInputEnvelope
    connect?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
  }

  export type TanamanUpdateOneRequiredWithoutHari_penanamanNestedInput = {
    create?: XOR<TanamanCreateWithoutHari_penanamanInput, TanamanUncheckedCreateWithoutHari_penanamanInput>
    connectOrCreate?: TanamanCreateOrConnectWithoutHari_penanamanInput
    upsert?: TanamanUpsertWithoutHari_penanamanInput
    connect?: TanamanWhereUniqueInput
    update?: XOR<XOR<TanamanUpdateToOneWithWhereWithoutHari_penanamanInput, TanamanUpdateWithoutHari_penanamanInput>, TanamanUncheckedUpdateWithoutHari_penanamanInput>
  }

  export type TugasPenanamanUpdateManyWithoutHari_penanamanNestedInput = {
    create?: XOR<TugasPenanamanCreateWithoutHari_penanamanInput, TugasPenanamanUncheckedCreateWithoutHari_penanamanInput> | TugasPenanamanCreateWithoutHari_penanamanInput[] | TugasPenanamanUncheckedCreateWithoutHari_penanamanInput[]
    connectOrCreate?: TugasPenanamanCreateOrConnectWithoutHari_penanamanInput | TugasPenanamanCreateOrConnectWithoutHari_penanamanInput[]
    upsert?: TugasPenanamanUpsertWithWhereUniqueWithoutHari_penanamanInput | TugasPenanamanUpsertWithWhereUniqueWithoutHari_penanamanInput[]
    createMany?: TugasPenanamanCreateManyHari_penanamanInputEnvelope
    set?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
    disconnect?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
    delete?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
    connect?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
    update?: TugasPenanamanUpdateWithWhereUniqueWithoutHari_penanamanInput | TugasPenanamanUpdateWithWhereUniqueWithoutHari_penanamanInput[]
    updateMany?: TugasPenanamanUpdateManyWithWhereWithoutHari_penanamanInput | TugasPenanamanUpdateManyWithWhereWithoutHari_penanamanInput[]
    deleteMany?: TugasPenanamanScalarWhereInput | TugasPenanamanScalarWhereInput[]
  }

  export type TugasPenanamanUncheckedUpdateManyWithoutHari_penanamanNestedInput = {
    create?: XOR<TugasPenanamanCreateWithoutHari_penanamanInput, TugasPenanamanUncheckedCreateWithoutHari_penanamanInput> | TugasPenanamanCreateWithoutHari_penanamanInput[] | TugasPenanamanUncheckedCreateWithoutHari_penanamanInput[]
    connectOrCreate?: TugasPenanamanCreateOrConnectWithoutHari_penanamanInput | TugasPenanamanCreateOrConnectWithoutHari_penanamanInput[]
    upsert?: TugasPenanamanUpsertWithWhereUniqueWithoutHari_penanamanInput | TugasPenanamanUpsertWithWhereUniqueWithoutHari_penanamanInput[]
    createMany?: TugasPenanamanCreateManyHari_penanamanInputEnvelope
    set?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
    disconnect?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
    delete?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
    connect?: TugasPenanamanWhereUniqueInput | TugasPenanamanWhereUniqueInput[]
    update?: TugasPenanamanUpdateWithWhereUniqueWithoutHari_penanamanInput | TugasPenanamanUpdateWithWhereUniqueWithoutHari_penanamanInput[]
    updateMany?: TugasPenanamanUpdateManyWithWhereWithoutHari_penanamanInput | TugasPenanamanUpdateManyWithWhereWithoutHari_penanamanInput[]
    deleteMany?: TugasPenanamanScalarWhereInput | TugasPenanamanScalarWhereInput[]
  }

  export type HariPenanamanCreateNestedOneWithoutTugas_penanamanInput = {
    create?: XOR<HariPenanamanCreateWithoutTugas_penanamanInput, HariPenanamanUncheckedCreateWithoutTugas_penanamanInput>
    connectOrCreate?: HariPenanamanCreateOrConnectWithoutTugas_penanamanInput
    connect?: HariPenanamanWhereUniqueInput
  }

  export type HariPenanamanUpdateOneRequiredWithoutTugas_penanamanNestedInput = {
    create?: XOR<HariPenanamanCreateWithoutTugas_penanamanInput, HariPenanamanUncheckedCreateWithoutTugas_penanamanInput>
    connectOrCreate?: HariPenanamanCreateOrConnectWithoutTugas_penanamanInput
    upsert?: HariPenanamanUpsertWithoutTugas_penanamanInput
    connect?: HariPenanamanWhereUniqueInput
    update?: XOR<XOR<HariPenanamanUpdateToOneWithWhereWithoutTugas_penanamanInput, HariPenanamanUpdateWithoutTugas_penanamanInput>, HariPenanamanUncheckedUpdateWithoutTugas_penanamanInput>
  }

  export type TanamanCreateNestedOneWithoutTanaman_penggunaInput = {
    create?: XOR<TanamanCreateWithoutTanaman_penggunaInput, TanamanUncheckedCreateWithoutTanaman_penggunaInput>
    connectOrCreate?: TanamanCreateOrConnectWithoutTanaman_penggunaInput
    connect?: TanamanWhereUniqueInput
  }

  export type PenggunaCreateNestedOneWithoutTanaman_penggunaInput = {
    create?: XOR<PenggunaCreateWithoutTanaman_penggunaInput, PenggunaUncheckedCreateWithoutTanaman_penggunaInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutTanaman_penggunaInput
    connect?: PenggunaWhereUniqueInput
  }

  export type HariTanamanPenggunaCreateNestedManyWithoutTanaman_penggunaInput = {
    create?: XOR<HariTanamanPenggunaCreateWithoutTanaman_penggunaInput, HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput> | HariTanamanPenggunaCreateWithoutTanaman_penggunaInput[] | HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput[]
    connectOrCreate?: HariTanamanPenggunaCreateOrConnectWithoutTanaman_penggunaInput | HariTanamanPenggunaCreateOrConnectWithoutTanaman_penggunaInput[]
    createMany?: HariTanamanPenggunaCreateManyTanaman_penggunaInputEnvelope
    connect?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
  }

  export type HariTanamanPenggunaUncheckedCreateNestedManyWithoutTanaman_penggunaInput = {
    create?: XOR<HariTanamanPenggunaCreateWithoutTanaman_penggunaInput, HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput> | HariTanamanPenggunaCreateWithoutTanaman_penggunaInput[] | HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput[]
    connectOrCreate?: HariTanamanPenggunaCreateOrConnectWithoutTanaman_penggunaInput | HariTanamanPenggunaCreateOrConnectWithoutTanaman_penggunaInput[]
    createMany?: HariTanamanPenggunaCreateManyTanaman_penggunaInputEnvelope
    connect?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
  }

  export type TanamanUpdateOneRequiredWithoutTanaman_penggunaNestedInput = {
    create?: XOR<TanamanCreateWithoutTanaman_penggunaInput, TanamanUncheckedCreateWithoutTanaman_penggunaInput>
    connectOrCreate?: TanamanCreateOrConnectWithoutTanaman_penggunaInput
    upsert?: TanamanUpsertWithoutTanaman_penggunaInput
    connect?: TanamanWhereUniqueInput
    update?: XOR<XOR<TanamanUpdateToOneWithWhereWithoutTanaman_penggunaInput, TanamanUpdateWithoutTanaman_penggunaInput>, TanamanUncheckedUpdateWithoutTanaman_penggunaInput>
  }

  export type PenggunaUpdateOneRequiredWithoutTanaman_penggunaNestedInput = {
    create?: XOR<PenggunaCreateWithoutTanaman_penggunaInput, PenggunaUncheckedCreateWithoutTanaman_penggunaInput>
    connectOrCreate?: PenggunaCreateOrConnectWithoutTanaman_penggunaInput
    upsert?: PenggunaUpsertWithoutTanaman_penggunaInput
    connect?: PenggunaWhereUniqueInput
    update?: XOR<XOR<PenggunaUpdateToOneWithWhereWithoutTanaman_penggunaInput, PenggunaUpdateWithoutTanaman_penggunaInput>, PenggunaUncheckedUpdateWithoutTanaman_penggunaInput>
  }

  export type HariTanamanPenggunaUpdateManyWithoutTanaman_penggunaNestedInput = {
    create?: XOR<HariTanamanPenggunaCreateWithoutTanaman_penggunaInput, HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput> | HariTanamanPenggunaCreateWithoutTanaman_penggunaInput[] | HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput[]
    connectOrCreate?: HariTanamanPenggunaCreateOrConnectWithoutTanaman_penggunaInput | HariTanamanPenggunaCreateOrConnectWithoutTanaman_penggunaInput[]
    upsert?: HariTanamanPenggunaUpsertWithWhereUniqueWithoutTanaman_penggunaInput | HariTanamanPenggunaUpsertWithWhereUniqueWithoutTanaman_penggunaInput[]
    createMany?: HariTanamanPenggunaCreateManyTanaman_penggunaInputEnvelope
    set?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
    disconnect?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
    delete?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
    connect?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
    update?: HariTanamanPenggunaUpdateWithWhereUniqueWithoutTanaman_penggunaInput | HariTanamanPenggunaUpdateWithWhereUniqueWithoutTanaman_penggunaInput[]
    updateMany?: HariTanamanPenggunaUpdateManyWithWhereWithoutTanaman_penggunaInput | HariTanamanPenggunaUpdateManyWithWhereWithoutTanaman_penggunaInput[]
    deleteMany?: HariTanamanPenggunaScalarWhereInput | HariTanamanPenggunaScalarWhereInput[]
  }

  export type HariTanamanPenggunaUncheckedUpdateManyWithoutTanaman_penggunaNestedInput = {
    create?: XOR<HariTanamanPenggunaCreateWithoutTanaman_penggunaInput, HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput> | HariTanamanPenggunaCreateWithoutTanaman_penggunaInput[] | HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput[]
    connectOrCreate?: HariTanamanPenggunaCreateOrConnectWithoutTanaman_penggunaInput | HariTanamanPenggunaCreateOrConnectWithoutTanaman_penggunaInput[]
    upsert?: HariTanamanPenggunaUpsertWithWhereUniqueWithoutTanaman_penggunaInput | HariTanamanPenggunaUpsertWithWhereUniqueWithoutTanaman_penggunaInput[]
    createMany?: HariTanamanPenggunaCreateManyTanaman_penggunaInputEnvelope
    set?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
    disconnect?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
    delete?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
    connect?: HariTanamanPenggunaWhereUniqueInput | HariTanamanPenggunaWhereUniqueInput[]
    update?: HariTanamanPenggunaUpdateWithWhereUniqueWithoutTanaman_penggunaInput | HariTanamanPenggunaUpdateWithWhereUniqueWithoutTanaman_penggunaInput[]
    updateMany?: HariTanamanPenggunaUpdateManyWithWhereWithoutTanaman_penggunaInput | HariTanamanPenggunaUpdateManyWithWhereWithoutTanaman_penggunaInput[]
    deleteMany?: HariTanamanPenggunaScalarWhereInput | HariTanamanPenggunaScalarWhereInput[]
  }

  export type TugasPenanamanPenggunaCreateNestedManyWithoutHari_tanamanInput = {
    create?: XOR<TugasPenanamanPenggunaCreateWithoutHari_tanamanInput, TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput> | TugasPenanamanPenggunaCreateWithoutHari_tanamanInput[] | TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput[]
    connectOrCreate?: TugasPenanamanPenggunaCreateOrConnectWithoutHari_tanamanInput | TugasPenanamanPenggunaCreateOrConnectWithoutHari_tanamanInput[]
    createMany?: TugasPenanamanPenggunaCreateManyHari_tanamanInputEnvelope
    connect?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
  }

  export type TanamanPenggunaCreateNestedOneWithoutHari_tanamanInput = {
    create?: XOR<TanamanPenggunaCreateWithoutHari_tanamanInput, TanamanPenggunaUncheckedCreateWithoutHari_tanamanInput>
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutHari_tanamanInput
    connect?: TanamanPenggunaWhereUniqueInput
  }

  export type TugasPenanamanPenggunaUncheckedCreateNestedManyWithoutHari_tanamanInput = {
    create?: XOR<TugasPenanamanPenggunaCreateWithoutHari_tanamanInput, TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput> | TugasPenanamanPenggunaCreateWithoutHari_tanamanInput[] | TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput[]
    connectOrCreate?: TugasPenanamanPenggunaCreateOrConnectWithoutHari_tanamanInput | TugasPenanamanPenggunaCreateOrConnectWithoutHari_tanamanInput[]
    createMany?: TugasPenanamanPenggunaCreateManyHari_tanamanInputEnvelope
    connect?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
  }

  export type TugasPenanamanPenggunaUpdateManyWithoutHari_tanamanNestedInput = {
    create?: XOR<TugasPenanamanPenggunaCreateWithoutHari_tanamanInput, TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput> | TugasPenanamanPenggunaCreateWithoutHari_tanamanInput[] | TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput[]
    connectOrCreate?: TugasPenanamanPenggunaCreateOrConnectWithoutHari_tanamanInput | TugasPenanamanPenggunaCreateOrConnectWithoutHari_tanamanInput[]
    upsert?: TugasPenanamanPenggunaUpsertWithWhereUniqueWithoutHari_tanamanInput | TugasPenanamanPenggunaUpsertWithWhereUniqueWithoutHari_tanamanInput[]
    createMany?: TugasPenanamanPenggunaCreateManyHari_tanamanInputEnvelope
    set?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
    disconnect?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
    delete?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
    connect?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
    update?: TugasPenanamanPenggunaUpdateWithWhereUniqueWithoutHari_tanamanInput | TugasPenanamanPenggunaUpdateWithWhereUniqueWithoutHari_tanamanInput[]
    updateMany?: TugasPenanamanPenggunaUpdateManyWithWhereWithoutHari_tanamanInput | TugasPenanamanPenggunaUpdateManyWithWhereWithoutHari_tanamanInput[]
    deleteMany?: TugasPenanamanPenggunaScalarWhereInput | TugasPenanamanPenggunaScalarWhereInput[]
  }

  export type TanamanPenggunaUpdateOneRequiredWithoutHari_tanamanNestedInput = {
    create?: XOR<TanamanPenggunaCreateWithoutHari_tanamanInput, TanamanPenggunaUncheckedCreateWithoutHari_tanamanInput>
    connectOrCreate?: TanamanPenggunaCreateOrConnectWithoutHari_tanamanInput
    upsert?: TanamanPenggunaUpsertWithoutHari_tanamanInput
    connect?: TanamanPenggunaWhereUniqueInput
    update?: XOR<XOR<TanamanPenggunaUpdateToOneWithWhereWithoutHari_tanamanInput, TanamanPenggunaUpdateWithoutHari_tanamanInput>, TanamanPenggunaUncheckedUpdateWithoutHari_tanamanInput>
  }

  export type TugasPenanamanPenggunaUncheckedUpdateManyWithoutHari_tanamanNestedInput = {
    create?: XOR<TugasPenanamanPenggunaCreateWithoutHari_tanamanInput, TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput> | TugasPenanamanPenggunaCreateWithoutHari_tanamanInput[] | TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput[]
    connectOrCreate?: TugasPenanamanPenggunaCreateOrConnectWithoutHari_tanamanInput | TugasPenanamanPenggunaCreateOrConnectWithoutHari_tanamanInput[]
    upsert?: TugasPenanamanPenggunaUpsertWithWhereUniqueWithoutHari_tanamanInput | TugasPenanamanPenggunaUpsertWithWhereUniqueWithoutHari_tanamanInput[]
    createMany?: TugasPenanamanPenggunaCreateManyHari_tanamanInputEnvelope
    set?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
    disconnect?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
    delete?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
    connect?: TugasPenanamanPenggunaWhereUniqueInput | TugasPenanamanPenggunaWhereUniqueInput[]
    update?: TugasPenanamanPenggunaUpdateWithWhereUniqueWithoutHari_tanamanInput | TugasPenanamanPenggunaUpdateWithWhereUniqueWithoutHari_tanamanInput[]
    updateMany?: TugasPenanamanPenggunaUpdateManyWithWhereWithoutHari_tanamanInput | TugasPenanamanPenggunaUpdateManyWithWhereWithoutHari_tanamanInput[]
    deleteMany?: TugasPenanamanPenggunaScalarWhereInput | TugasPenanamanPenggunaScalarWhereInput[]
  }

  export type HariTanamanPenggunaCreateNestedOneWithoutTugas_penanamanInput = {
    create?: XOR<HariTanamanPenggunaCreateWithoutTugas_penanamanInput, HariTanamanPenggunaUncheckedCreateWithoutTugas_penanamanInput>
    connectOrCreate?: HariTanamanPenggunaCreateOrConnectWithoutTugas_penanamanInput
    connect?: HariTanamanPenggunaWhereUniqueInput
  }

  export type HariTanamanPenggunaUpdateOneRequiredWithoutTugas_penanamanNestedInput = {
    create?: XOR<HariTanamanPenggunaCreateWithoutTugas_penanamanInput, HariTanamanPenggunaUncheckedCreateWithoutTugas_penanamanInput>
    connectOrCreate?: HariTanamanPenggunaCreateOrConnectWithoutTugas_penanamanInput
    upsert?: HariTanamanPenggunaUpsertWithoutTugas_penanamanInput
    connect?: HariTanamanPenggunaWhereUniqueInput
    update?: XOR<XOR<HariTanamanPenggunaUpdateToOneWithWhereWithoutTugas_penanamanInput, HariTanamanPenggunaUpdateWithoutTugas_penanamanInput>, HariTanamanPenggunaUncheckedUpdateWithoutTugas_penanamanInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumStatusArtikelFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusArtikel | EnumStatusArtikelFieldRefInput<$PrismaModel>
    in?: $Enums.StatusArtikel[] | ListEnumStatusArtikelFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusArtikel[] | ListEnumStatusArtikelFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusArtikelFilter<$PrismaModel> | $Enums.StatusArtikel
  }

  export type NestedEnumStatusArtikelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusArtikel | EnumStatusArtikelFieldRefInput<$PrismaModel>
    in?: $Enums.StatusArtikel[] | ListEnumStatusArtikelFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusArtikel[] | ListEnumStatusArtikelFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusArtikelWithAggregatesFilter<$PrismaModel> | $Enums.StatusArtikel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusArtikelFilter<$PrismaModel>
    _max?: NestedEnumStatusArtikelFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type KabupatenCreateWithoutProvinsiInput = {
    nama_kabupaten: string
    type: string
    facilitators?: FacilitatorCreateNestedManyWithoutKabupatenInput
    workshop?: WorkshopCreateNestedManyWithoutKabupatenInput
  }

  export type KabupatenUncheckedCreateWithoutProvinsiInput = {
    id_kabupaten?: number
    nama_kabupaten: string
    type: string
    facilitators?: FacilitatorUncheckedCreateNestedManyWithoutKabupatenInput
    workshop?: WorkshopUncheckedCreateNestedManyWithoutKabupatenInput
  }

  export type KabupatenCreateOrConnectWithoutProvinsiInput = {
    where: KabupatenWhereUniqueInput
    create: XOR<KabupatenCreateWithoutProvinsiInput, KabupatenUncheckedCreateWithoutProvinsiInput>
  }

  export type KabupatenCreateManyProvinsiInputEnvelope = {
    data: KabupatenCreateManyProvinsiInput | KabupatenCreateManyProvinsiInput[]
    skipDuplicates?: boolean
  }

  export type KabupatenUpsertWithWhereUniqueWithoutProvinsiInput = {
    where: KabupatenWhereUniqueInput
    update: XOR<KabupatenUpdateWithoutProvinsiInput, KabupatenUncheckedUpdateWithoutProvinsiInput>
    create: XOR<KabupatenCreateWithoutProvinsiInput, KabupatenUncheckedCreateWithoutProvinsiInput>
  }

  export type KabupatenUpdateWithWhereUniqueWithoutProvinsiInput = {
    where: KabupatenWhereUniqueInput
    data: XOR<KabupatenUpdateWithoutProvinsiInput, KabupatenUncheckedUpdateWithoutProvinsiInput>
  }

  export type KabupatenUpdateManyWithWhereWithoutProvinsiInput = {
    where: KabupatenScalarWhereInput
    data: XOR<KabupatenUpdateManyMutationInput, KabupatenUncheckedUpdateManyWithoutProvinsiInput>
  }

  export type KabupatenScalarWhereInput = {
    AND?: KabupatenScalarWhereInput | KabupatenScalarWhereInput[]
    OR?: KabupatenScalarWhereInput[]
    NOT?: KabupatenScalarWhereInput | KabupatenScalarWhereInput[]
    id_kabupaten?: IntFilter<"Kabupaten"> | number
    nama_kabupaten?: StringFilter<"Kabupaten"> | string
    type?: StringFilter<"Kabupaten"> | string
    id_provinsi?: IntFilter<"Kabupaten"> | number
  }

  export type ProvinsiCreateWithoutKabupatenInput = {
    nama_provinsi: string
  }

  export type ProvinsiUncheckedCreateWithoutKabupatenInput = {
    id_provinsi?: number
    nama_provinsi: string
  }

  export type ProvinsiCreateOrConnectWithoutKabupatenInput = {
    where: ProvinsiWhereUniqueInput
    create: XOR<ProvinsiCreateWithoutKabupatenInput, ProvinsiUncheckedCreateWithoutKabupatenInput>
  }

  export type FacilitatorCreateWithoutKabupatenInput = {
    id_facilitator?: string
    nama_facilitator: string
    email_facilitator: string
    nomor_telepon_facilitator: string
    password_facilitator: string
    tanggal_pembuatan_akun: Date | string
    alamat_lengkap_facilitator: string
    avatar?: string | null
    status_aktif?: boolean
    workshops?: WorkshopCreateNestedManyWithoutFacilitatorInput
  }

  export type FacilitatorUncheckedCreateWithoutKabupatenInput = {
    id_facilitator?: string
    nama_facilitator: string
    email_facilitator: string
    nomor_telepon_facilitator: string
    password_facilitator: string
    tanggal_pembuatan_akun: Date | string
    alamat_lengkap_facilitator: string
    avatar?: string | null
    status_aktif?: boolean
    workshops?: WorkshopUncheckedCreateNestedManyWithoutFacilitatorInput
  }

  export type FacilitatorCreateOrConnectWithoutKabupatenInput = {
    where: FacilitatorWhereUniqueInput
    create: XOR<FacilitatorCreateWithoutKabupatenInput, FacilitatorUncheckedCreateWithoutKabupatenInput>
  }

  export type FacilitatorCreateManyKabupatenInputEnvelope = {
    data: FacilitatorCreateManyKabupatenInput | FacilitatorCreateManyKabupatenInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopCreateWithoutKabupatenInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    facilitator: FacilitatorCreateNestedOneWithoutWorkshopsInput
    pendaftaran?: WorkshopTerdaftarCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutKabupatenInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    id_facilitator: string
    pendaftaran?: WorkshopTerdaftarUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutKabupatenInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutKabupatenInput, WorkshopUncheckedCreateWithoutKabupatenInput>
  }

  export type WorkshopCreateManyKabupatenInputEnvelope = {
    data: WorkshopCreateManyKabupatenInput | WorkshopCreateManyKabupatenInput[]
    skipDuplicates?: boolean
  }

  export type ProvinsiUpsertWithoutKabupatenInput = {
    update: XOR<ProvinsiUpdateWithoutKabupatenInput, ProvinsiUncheckedUpdateWithoutKabupatenInput>
    create: XOR<ProvinsiCreateWithoutKabupatenInput, ProvinsiUncheckedCreateWithoutKabupatenInput>
    where?: ProvinsiWhereInput
  }

  export type ProvinsiUpdateToOneWithWhereWithoutKabupatenInput = {
    where?: ProvinsiWhereInput
    data: XOR<ProvinsiUpdateWithoutKabupatenInput, ProvinsiUncheckedUpdateWithoutKabupatenInput>
  }

  export type ProvinsiUpdateWithoutKabupatenInput = {
    nama_provinsi?: StringFieldUpdateOperationsInput | string
  }

  export type ProvinsiUncheckedUpdateWithoutKabupatenInput = {
    id_provinsi?: IntFieldUpdateOperationsInput | number
    nama_provinsi?: StringFieldUpdateOperationsInput | string
  }

  export type FacilitatorUpsertWithWhereUniqueWithoutKabupatenInput = {
    where: FacilitatorWhereUniqueInput
    update: XOR<FacilitatorUpdateWithoutKabupatenInput, FacilitatorUncheckedUpdateWithoutKabupatenInput>
    create: XOR<FacilitatorCreateWithoutKabupatenInput, FacilitatorUncheckedCreateWithoutKabupatenInput>
  }

  export type FacilitatorUpdateWithWhereUniqueWithoutKabupatenInput = {
    where: FacilitatorWhereUniqueInput
    data: XOR<FacilitatorUpdateWithoutKabupatenInput, FacilitatorUncheckedUpdateWithoutKabupatenInput>
  }

  export type FacilitatorUpdateManyWithWhereWithoutKabupatenInput = {
    where: FacilitatorScalarWhereInput
    data: XOR<FacilitatorUpdateManyMutationInput, FacilitatorUncheckedUpdateManyWithoutKabupatenInput>
  }

  export type FacilitatorScalarWhereInput = {
    AND?: FacilitatorScalarWhereInput | FacilitatorScalarWhereInput[]
    OR?: FacilitatorScalarWhereInput[]
    NOT?: FacilitatorScalarWhereInput | FacilitatorScalarWhereInput[]
    id_facilitator?: StringFilter<"Facilitator"> | string
    nama_facilitator?: StringFilter<"Facilitator"> | string
    email_facilitator?: StringFilter<"Facilitator"> | string
    nomor_telepon_facilitator?: StringFilter<"Facilitator"> | string
    password_facilitator?: StringFilter<"Facilitator"> | string
    tanggal_pembuatan_akun?: DateTimeFilter<"Facilitator"> | Date | string
    alamat_lengkap_facilitator?: StringFilter<"Facilitator"> | string
    avatar?: StringNullableFilter<"Facilitator"> | string | null
    status_aktif?: BoolFilter<"Facilitator"> | boolean
    id_kabupaten?: IntFilter<"Facilitator"> | number
  }

  export type WorkshopUpsertWithWhereUniqueWithoutKabupatenInput = {
    where: WorkshopWhereUniqueInput
    update: XOR<WorkshopUpdateWithoutKabupatenInput, WorkshopUncheckedUpdateWithoutKabupatenInput>
    create: XOR<WorkshopCreateWithoutKabupatenInput, WorkshopUncheckedCreateWithoutKabupatenInput>
  }

  export type WorkshopUpdateWithWhereUniqueWithoutKabupatenInput = {
    where: WorkshopWhereUniqueInput
    data: XOR<WorkshopUpdateWithoutKabupatenInput, WorkshopUncheckedUpdateWithoutKabupatenInput>
  }

  export type WorkshopUpdateManyWithWhereWithoutKabupatenInput = {
    where: WorkshopScalarWhereInput
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyWithoutKabupatenInput>
  }

  export type WorkshopScalarWhereInput = {
    AND?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
    OR?: WorkshopScalarWhereInput[]
    NOT?: WorkshopScalarWhereInput | WorkshopScalarWhereInput[]
    id_workshop?: StringFilter<"Workshop"> | string
    judul_workshop?: StringFilter<"Workshop"> | string
    tanggal_workshop?: DateTimeFilter<"Workshop"> | Date | string
    alaamt_lengkap_workshop?: StringFilter<"Workshop"> | string
    deskripsi_workshop?: StringFilter<"Workshop"> | string
    harga_workshop?: DecimalFilter<"Workshop"> | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFilter<"Workshop"> | number
    status_verifikasi?: BoolFilter<"Workshop"> | boolean
    lat_lokasi?: FloatFilter<"Workshop"> | number
    long_lokasi?: FloatFilter<"Workshop"> | number
    gambar_workshop?: StringFilter<"Workshop"> | string
    status_aktif?: BoolFilter<"Workshop"> | boolean
    id_facilitator?: StringFilter<"Workshop"> | string
    id_kabupaten?: IntFilter<"Workshop"> | number
  }

  export type WorkshopTerdaftarCreateWithoutPenggunaInput = {
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran?: Date | string
    status_pembayaran: string
    nomor_tiket?: string | null
    workshop: WorkshopCreateNestedOneWithoutPendaftaranInput
  }

  export type WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput = {
    id_pendaftaran?: number
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran?: Date | string
    status_pembayaran: string
    nomor_tiket?: string | null
    id_workshop: string
  }

  export type WorkshopTerdaftarCreateOrConnectWithoutPenggunaInput = {
    where: WorkshopTerdaftarWhereUniqueInput
    create: XOR<WorkshopTerdaftarCreateWithoutPenggunaInput, WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput>
  }

  export type WorkshopTerdaftarCreateManyPenggunaInputEnvelope = {
    data: WorkshopTerdaftarCreateManyPenggunaInput | WorkshopTerdaftarCreateManyPenggunaInput[]
    skipDuplicates?: boolean
  }

  export type ArtikelCreateWithoutPenggunaInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    kategori: KategoriArtikelCreateNestedOneWithoutArtikelInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutArtikelInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelUncheckedCreateWithoutPenggunaInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    id_kategori_artikel: number
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutArtikelInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelCreateOrConnectWithoutPenggunaInput = {
    where: ArtikelWhereUniqueInput
    create: XOR<ArtikelCreateWithoutPenggunaInput, ArtikelUncheckedCreateWithoutPenggunaInput>
  }

  export type ArtikelCreateManyPenggunaInputEnvelope = {
    data: ArtikelCreateManyPenggunaInput | ArtikelCreateManyPenggunaInput[]
    skipDuplicates?: boolean
  }

  export type ArtikelDisimpanCreateWithoutPenggunaInput = {
    artikel: ArtikelCreateNestedOneWithoutArtikel_disimpanInput
  }

  export type ArtikelDisimpanUncheckedCreateWithoutPenggunaInput = {
    id_penyimpanan?: number
    id_artikel: string
  }

  export type ArtikelDisimpanCreateOrConnectWithoutPenggunaInput = {
    where: ArtikelDisimpanWhereUniqueInput
    create: XOR<ArtikelDisimpanCreateWithoutPenggunaInput, ArtikelDisimpanUncheckedCreateWithoutPenggunaInput>
  }

  export type ArtikelDisimpanCreateManyPenggunaInputEnvelope = {
    data: ArtikelDisimpanCreateManyPenggunaInput | ArtikelDisimpanCreateManyPenggunaInput[]
    skipDuplicates?: boolean
  }

  export type ArtikelDisukaiCreateWithoutPenggunaInput = {
    rating: number
    artikel: ArtikelCreateNestedOneWithoutArtikel_disukaiInput
  }

  export type ArtikelDisukaiUncheckedCreateWithoutPenggunaInput = {
    id_disukai?: number
    id_artikel: string
    rating: number
  }

  export type ArtikelDisukaiCreateOrConnectWithoutPenggunaInput = {
    where: ArtikelDisukaiWhereUniqueInput
    create: XOR<ArtikelDisukaiCreateWithoutPenggunaInput, ArtikelDisukaiUncheckedCreateWithoutPenggunaInput>
  }

  export type ArtikelDisukaiCreateManyPenggunaInputEnvelope = {
    data: ArtikelDisukaiCreateManyPenggunaInput | ArtikelDisukaiCreateManyPenggunaInput[]
    skipDuplicates?: boolean
  }

  export type KomentarArtikelCreateWithoutPenggunaInput = {
    komentar: string
    artikel: ArtikelCreateNestedOneWithoutKomentar_artikelInput
  }

  export type KomentarArtikelUncheckedCreateWithoutPenggunaInput = {
    id_komentar?: number
    id_artikel: string
    komentar: string
  }

  export type KomentarArtikelCreateOrConnectWithoutPenggunaInput = {
    where: KomentarArtikelWhereUniqueInput
    create: XOR<KomentarArtikelCreateWithoutPenggunaInput, KomentarArtikelUncheckedCreateWithoutPenggunaInput>
  }

  export type KomentarArtikelCreateManyPenggunaInputEnvelope = {
    data: KomentarArtikelCreateManyPenggunaInput | KomentarArtikelCreateManyPenggunaInput[]
    skipDuplicates?: boolean
  }

  export type TanamanPenggunaCreateWithoutPenggunaInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    tanaman: TanamanCreateNestedOneWithoutTanaman_penggunaInput
    hari_tanaman?: HariTanamanPenggunaCreateNestedManyWithoutTanaman_penggunaInput
  }

  export type TanamanPenggunaUncheckedCreateWithoutPenggunaInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    id_tanaman: string
    hari_tanaman?: HariTanamanPenggunaUncheckedCreateNestedManyWithoutTanaman_penggunaInput
  }

  export type TanamanPenggunaCreateOrConnectWithoutPenggunaInput = {
    where: TanamanPenggunaWhereUniqueInput
    create: XOR<TanamanPenggunaCreateWithoutPenggunaInput, TanamanPenggunaUncheckedCreateWithoutPenggunaInput>
  }

  export type TanamanPenggunaCreateManyPenggunaInputEnvelope = {
    data: TanamanPenggunaCreateManyPenggunaInput | TanamanPenggunaCreateManyPenggunaInput[]
    skipDuplicates?: boolean
  }

  export type WorkshopTerdaftarUpsertWithWhereUniqueWithoutPenggunaInput = {
    where: WorkshopTerdaftarWhereUniqueInput
    update: XOR<WorkshopTerdaftarUpdateWithoutPenggunaInput, WorkshopTerdaftarUncheckedUpdateWithoutPenggunaInput>
    create: XOR<WorkshopTerdaftarCreateWithoutPenggunaInput, WorkshopTerdaftarUncheckedCreateWithoutPenggunaInput>
  }

  export type WorkshopTerdaftarUpdateWithWhereUniqueWithoutPenggunaInput = {
    where: WorkshopTerdaftarWhereUniqueInput
    data: XOR<WorkshopTerdaftarUpdateWithoutPenggunaInput, WorkshopTerdaftarUncheckedUpdateWithoutPenggunaInput>
  }

  export type WorkshopTerdaftarUpdateManyWithWhereWithoutPenggunaInput = {
    where: WorkshopTerdaftarScalarWhereInput
    data: XOR<WorkshopTerdaftarUpdateManyMutationInput, WorkshopTerdaftarUncheckedUpdateManyWithoutPenggunaInput>
  }

  export type WorkshopTerdaftarScalarWhereInput = {
    AND?: WorkshopTerdaftarScalarWhereInput | WorkshopTerdaftarScalarWhereInput[]
    OR?: WorkshopTerdaftarScalarWhereInput[]
    NOT?: WorkshopTerdaftarScalarWhereInput | WorkshopTerdaftarScalarWhereInput[]
    id_pendaftaran?: IntFilter<"WorkshopTerdaftar"> | number
    nama_peserta?: StringFilter<"WorkshopTerdaftar"> | string
    email_peserta?: StringFilter<"WorkshopTerdaftar"> | string
    nomor_telepon_peserta?: StringFilter<"WorkshopTerdaftar"> | string
    tanggal_pendaftaran?: DateTimeFilter<"WorkshopTerdaftar"> | Date | string
    status_pembayaran?: StringFilter<"WorkshopTerdaftar"> | string
    nomor_tiket?: StringNullableFilter<"WorkshopTerdaftar"> | string | null
    id_pengguna?: StringFilter<"WorkshopTerdaftar"> | string
    id_workshop?: StringFilter<"WorkshopTerdaftar"> | string
  }

  export type ArtikelUpsertWithWhereUniqueWithoutPenggunaInput = {
    where: ArtikelWhereUniqueInput
    update: XOR<ArtikelUpdateWithoutPenggunaInput, ArtikelUncheckedUpdateWithoutPenggunaInput>
    create: XOR<ArtikelCreateWithoutPenggunaInput, ArtikelUncheckedCreateWithoutPenggunaInput>
  }

  export type ArtikelUpdateWithWhereUniqueWithoutPenggunaInput = {
    where: ArtikelWhereUniqueInput
    data: XOR<ArtikelUpdateWithoutPenggunaInput, ArtikelUncheckedUpdateWithoutPenggunaInput>
  }

  export type ArtikelUpdateManyWithWhereWithoutPenggunaInput = {
    where: ArtikelScalarWhereInput
    data: XOR<ArtikelUpdateManyMutationInput, ArtikelUncheckedUpdateManyWithoutPenggunaInput>
  }

  export type ArtikelScalarWhereInput = {
    AND?: ArtikelScalarWhereInput | ArtikelScalarWhereInput[]
    OR?: ArtikelScalarWhereInput[]
    NOT?: ArtikelScalarWhereInput | ArtikelScalarWhereInput[]
    id_artikel?: StringFilter<"Artikel"> | string
    judul_artikel?: StringFilter<"Artikel"> | string
    tanggal_artikel?: DateTimeFilter<"Artikel"> | Date | string
    deskripsi_artikel?: StringFilter<"Artikel"> | string
    isi_artikel?: StringFilter<"Artikel"> | string
    status_artikel?: EnumStatusArtikelFilter<"Artikel"> | $Enums.StatusArtikel
    status_verifikasi?: BoolFilter<"Artikel"> | boolean
    gambar_artikel?: StringFilter<"Artikel"> | string
    status_aktif?: BoolFilter<"Artikel"> | boolean
    id_kategori_artikel?: IntFilter<"Artikel"> | number
    id_pengguna?: StringFilter<"Artikel"> | string
  }

  export type ArtikelDisimpanUpsertWithWhereUniqueWithoutPenggunaInput = {
    where: ArtikelDisimpanWhereUniqueInput
    update: XOR<ArtikelDisimpanUpdateWithoutPenggunaInput, ArtikelDisimpanUncheckedUpdateWithoutPenggunaInput>
    create: XOR<ArtikelDisimpanCreateWithoutPenggunaInput, ArtikelDisimpanUncheckedCreateWithoutPenggunaInput>
  }

  export type ArtikelDisimpanUpdateWithWhereUniqueWithoutPenggunaInput = {
    where: ArtikelDisimpanWhereUniqueInput
    data: XOR<ArtikelDisimpanUpdateWithoutPenggunaInput, ArtikelDisimpanUncheckedUpdateWithoutPenggunaInput>
  }

  export type ArtikelDisimpanUpdateManyWithWhereWithoutPenggunaInput = {
    where: ArtikelDisimpanScalarWhereInput
    data: XOR<ArtikelDisimpanUpdateManyMutationInput, ArtikelDisimpanUncheckedUpdateManyWithoutPenggunaInput>
  }

  export type ArtikelDisimpanScalarWhereInput = {
    AND?: ArtikelDisimpanScalarWhereInput | ArtikelDisimpanScalarWhereInput[]
    OR?: ArtikelDisimpanScalarWhereInput[]
    NOT?: ArtikelDisimpanScalarWhereInput | ArtikelDisimpanScalarWhereInput[]
    id_penyimpanan?: IntFilter<"ArtikelDisimpan"> | number
    id_artikel?: StringFilter<"ArtikelDisimpan"> | string
    id_pengguna?: StringFilter<"ArtikelDisimpan"> | string
  }

  export type ArtikelDisukaiUpsertWithWhereUniqueWithoutPenggunaInput = {
    where: ArtikelDisukaiWhereUniqueInput
    update: XOR<ArtikelDisukaiUpdateWithoutPenggunaInput, ArtikelDisukaiUncheckedUpdateWithoutPenggunaInput>
    create: XOR<ArtikelDisukaiCreateWithoutPenggunaInput, ArtikelDisukaiUncheckedCreateWithoutPenggunaInput>
  }

  export type ArtikelDisukaiUpdateWithWhereUniqueWithoutPenggunaInput = {
    where: ArtikelDisukaiWhereUniqueInput
    data: XOR<ArtikelDisukaiUpdateWithoutPenggunaInput, ArtikelDisukaiUncheckedUpdateWithoutPenggunaInput>
  }

  export type ArtikelDisukaiUpdateManyWithWhereWithoutPenggunaInput = {
    where: ArtikelDisukaiScalarWhereInput
    data: XOR<ArtikelDisukaiUpdateManyMutationInput, ArtikelDisukaiUncheckedUpdateManyWithoutPenggunaInput>
  }

  export type ArtikelDisukaiScalarWhereInput = {
    AND?: ArtikelDisukaiScalarWhereInput | ArtikelDisukaiScalarWhereInput[]
    OR?: ArtikelDisukaiScalarWhereInput[]
    NOT?: ArtikelDisukaiScalarWhereInput | ArtikelDisukaiScalarWhereInput[]
    id_disukai?: IntFilter<"ArtikelDisukai"> | number
    id_artikel?: StringFilter<"ArtikelDisukai"> | string
    id_pengguna?: StringFilter<"ArtikelDisukai"> | string
    rating?: IntFilter<"ArtikelDisukai"> | number
  }

  export type KomentarArtikelUpsertWithWhereUniqueWithoutPenggunaInput = {
    where: KomentarArtikelWhereUniqueInput
    update: XOR<KomentarArtikelUpdateWithoutPenggunaInput, KomentarArtikelUncheckedUpdateWithoutPenggunaInput>
    create: XOR<KomentarArtikelCreateWithoutPenggunaInput, KomentarArtikelUncheckedCreateWithoutPenggunaInput>
  }

  export type KomentarArtikelUpdateWithWhereUniqueWithoutPenggunaInput = {
    where: KomentarArtikelWhereUniqueInput
    data: XOR<KomentarArtikelUpdateWithoutPenggunaInput, KomentarArtikelUncheckedUpdateWithoutPenggunaInput>
  }

  export type KomentarArtikelUpdateManyWithWhereWithoutPenggunaInput = {
    where: KomentarArtikelScalarWhereInput
    data: XOR<KomentarArtikelUpdateManyMutationInput, KomentarArtikelUncheckedUpdateManyWithoutPenggunaInput>
  }

  export type KomentarArtikelScalarWhereInput = {
    AND?: KomentarArtikelScalarWhereInput | KomentarArtikelScalarWhereInput[]
    OR?: KomentarArtikelScalarWhereInput[]
    NOT?: KomentarArtikelScalarWhereInput | KomentarArtikelScalarWhereInput[]
    id_komentar?: IntFilter<"KomentarArtikel"> | number
    id_artikel?: StringFilter<"KomentarArtikel"> | string
    id_pengguna?: StringFilter<"KomentarArtikel"> | string
    komentar?: StringFilter<"KomentarArtikel"> | string
  }

  export type TanamanPenggunaUpsertWithWhereUniqueWithoutPenggunaInput = {
    where: TanamanPenggunaWhereUniqueInput
    update: XOR<TanamanPenggunaUpdateWithoutPenggunaInput, TanamanPenggunaUncheckedUpdateWithoutPenggunaInput>
    create: XOR<TanamanPenggunaCreateWithoutPenggunaInput, TanamanPenggunaUncheckedCreateWithoutPenggunaInput>
  }

  export type TanamanPenggunaUpdateWithWhereUniqueWithoutPenggunaInput = {
    where: TanamanPenggunaWhereUniqueInput
    data: XOR<TanamanPenggunaUpdateWithoutPenggunaInput, TanamanPenggunaUncheckedUpdateWithoutPenggunaInput>
  }

  export type TanamanPenggunaUpdateManyWithWhereWithoutPenggunaInput = {
    where: TanamanPenggunaScalarWhereInput
    data: XOR<TanamanPenggunaUpdateManyMutationInput, TanamanPenggunaUncheckedUpdateManyWithoutPenggunaInput>
  }

  export type TanamanPenggunaScalarWhereInput = {
    AND?: TanamanPenggunaScalarWhereInput | TanamanPenggunaScalarWhereInput[]
    OR?: TanamanPenggunaScalarWhereInput[]
    NOT?: TanamanPenggunaScalarWhereInput | TanamanPenggunaScalarWhereInput[]
    id_tanaman_pengguna?: StringFilter<"TanamanPengguna"> | string
    tanggal_penanaman?: DateTimeFilter<"TanamanPengguna"> | Date | string
    status_penanaman?: BoolFilter<"TanamanPengguna"> | boolean
    nama_tanaman?: StringFilter<"TanamanPengguna"> | string
    id_tanaman?: StringFilter<"TanamanPengguna"> | string
    id_pengguna?: StringFilter<"TanamanPengguna"> | string
  }

  export type KabupatenCreateWithoutFacilitatorsInput = {
    nama_kabupaten: string
    type: string
    provinsi: ProvinsiCreateNestedOneWithoutKabupatenInput
    workshop?: WorkshopCreateNestedManyWithoutKabupatenInput
  }

  export type KabupatenUncheckedCreateWithoutFacilitatorsInput = {
    id_kabupaten?: number
    nama_kabupaten: string
    type: string
    id_provinsi: number
    workshop?: WorkshopUncheckedCreateNestedManyWithoutKabupatenInput
  }

  export type KabupatenCreateOrConnectWithoutFacilitatorsInput = {
    where: KabupatenWhereUniqueInput
    create: XOR<KabupatenCreateWithoutFacilitatorsInput, KabupatenUncheckedCreateWithoutFacilitatorsInput>
  }

  export type WorkshopCreateWithoutFacilitatorInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    kabupaten: KabupatenCreateNestedOneWithoutWorkshopInput
    pendaftaran?: WorkshopTerdaftarCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutFacilitatorInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    id_kabupaten: number
    pendaftaran?: WorkshopTerdaftarUncheckedCreateNestedManyWithoutWorkshopInput
  }

  export type WorkshopCreateOrConnectWithoutFacilitatorInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutFacilitatorInput, WorkshopUncheckedCreateWithoutFacilitatorInput>
  }

  export type WorkshopCreateManyFacilitatorInputEnvelope = {
    data: WorkshopCreateManyFacilitatorInput | WorkshopCreateManyFacilitatorInput[]
    skipDuplicates?: boolean
  }

  export type KabupatenUpsertWithoutFacilitatorsInput = {
    update: XOR<KabupatenUpdateWithoutFacilitatorsInput, KabupatenUncheckedUpdateWithoutFacilitatorsInput>
    create: XOR<KabupatenCreateWithoutFacilitatorsInput, KabupatenUncheckedCreateWithoutFacilitatorsInput>
    where?: KabupatenWhereInput
  }

  export type KabupatenUpdateToOneWithWhereWithoutFacilitatorsInput = {
    where?: KabupatenWhereInput
    data: XOR<KabupatenUpdateWithoutFacilitatorsInput, KabupatenUncheckedUpdateWithoutFacilitatorsInput>
  }

  export type KabupatenUpdateWithoutFacilitatorsInput = {
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provinsi?: ProvinsiUpdateOneRequiredWithoutKabupatenNestedInput
    workshop?: WorkshopUpdateManyWithoutKabupatenNestedInput
  }

  export type KabupatenUncheckedUpdateWithoutFacilitatorsInput = {
    id_kabupaten?: IntFieldUpdateOperationsInput | number
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    id_provinsi?: IntFieldUpdateOperationsInput | number
    workshop?: WorkshopUncheckedUpdateManyWithoutKabupatenNestedInput
  }

  export type WorkshopUpsertWithWhereUniqueWithoutFacilitatorInput = {
    where: WorkshopWhereUniqueInput
    update: XOR<WorkshopUpdateWithoutFacilitatorInput, WorkshopUncheckedUpdateWithoutFacilitatorInput>
    create: XOR<WorkshopCreateWithoutFacilitatorInput, WorkshopUncheckedCreateWithoutFacilitatorInput>
  }

  export type WorkshopUpdateWithWhereUniqueWithoutFacilitatorInput = {
    where: WorkshopWhereUniqueInput
    data: XOR<WorkshopUpdateWithoutFacilitatorInput, WorkshopUncheckedUpdateWithoutFacilitatorInput>
  }

  export type WorkshopUpdateManyWithWhereWithoutFacilitatorInput = {
    where: WorkshopScalarWhereInput
    data: XOR<WorkshopUpdateManyMutationInput, WorkshopUncheckedUpdateManyWithoutFacilitatorInput>
  }

  export type KategoriArtikelCreateWithoutArtikelInput = {
    nama_kategori_artikel: string
  }

  export type KategoriArtikelUncheckedCreateWithoutArtikelInput = {
    id_kategori_artikel?: number
    nama_kategori_artikel: string
  }

  export type KategoriArtikelCreateOrConnectWithoutArtikelInput = {
    where: KategoriArtikelWhereUniqueInput
    create: XOR<KategoriArtikelCreateWithoutArtikelInput, KategoriArtikelUncheckedCreateWithoutArtikelInput>
  }

  export type PenggunaCreateWithoutArtikelInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaUncheckedCreateWithoutArtikelInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaCreateOrConnectWithoutArtikelInput = {
    where: PenggunaWhereUniqueInput
    create: XOR<PenggunaCreateWithoutArtikelInput, PenggunaUncheckedCreateWithoutArtikelInput>
  }

  export type ArtikelDisimpanCreateWithoutArtikelInput = {
    pengguna: PenggunaCreateNestedOneWithoutArtikel_disimpanInput
  }

  export type ArtikelDisimpanUncheckedCreateWithoutArtikelInput = {
    id_penyimpanan?: number
    id_pengguna: string
  }

  export type ArtikelDisimpanCreateOrConnectWithoutArtikelInput = {
    where: ArtikelDisimpanWhereUniqueInput
    create: XOR<ArtikelDisimpanCreateWithoutArtikelInput, ArtikelDisimpanUncheckedCreateWithoutArtikelInput>
  }

  export type ArtikelDisimpanCreateManyArtikelInputEnvelope = {
    data: ArtikelDisimpanCreateManyArtikelInput | ArtikelDisimpanCreateManyArtikelInput[]
    skipDuplicates?: boolean
  }

  export type ArtikelDisukaiCreateWithoutArtikelInput = {
    rating: number
    pengguna: PenggunaCreateNestedOneWithoutArtikel_disukaiInput
  }

  export type ArtikelDisukaiUncheckedCreateWithoutArtikelInput = {
    id_disukai?: number
    id_pengguna: string
    rating: number
  }

  export type ArtikelDisukaiCreateOrConnectWithoutArtikelInput = {
    where: ArtikelDisukaiWhereUniqueInput
    create: XOR<ArtikelDisukaiCreateWithoutArtikelInput, ArtikelDisukaiUncheckedCreateWithoutArtikelInput>
  }

  export type ArtikelDisukaiCreateManyArtikelInputEnvelope = {
    data: ArtikelDisukaiCreateManyArtikelInput | ArtikelDisukaiCreateManyArtikelInput[]
    skipDuplicates?: boolean
  }

  export type KomentarArtikelCreateWithoutArtikelInput = {
    komentar: string
    pengguna: PenggunaCreateNestedOneWithoutKomentar_artikelInput
  }

  export type KomentarArtikelUncheckedCreateWithoutArtikelInput = {
    id_komentar?: number
    id_pengguna: string
    komentar: string
  }

  export type KomentarArtikelCreateOrConnectWithoutArtikelInput = {
    where: KomentarArtikelWhereUniqueInput
    create: XOR<KomentarArtikelCreateWithoutArtikelInput, KomentarArtikelUncheckedCreateWithoutArtikelInput>
  }

  export type KomentarArtikelCreateManyArtikelInputEnvelope = {
    data: KomentarArtikelCreateManyArtikelInput | KomentarArtikelCreateManyArtikelInput[]
    skipDuplicates?: boolean
  }

  export type KategoriArtikelUpsertWithoutArtikelInput = {
    update: XOR<KategoriArtikelUpdateWithoutArtikelInput, KategoriArtikelUncheckedUpdateWithoutArtikelInput>
    create: XOR<KategoriArtikelCreateWithoutArtikelInput, KategoriArtikelUncheckedCreateWithoutArtikelInput>
    where?: KategoriArtikelWhereInput
  }

  export type KategoriArtikelUpdateToOneWithWhereWithoutArtikelInput = {
    where?: KategoriArtikelWhereInput
    data: XOR<KategoriArtikelUpdateWithoutArtikelInput, KategoriArtikelUncheckedUpdateWithoutArtikelInput>
  }

  export type KategoriArtikelUpdateWithoutArtikelInput = {
    nama_kategori_artikel?: StringFieldUpdateOperationsInput | string
  }

  export type KategoriArtikelUncheckedUpdateWithoutArtikelInput = {
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
    nama_kategori_artikel?: StringFieldUpdateOperationsInput | string
  }

  export type PenggunaUpsertWithoutArtikelInput = {
    update: XOR<PenggunaUpdateWithoutArtikelInput, PenggunaUncheckedUpdateWithoutArtikelInput>
    create: XOR<PenggunaCreateWithoutArtikelInput, PenggunaUncheckedCreateWithoutArtikelInput>
    where?: PenggunaWhereInput
  }

  export type PenggunaUpdateToOneWithWhereWithoutArtikelInput = {
    where?: PenggunaWhereInput
    data: XOR<PenggunaUpdateWithoutArtikelInput, PenggunaUncheckedUpdateWithoutArtikelInput>
  }

  export type PenggunaUpdateWithoutArtikelInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutPenggunaNestedInput
  }

  export type PenggunaUncheckedUpdateWithoutArtikelInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutPenggunaNestedInput
  }

  export type ArtikelDisimpanUpsertWithWhereUniqueWithoutArtikelInput = {
    where: ArtikelDisimpanWhereUniqueInput
    update: XOR<ArtikelDisimpanUpdateWithoutArtikelInput, ArtikelDisimpanUncheckedUpdateWithoutArtikelInput>
    create: XOR<ArtikelDisimpanCreateWithoutArtikelInput, ArtikelDisimpanUncheckedCreateWithoutArtikelInput>
  }

  export type ArtikelDisimpanUpdateWithWhereUniqueWithoutArtikelInput = {
    where: ArtikelDisimpanWhereUniqueInput
    data: XOR<ArtikelDisimpanUpdateWithoutArtikelInput, ArtikelDisimpanUncheckedUpdateWithoutArtikelInput>
  }

  export type ArtikelDisimpanUpdateManyWithWhereWithoutArtikelInput = {
    where: ArtikelDisimpanScalarWhereInput
    data: XOR<ArtikelDisimpanUpdateManyMutationInput, ArtikelDisimpanUncheckedUpdateManyWithoutArtikelInput>
  }

  export type ArtikelDisukaiUpsertWithWhereUniqueWithoutArtikelInput = {
    where: ArtikelDisukaiWhereUniqueInput
    update: XOR<ArtikelDisukaiUpdateWithoutArtikelInput, ArtikelDisukaiUncheckedUpdateWithoutArtikelInput>
    create: XOR<ArtikelDisukaiCreateWithoutArtikelInput, ArtikelDisukaiUncheckedCreateWithoutArtikelInput>
  }

  export type ArtikelDisukaiUpdateWithWhereUniqueWithoutArtikelInput = {
    where: ArtikelDisukaiWhereUniqueInput
    data: XOR<ArtikelDisukaiUpdateWithoutArtikelInput, ArtikelDisukaiUncheckedUpdateWithoutArtikelInput>
  }

  export type ArtikelDisukaiUpdateManyWithWhereWithoutArtikelInput = {
    where: ArtikelDisukaiScalarWhereInput
    data: XOR<ArtikelDisukaiUpdateManyMutationInput, ArtikelDisukaiUncheckedUpdateManyWithoutArtikelInput>
  }

  export type KomentarArtikelUpsertWithWhereUniqueWithoutArtikelInput = {
    where: KomentarArtikelWhereUniqueInput
    update: XOR<KomentarArtikelUpdateWithoutArtikelInput, KomentarArtikelUncheckedUpdateWithoutArtikelInput>
    create: XOR<KomentarArtikelCreateWithoutArtikelInput, KomentarArtikelUncheckedCreateWithoutArtikelInput>
  }

  export type KomentarArtikelUpdateWithWhereUniqueWithoutArtikelInput = {
    where: KomentarArtikelWhereUniqueInput
    data: XOR<KomentarArtikelUpdateWithoutArtikelInput, KomentarArtikelUncheckedUpdateWithoutArtikelInput>
  }

  export type KomentarArtikelUpdateManyWithWhereWithoutArtikelInput = {
    where: KomentarArtikelScalarWhereInput
    data: XOR<KomentarArtikelUpdateManyMutationInput, KomentarArtikelUncheckedUpdateManyWithoutArtikelInput>
  }

  export type ArtikelCreateWithoutKategoriInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    pengguna: PenggunaCreateNestedOneWithoutArtikelInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutArtikelInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelUncheckedCreateWithoutKategoriInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    id_pengguna: string
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutArtikelInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelCreateOrConnectWithoutKategoriInput = {
    where: ArtikelWhereUniqueInput
    create: XOR<ArtikelCreateWithoutKategoriInput, ArtikelUncheckedCreateWithoutKategoriInput>
  }

  export type ArtikelCreateManyKategoriInputEnvelope = {
    data: ArtikelCreateManyKategoriInput | ArtikelCreateManyKategoriInput[]
    skipDuplicates?: boolean
  }

  export type ArtikelUpsertWithWhereUniqueWithoutKategoriInput = {
    where: ArtikelWhereUniqueInput
    update: XOR<ArtikelUpdateWithoutKategoriInput, ArtikelUncheckedUpdateWithoutKategoriInput>
    create: XOR<ArtikelCreateWithoutKategoriInput, ArtikelUncheckedCreateWithoutKategoriInput>
  }

  export type ArtikelUpdateWithWhereUniqueWithoutKategoriInput = {
    where: ArtikelWhereUniqueInput
    data: XOR<ArtikelUpdateWithoutKategoriInput, ArtikelUncheckedUpdateWithoutKategoriInput>
  }

  export type ArtikelUpdateManyWithWhereWithoutKategoriInput = {
    where: ArtikelScalarWhereInput
    data: XOR<ArtikelUpdateManyMutationInput, ArtikelUncheckedUpdateManyWithoutKategoriInput>
  }

  export type ArtikelCreateWithoutArtikel_disimpanInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    kategori: KategoriArtikelCreateNestedOneWithoutArtikelInput
    pengguna: PenggunaCreateNestedOneWithoutArtikelInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelUncheckedCreateWithoutArtikel_disimpanInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    id_kategori_artikel: number
    id_pengguna: string
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelCreateOrConnectWithoutArtikel_disimpanInput = {
    where: ArtikelWhereUniqueInput
    create: XOR<ArtikelCreateWithoutArtikel_disimpanInput, ArtikelUncheckedCreateWithoutArtikel_disimpanInput>
  }

  export type PenggunaCreateWithoutArtikel_disimpanInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaUncheckedCreateWithoutArtikel_disimpanInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaCreateOrConnectWithoutArtikel_disimpanInput = {
    where: PenggunaWhereUniqueInput
    create: XOR<PenggunaCreateWithoutArtikel_disimpanInput, PenggunaUncheckedCreateWithoutArtikel_disimpanInput>
  }

  export type ArtikelUpsertWithoutArtikel_disimpanInput = {
    update: XOR<ArtikelUpdateWithoutArtikel_disimpanInput, ArtikelUncheckedUpdateWithoutArtikel_disimpanInput>
    create: XOR<ArtikelCreateWithoutArtikel_disimpanInput, ArtikelUncheckedCreateWithoutArtikel_disimpanInput>
    where?: ArtikelWhereInput
  }

  export type ArtikelUpdateToOneWithWhereWithoutArtikel_disimpanInput = {
    where?: ArtikelWhereInput
    data: XOR<ArtikelUpdateWithoutArtikel_disimpanInput, ArtikelUncheckedUpdateWithoutArtikel_disimpanInput>
  }

  export type ArtikelUpdateWithoutArtikel_disimpanInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    kategori?: KategoriArtikelUpdateOneRequiredWithoutArtikelNestedInput
    pengguna?: PenggunaUpdateOneRequiredWithoutArtikelNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutArtikelNestedInput
  }

  export type ArtikelUncheckedUpdateWithoutArtikel_disimpanInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutArtikelNestedInput
  }

  export type PenggunaUpsertWithoutArtikel_disimpanInput = {
    update: XOR<PenggunaUpdateWithoutArtikel_disimpanInput, PenggunaUncheckedUpdateWithoutArtikel_disimpanInput>
    create: XOR<PenggunaCreateWithoutArtikel_disimpanInput, PenggunaUncheckedCreateWithoutArtikel_disimpanInput>
    where?: PenggunaWhereInput
  }

  export type PenggunaUpdateToOneWithWhereWithoutArtikel_disimpanInput = {
    where?: PenggunaWhereInput
    data: XOR<PenggunaUpdateWithoutArtikel_disimpanInput, PenggunaUncheckedUpdateWithoutArtikel_disimpanInput>
  }

  export type PenggunaUpdateWithoutArtikel_disimpanInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutPenggunaNestedInput
  }

  export type PenggunaUncheckedUpdateWithoutArtikel_disimpanInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutPenggunaNestedInput
  }

  export type ArtikelCreateWithoutArtikel_disukaiInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    kategori: KategoriArtikelCreateNestedOneWithoutArtikelInput
    pengguna: PenggunaCreateNestedOneWithoutArtikelInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelUncheckedCreateWithoutArtikel_disukaiInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    id_kategori_artikel: number
    id_pengguna: string
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutArtikelInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelCreateOrConnectWithoutArtikel_disukaiInput = {
    where: ArtikelWhereUniqueInput
    create: XOR<ArtikelCreateWithoutArtikel_disukaiInput, ArtikelUncheckedCreateWithoutArtikel_disukaiInput>
  }

  export type PenggunaCreateWithoutArtikel_disukaiInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaUncheckedCreateWithoutArtikel_disukaiInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaCreateOrConnectWithoutArtikel_disukaiInput = {
    where: PenggunaWhereUniqueInput
    create: XOR<PenggunaCreateWithoutArtikel_disukaiInput, PenggunaUncheckedCreateWithoutArtikel_disukaiInput>
  }

  export type ArtikelUpsertWithoutArtikel_disukaiInput = {
    update: XOR<ArtikelUpdateWithoutArtikel_disukaiInput, ArtikelUncheckedUpdateWithoutArtikel_disukaiInput>
    create: XOR<ArtikelCreateWithoutArtikel_disukaiInput, ArtikelUncheckedCreateWithoutArtikel_disukaiInput>
    where?: ArtikelWhereInput
  }

  export type ArtikelUpdateToOneWithWhereWithoutArtikel_disukaiInput = {
    where?: ArtikelWhereInput
    data: XOR<ArtikelUpdateWithoutArtikel_disukaiInput, ArtikelUncheckedUpdateWithoutArtikel_disukaiInput>
  }

  export type ArtikelUpdateWithoutArtikel_disukaiInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    kategori?: KategoriArtikelUpdateOneRequiredWithoutArtikelNestedInput
    pengguna?: PenggunaUpdateOneRequiredWithoutArtikelNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutArtikelNestedInput
  }

  export type ArtikelUncheckedUpdateWithoutArtikel_disukaiInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutArtikelNestedInput
  }

  export type PenggunaUpsertWithoutArtikel_disukaiInput = {
    update: XOR<PenggunaUpdateWithoutArtikel_disukaiInput, PenggunaUncheckedUpdateWithoutArtikel_disukaiInput>
    create: XOR<PenggunaCreateWithoutArtikel_disukaiInput, PenggunaUncheckedCreateWithoutArtikel_disukaiInput>
    where?: PenggunaWhereInput
  }

  export type PenggunaUpdateToOneWithWhereWithoutArtikel_disukaiInput = {
    where?: PenggunaWhereInput
    data: XOR<PenggunaUpdateWithoutArtikel_disukaiInput, PenggunaUncheckedUpdateWithoutArtikel_disukaiInput>
  }

  export type PenggunaUpdateWithoutArtikel_disukaiInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutPenggunaNestedInput
  }

  export type PenggunaUncheckedUpdateWithoutArtikel_disukaiInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutPenggunaNestedInput
  }

  export type ArtikelCreateWithoutKomentar_artikelInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    kategori: KategoriArtikelCreateNestedOneWithoutArtikelInput
    pengguna: PenggunaCreateNestedOneWithoutArtikelInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutArtikelInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelUncheckedCreateWithoutKomentar_artikelInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    id_kategori_artikel: number
    id_pengguna: string
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutArtikelInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutArtikelInput
  }

  export type ArtikelCreateOrConnectWithoutKomentar_artikelInput = {
    where: ArtikelWhereUniqueInput
    create: XOR<ArtikelCreateWithoutKomentar_artikelInput, ArtikelUncheckedCreateWithoutKomentar_artikelInput>
  }

  export type PenggunaCreateWithoutKomentar_artikelInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaUncheckedCreateWithoutKomentar_artikelInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaCreateOrConnectWithoutKomentar_artikelInput = {
    where: PenggunaWhereUniqueInput
    create: XOR<PenggunaCreateWithoutKomentar_artikelInput, PenggunaUncheckedCreateWithoutKomentar_artikelInput>
  }

  export type ArtikelUpsertWithoutKomentar_artikelInput = {
    update: XOR<ArtikelUpdateWithoutKomentar_artikelInput, ArtikelUncheckedUpdateWithoutKomentar_artikelInput>
    create: XOR<ArtikelCreateWithoutKomentar_artikelInput, ArtikelUncheckedCreateWithoutKomentar_artikelInput>
    where?: ArtikelWhereInput
  }

  export type ArtikelUpdateToOneWithWhereWithoutKomentar_artikelInput = {
    where?: ArtikelWhereInput
    data: XOR<ArtikelUpdateWithoutKomentar_artikelInput, ArtikelUncheckedUpdateWithoutKomentar_artikelInput>
  }

  export type ArtikelUpdateWithoutKomentar_artikelInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    kategori?: KategoriArtikelUpdateOneRequiredWithoutArtikelNestedInput
    pengguna?: PenggunaUpdateOneRequiredWithoutArtikelNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutArtikelNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutArtikelNestedInput
  }

  export type ArtikelUncheckedUpdateWithoutKomentar_artikelInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutArtikelNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutArtikelNestedInput
  }

  export type PenggunaUpsertWithoutKomentar_artikelInput = {
    update: XOR<PenggunaUpdateWithoutKomentar_artikelInput, PenggunaUncheckedUpdateWithoutKomentar_artikelInput>
    create: XOR<PenggunaCreateWithoutKomentar_artikelInput, PenggunaUncheckedCreateWithoutKomentar_artikelInput>
    where?: PenggunaWhereInput
  }

  export type PenggunaUpdateToOneWithWhereWithoutKomentar_artikelInput = {
    where?: PenggunaWhereInput
    data: XOR<PenggunaUpdateWithoutKomentar_artikelInput, PenggunaUncheckedUpdateWithoutKomentar_artikelInput>
  }

  export type PenggunaUpdateWithoutKomentar_artikelInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutPenggunaNestedInput
  }

  export type PenggunaUncheckedUpdateWithoutKomentar_artikelInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutPenggunaNestedInput
  }

  export type FacilitatorCreateWithoutWorkshopsInput = {
    id_facilitator?: string
    nama_facilitator: string
    email_facilitator: string
    nomor_telepon_facilitator: string
    password_facilitator: string
    tanggal_pembuatan_akun: Date | string
    alamat_lengkap_facilitator: string
    avatar?: string | null
    status_aktif?: boolean
    kabupaten: KabupatenCreateNestedOneWithoutFacilitatorsInput
  }

  export type FacilitatorUncheckedCreateWithoutWorkshopsInput = {
    id_facilitator?: string
    nama_facilitator: string
    email_facilitator: string
    nomor_telepon_facilitator: string
    password_facilitator: string
    tanggal_pembuatan_akun: Date | string
    alamat_lengkap_facilitator: string
    avatar?: string | null
    status_aktif?: boolean
    id_kabupaten: number
  }

  export type FacilitatorCreateOrConnectWithoutWorkshopsInput = {
    where: FacilitatorWhereUniqueInput
    create: XOR<FacilitatorCreateWithoutWorkshopsInput, FacilitatorUncheckedCreateWithoutWorkshopsInput>
  }

  export type KabupatenCreateWithoutWorkshopInput = {
    nama_kabupaten: string
    type: string
    provinsi: ProvinsiCreateNestedOneWithoutKabupatenInput
    facilitators?: FacilitatorCreateNestedManyWithoutKabupatenInput
  }

  export type KabupatenUncheckedCreateWithoutWorkshopInput = {
    id_kabupaten?: number
    nama_kabupaten: string
    type: string
    id_provinsi: number
    facilitators?: FacilitatorUncheckedCreateNestedManyWithoutKabupatenInput
  }

  export type KabupatenCreateOrConnectWithoutWorkshopInput = {
    where: KabupatenWhereUniqueInput
    create: XOR<KabupatenCreateWithoutWorkshopInput, KabupatenUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopTerdaftarCreateWithoutWorkshopInput = {
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran?: Date | string
    status_pembayaran: string
    nomor_tiket?: string | null
    pengguna: PenggunaCreateNestedOneWithoutWorkshop_terdaftarInput
  }

  export type WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput = {
    id_pendaftaran?: number
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran?: Date | string
    status_pembayaran: string
    nomor_tiket?: string | null
    id_pengguna: string
  }

  export type WorkshopTerdaftarCreateOrConnectWithoutWorkshopInput = {
    where: WorkshopTerdaftarWhereUniqueInput
    create: XOR<WorkshopTerdaftarCreateWithoutWorkshopInput, WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopTerdaftarCreateManyWorkshopInputEnvelope = {
    data: WorkshopTerdaftarCreateManyWorkshopInput | WorkshopTerdaftarCreateManyWorkshopInput[]
    skipDuplicates?: boolean
  }

  export type FacilitatorUpsertWithoutWorkshopsInput = {
    update: XOR<FacilitatorUpdateWithoutWorkshopsInput, FacilitatorUncheckedUpdateWithoutWorkshopsInput>
    create: XOR<FacilitatorCreateWithoutWorkshopsInput, FacilitatorUncheckedCreateWithoutWorkshopsInput>
    where?: FacilitatorWhereInput
  }

  export type FacilitatorUpdateToOneWithWhereWithoutWorkshopsInput = {
    where?: FacilitatorWhereInput
    data: XOR<FacilitatorUpdateWithoutWorkshopsInput, FacilitatorUncheckedUpdateWithoutWorkshopsInput>
  }

  export type FacilitatorUpdateWithoutWorkshopsInput = {
    id_facilitator?: StringFieldUpdateOperationsInput | string
    nama_facilitator?: StringFieldUpdateOperationsInput | string
    email_facilitator?: StringFieldUpdateOperationsInput | string
    nomor_telepon_facilitator?: StringFieldUpdateOperationsInput | string
    password_facilitator?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    alamat_lengkap_facilitator?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    kabupaten?: KabupatenUpdateOneRequiredWithoutFacilitatorsNestedInput
  }

  export type FacilitatorUncheckedUpdateWithoutWorkshopsInput = {
    id_facilitator?: StringFieldUpdateOperationsInput | string
    nama_facilitator?: StringFieldUpdateOperationsInput | string
    email_facilitator?: StringFieldUpdateOperationsInput | string
    nomor_telepon_facilitator?: StringFieldUpdateOperationsInput | string
    password_facilitator?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    alamat_lengkap_facilitator?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kabupaten?: IntFieldUpdateOperationsInput | number
  }

  export type KabupatenUpsertWithoutWorkshopInput = {
    update: XOR<KabupatenUpdateWithoutWorkshopInput, KabupatenUncheckedUpdateWithoutWorkshopInput>
    create: XOR<KabupatenCreateWithoutWorkshopInput, KabupatenUncheckedCreateWithoutWorkshopInput>
    where?: KabupatenWhereInput
  }

  export type KabupatenUpdateToOneWithWhereWithoutWorkshopInput = {
    where?: KabupatenWhereInput
    data: XOR<KabupatenUpdateWithoutWorkshopInput, KabupatenUncheckedUpdateWithoutWorkshopInput>
  }

  export type KabupatenUpdateWithoutWorkshopInput = {
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provinsi?: ProvinsiUpdateOneRequiredWithoutKabupatenNestedInput
    facilitators?: FacilitatorUpdateManyWithoutKabupatenNestedInput
  }

  export type KabupatenUncheckedUpdateWithoutWorkshopInput = {
    id_kabupaten?: IntFieldUpdateOperationsInput | number
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    id_provinsi?: IntFieldUpdateOperationsInput | number
    facilitators?: FacilitatorUncheckedUpdateManyWithoutKabupatenNestedInput
  }

  export type WorkshopTerdaftarUpsertWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopTerdaftarWhereUniqueInput
    update: XOR<WorkshopTerdaftarUpdateWithoutWorkshopInput, WorkshopTerdaftarUncheckedUpdateWithoutWorkshopInput>
    create: XOR<WorkshopTerdaftarCreateWithoutWorkshopInput, WorkshopTerdaftarUncheckedCreateWithoutWorkshopInput>
  }

  export type WorkshopTerdaftarUpdateWithWhereUniqueWithoutWorkshopInput = {
    where: WorkshopTerdaftarWhereUniqueInput
    data: XOR<WorkshopTerdaftarUpdateWithoutWorkshopInput, WorkshopTerdaftarUncheckedUpdateWithoutWorkshopInput>
  }

  export type WorkshopTerdaftarUpdateManyWithWhereWithoutWorkshopInput = {
    where: WorkshopTerdaftarScalarWhereInput
    data: XOR<WorkshopTerdaftarUpdateManyMutationInput, WorkshopTerdaftarUncheckedUpdateManyWithoutWorkshopInput>
  }

  export type PenggunaCreateWithoutWorkshop_terdaftarInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    artikel?: ArtikelCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaUncheckedCreateWithoutWorkshop_terdaftarInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    artikel?: ArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaCreateOrConnectWithoutWorkshop_terdaftarInput = {
    where: PenggunaWhereUniqueInput
    create: XOR<PenggunaCreateWithoutWorkshop_terdaftarInput, PenggunaUncheckedCreateWithoutWorkshop_terdaftarInput>
  }

  export type WorkshopCreateWithoutPendaftaranInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    facilitator: FacilitatorCreateNestedOneWithoutWorkshopsInput
    kabupaten: KabupatenCreateNestedOneWithoutWorkshopInput
  }

  export type WorkshopUncheckedCreateWithoutPendaftaranInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    id_facilitator: string
    id_kabupaten: number
  }

  export type WorkshopCreateOrConnectWithoutPendaftaranInput = {
    where: WorkshopWhereUniqueInput
    create: XOR<WorkshopCreateWithoutPendaftaranInput, WorkshopUncheckedCreateWithoutPendaftaranInput>
  }

  export type PenggunaUpsertWithoutWorkshop_terdaftarInput = {
    update: XOR<PenggunaUpdateWithoutWorkshop_terdaftarInput, PenggunaUncheckedUpdateWithoutWorkshop_terdaftarInput>
    create: XOR<PenggunaCreateWithoutWorkshop_terdaftarInput, PenggunaUncheckedCreateWithoutWorkshop_terdaftarInput>
    where?: PenggunaWhereInput
  }

  export type PenggunaUpdateToOneWithWhereWithoutWorkshop_terdaftarInput = {
    where?: PenggunaWhereInput
    data: XOR<PenggunaUpdateWithoutWorkshop_terdaftarInput, PenggunaUncheckedUpdateWithoutWorkshop_terdaftarInput>
  }

  export type PenggunaUpdateWithoutWorkshop_terdaftarInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    artikel?: ArtikelUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutPenggunaNestedInput
  }

  export type PenggunaUncheckedUpdateWithoutWorkshop_terdaftarInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    artikel?: ArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutPenggunaNestedInput
  }

  export type WorkshopUpsertWithoutPendaftaranInput = {
    update: XOR<WorkshopUpdateWithoutPendaftaranInput, WorkshopUncheckedUpdateWithoutPendaftaranInput>
    create: XOR<WorkshopCreateWithoutPendaftaranInput, WorkshopUncheckedCreateWithoutPendaftaranInput>
    where?: WorkshopWhereInput
  }

  export type WorkshopUpdateToOneWithWhereWithoutPendaftaranInput = {
    where?: WorkshopWhereInput
    data: XOR<WorkshopUpdateWithoutPendaftaranInput, WorkshopUncheckedUpdateWithoutPendaftaranInput>
  }

  export type WorkshopUpdateWithoutPendaftaranInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    facilitator?: FacilitatorUpdateOneRequiredWithoutWorkshopsNestedInput
    kabupaten?: KabupatenUpdateOneRequiredWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutPendaftaranInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_facilitator?: StringFieldUpdateOperationsInput | string
    id_kabupaten?: IntFieldUpdateOperationsInput | number
  }

  export type TanamanCreateWithoutKategoriInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    instruksi_tanaman?: InstruksiTanamanCreateNestedManyWithoutTanamanInput
    hari_penanaman?: HariPenanamanCreateNestedManyWithoutTanamanInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutTanamanInput
  }

  export type TanamanUncheckedCreateWithoutKategoriInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    instruksi_tanaman?: InstruksiTanamanUncheckedCreateNestedManyWithoutTanamanInput
    hari_penanaman?: HariPenanamanUncheckedCreateNestedManyWithoutTanamanInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutTanamanInput
  }

  export type TanamanCreateOrConnectWithoutKategoriInput = {
    where: TanamanWhereUniqueInput
    create: XOR<TanamanCreateWithoutKategoriInput, TanamanUncheckedCreateWithoutKategoriInput>
  }

  export type TanamanCreateManyKategoriInputEnvelope = {
    data: TanamanCreateManyKategoriInput | TanamanCreateManyKategoriInput[]
    skipDuplicates?: boolean
  }

  export type TanamanUpsertWithWhereUniqueWithoutKategoriInput = {
    where: TanamanWhereUniqueInput
    update: XOR<TanamanUpdateWithoutKategoriInput, TanamanUncheckedUpdateWithoutKategoriInput>
    create: XOR<TanamanCreateWithoutKategoriInput, TanamanUncheckedCreateWithoutKategoriInput>
  }

  export type TanamanUpdateWithWhereUniqueWithoutKategoriInput = {
    where: TanamanWhereUniqueInput
    data: XOR<TanamanUpdateWithoutKategoriInput, TanamanUncheckedUpdateWithoutKategoriInput>
  }

  export type TanamanUpdateManyWithWhereWithoutKategoriInput = {
    where: TanamanScalarWhereInput
    data: XOR<TanamanUpdateManyMutationInput, TanamanUncheckedUpdateManyWithoutKategoriInput>
  }

  export type TanamanScalarWhereInput = {
    AND?: TanamanScalarWhereInput | TanamanScalarWhereInput[]
    OR?: TanamanScalarWhereInput[]
    NOT?: TanamanScalarWhereInput | TanamanScalarWhereInput[]
    id_tanaman?: StringFilter<"Tanaman"> | string
    nama_tanaman?: StringFilter<"Tanaman"> | string
    nama_latin?: StringFilter<"Tanaman"> | string
    durasi_penanaman?: IntFilter<"Tanaman"> | number
    deskripsi_tanaman?: StringFilter<"Tanaman"> | string
    id_kategori_tanaman?: IntFilter<"Tanaman"> | number
  }

  export type kategoriTanamanCreateWithoutTanamanInput = {
    nama_kategori_tanaman: string
  }

  export type kategoriTanamanUncheckedCreateWithoutTanamanInput = {
    id_kategori_tanaman?: number
    nama_kategori_tanaman: string
  }

  export type kategoriTanamanCreateOrConnectWithoutTanamanInput = {
    where: kategoriTanamanWhereUniqueInput
    create: XOR<kategoriTanamanCreateWithoutTanamanInput, kategoriTanamanUncheckedCreateWithoutTanamanInput>
  }

  export type InstruksiTanamanCreateWithoutTanamanInput = {
    instruksi: string
  }

  export type InstruksiTanamanUncheckedCreateWithoutTanamanInput = {
    id_instruksi?: number
    instruksi: string
  }

  export type InstruksiTanamanCreateOrConnectWithoutTanamanInput = {
    where: InstruksiTanamanWhereUniqueInput
    create: XOR<InstruksiTanamanCreateWithoutTanamanInput, InstruksiTanamanUncheckedCreateWithoutTanamanInput>
  }

  export type InstruksiTanamanCreateManyTanamanInputEnvelope = {
    data: InstruksiTanamanCreateManyTanamanInput | InstruksiTanamanCreateManyTanamanInput[]
    skipDuplicates?: boolean
  }

  export type HariPenanamanCreateWithoutTanamanInput = {
    jenis_tugas: number
    tugas_penanaman?: TugasPenanamanCreateNestedManyWithoutHari_penanamanInput
  }

  export type HariPenanamanUncheckedCreateWithoutTanamanInput = {
    id_hari_penanaman?: number
    jenis_tugas: number
    tugas_penanaman?: TugasPenanamanUncheckedCreateNestedManyWithoutHari_penanamanInput
  }

  export type HariPenanamanCreateOrConnectWithoutTanamanInput = {
    where: HariPenanamanWhereUniqueInput
    create: XOR<HariPenanamanCreateWithoutTanamanInput, HariPenanamanUncheckedCreateWithoutTanamanInput>
  }

  export type HariPenanamanCreateManyTanamanInputEnvelope = {
    data: HariPenanamanCreateManyTanamanInput | HariPenanamanCreateManyTanamanInput[]
    skipDuplicates?: boolean
  }

  export type TanamanPenggunaCreateWithoutTanamanInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    pengguna: PenggunaCreateNestedOneWithoutTanaman_penggunaInput
    hari_tanaman?: HariTanamanPenggunaCreateNestedManyWithoutTanaman_penggunaInput
  }

  export type TanamanPenggunaUncheckedCreateWithoutTanamanInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    id_pengguna: string
    hari_tanaman?: HariTanamanPenggunaUncheckedCreateNestedManyWithoutTanaman_penggunaInput
  }

  export type TanamanPenggunaCreateOrConnectWithoutTanamanInput = {
    where: TanamanPenggunaWhereUniqueInput
    create: XOR<TanamanPenggunaCreateWithoutTanamanInput, TanamanPenggunaUncheckedCreateWithoutTanamanInput>
  }

  export type TanamanPenggunaCreateManyTanamanInputEnvelope = {
    data: TanamanPenggunaCreateManyTanamanInput | TanamanPenggunaCreateManyTanamanInput[]
    skipDuplicates?: boolean
  }

  export type kategoriTanamanUpsertWithoutTanamanInput = {
    update: XOR<kategoriTanamanUpdateWithoutTanamanInput, kategoriTanamanUncheckedUpdateWithoutTanamanInput>
    create: XOR<kategoriTanamanCreateWithoutTanamanInput, kategoriTanamanUncheckedCreateWithoutTanamanInput>
    where?: kategoriTanamanWhereInput
  }

  export type kategoriTanamanUpdateToOneWithWhereWithoutTanamanInput = {
    where?: kategoriTanamanWhereInput
    data: XOR<kategoriTanamanUpdateWithoutTanamanInput, kategoriTanamanUncheckedUpdateWithoutTanamanInput>
  }

  export type kategoriTanamanUpdateWithoutTanamanInput = {
    nama_kategori_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type kategoriTanamanUncheckedUpdateWithoutTanamanInput = {
    id_kategori_tanaman?: IntFieldUpdateOperationsInput | number
    nama_kategori_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type InstruksiTanamanUpsertWithWhereUniqueWithoutTanamanInput = {
    where: InstruksiTanamanWhereUniqueInput
    update: XOR<InstruksiTanamanUpdateWithoutTanamanInput, InstruksiTanamanUncheckedUpdateWithoutTanamanInput>
    create: XOR<InstruksiTanamanCreateWithoutTanamanInput, InstruksiTanamanUncheckedCreateWithoutTanamanInput>
  }

  export type InstruksiTanamanUpdateWithWhereUniqueWithoutTanamanInput = {
    where: InstruksiTanamanWhereUniqueInput
    data: XOR<InstruksiTanamanUpdateWithoutTanamanInput, InstruksiTanamanUncheckedUpdateWithoutTanamanInput>
  }

  export type InstruksiTanamanUpdateManyWithWhereWithoutTanamanInput = {
    where: InstruksiTanamanScalarWhereInput
    data: XOR<InstruksiTanamanUpdateManyMutationInput, InstruksiTanamanUncheckedUpdateManyWithoutTanamanInput>
  }

  export type InstruksiTanamanScalarWhereInput = {
    AND?: InstruksiTanamanScalarWhereInput | InstruksiTanamanScalarWhereInput[]
    OR?: InstruksiTanamanScalarWhereInput[]
    NOT?: InstruksiTanamanScalarWhereInput | InstruksiTanamanScalarWhereInput[]
    id_instruksi?: IntFilter<"InstruksiTanaman"> | number
    instruksi?: StringFilter<"InstruksiTanaman"> | string
    id_tanaman?: StringFilter<"InstruksiTanaman"> | string
  }

  export type HariPenanamanUpsertWithWhereUniqueWithoutTanamanInput = {
    where: HariPenanamanWhereUniqueInput
    update: XOR<HariPenanamanUpdateWithoutTanamanInput, HariPenanamanUncheckedUpdateWithoutTanamanInput>
    create: XOR<HariPenanamanCreateWithoutTanamanInput, HariPenanamanUncheckedCreateWithoutTanamanInput>
  }

  export type HariPenanamanUpdateWithWhereUniqueWithoutTanamanInput = {
    where: HariPenanamanWhereUniqueInput
    data: XOR<HariPenanamanUpdateWithoutTanamanInput, HariPenanamanUncheckedUpdateWithoutTanamanInput>
  }

  export type HariPenanamanUpdateManyWithWhereWithoutTanamanInput = {
    where: HariPenanamanScalarWhereInput
    data: XOR<HariPenanamanUpdateManyMutationInput, HariPenanamanUncheckedUpdateManyWithoutTanamanInput>
  }

  export type HariPenanamanScalarWhereInput = {
    AND?: HariPenanamanScalarWhereInput | HariPenanamanScalarWhereInput[]
    OR?: HariPenanamanScalarWhereInput[]
    NOT?: HariPenanamanScalarWhereInput | HariPenanamanScalarWhereInput[]
    id_hari_penanaman?: IntFilter<"HariPenanaman"> | number
    jenis_tugas?: IntFilter<"HariPenanaman"> | number
    id_tanaman?: StringFilter<"HariPenanaman"> | string
  }

  export type TanamanPenggunaUpsertWithWhereUniqueWithoutTanamanInput = {
    where: TanamanPenggunaWhereUniqueInput
    update: XOR<TanamanPenggunaUpdateWithoutTanamanInput, TanamanPenggunaUncheckedUpdateWithoutTanamanInput>
    create: XOR<TanamanPenggunaCreateWithoutTanamanInput, TanamanPenggunaUncheckedCreateWithoutTanamanInput>
  }

  export type TanamanPenggunaUpdateWithWhereUniqueWithoutTanamanInput = {
    where: TanamanPenggunaWhereUniqueInput
    data: XOR<TanamanPenggunaUpdateWithoutTanamanInput, TanamanPenggunaUncheckedUpdateWithoutTanamanInput>
  }

  export type TanamanPenggunaUpdateManyWithWhereWithoutTanamanInput = {
    where: TanamanPenggunaScalarWhereInput
    data: XOR<TanamanPenggunaUpdateManyMutationInput, TanamanPenggunaUncheckedUpdateManyWithoutTanamanInput>
  }

  export type TanamanCreateWithoutInstruksi_tanamanInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    kategori: kategoriTanamanCreateNestedOneWithoutTanamanInput
    hari_penanaman?: HariPenanamanCreateNestedManyWithoutTanamanInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutTanamanInput
  }

  export type TanamanUncheckedCreateWithoutInstruksi_tanamanInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    id_kategori_tanaman: number
    hari_penanaman?: HariPenanamanUncheckedCreateNestedManyWithoutTanamanInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutTanamanInput
  }

  export type TanamanCreateOrConnectWithoutInstruksi_tanamanInput = {
    where: TanamanWhereUniqueInput
    create: XOR<TanamanCreateWithoutInstruksi_tanamanInput, TanamanUncheckedCreateWithoutInstruksi_tanamanInput>
  }

  export type TanamanUpsertWithoutInstruksi_tanamanInput = {
    update: XOR<TanamanUpdateWithoutInstruksi_tanamanInput, TanamanUncheckedUpdateWithoutInstruksi_tanamanInput>
    create: XOR<TanamanCreateWithoutInstruksi_tanamanInput, TanamanUncheckedCreateWithoutInstruksi_tanamanInput>
    where?: TanamanWhereInput
  }

  export type TanamanUpdateToOneWithWhereWithoutInstruksi_tanamanInput = {
    where?: TanamanWhereInput
    data: XOR<TanamanUpdateWithoutInstruksi_tanamanInput, TanamanUncheckedUpdateWithoutInstruksi_tanamanInput>
  }

  export type TanamanUpdateWithoutInstruksi_tanamanInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    kategori?: kategoriTanamanUpdateOneRequiredWithoutTanamanNestedInput
    hari_penanaman?: HariPenanamanUpdateManyWithoutTanamanNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutTanamanNestedInput
  }

  export type TanamanUncheckedUpdateWithoutInstruksi_tanamanInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    id_kategori_tanaman?: IntFieldUpdateOperationsInput | number
    hari_penanaman?: HariPenanamanUncheckedUpdateManyWithoutTanamanNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutTanamanNestedInput
  }

  export type TanamanCreateWithoutHari_penanamanInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    kategori: kategoriTanamanCreateNestedOneWithoutTanamanInput
    instruksi_tanaman?: InstruksiTanamanCreateNestedManyWithoutTanamanInput
    tanaman_pengguna?: TanamanPenggunaCreateNestedManyWithoutTanamanInput
  }

  export type TanamanUncheckedCreateWithoutHari_penanamanInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    id_kategori_tanaman: number
    instruksi_tanaman?: InstruksiTanamanUncheckedCreateNestedManyWithoutTanamanInput
    tanaman_pengguna?: TanamanPenggunaUncheckedCreateNestedManyWithoutTanamanInput
  }

  export type TanamanCreateOrConnectWithoutHari_penanamanInput = {
    where: TanamanWhereUniqueInput
    create: XOR<TanamanCreateWithoutHari_penanamanInput, TanamanUncheckedCreateWithoutHari_penanamanInput>
  }

  export type TugasPenanamanCreateWithoutHari_penanamanInput = {
    nama_tugas: string
  }

  export type TugasPenanamanUncheckedCreateWithoutHari_penanamanInput = {
    id_tugas?: number
    nama_tugas: string
  }

  export type TugasPenanamanCreateOrConnectWithoutHari_penanamanInput = {
    where: TugasPenanamanWhereUniqueInput
    create: XOR<TugasPenanamanCreateWithoutHari_penanamanInput, TugasPenanamanUncheckedCreateWithoutHari_penanamanInput>
  }

  export type TugasPenanamanCreateManyHari_penanamanInputEnvelope = {
    data: TugasPenanamanCreateManyHari_penanamanInput | TugasPenanamanCreateManyHari_penanamanInput[]
    skipDuplicates?: boolean
  }

  export type TanamanUpsertWithoutHari_penanamanInput = {
    update: XOR<TanamanUpdateWithoutHari_penanamanInput, TanamanUncheckedUpdateWithoutHari_penanamanInput>
    create: XOR<TanamanCreateWithoutHari_penanamanInput, TanamanUncheckedCreateWithoutHari_penanamanInput>
    where?: TanamanWhereInput
  }

  export type TanamanUpdateToOneWithWhereWithoutHari_penanamanInput = {
    where?: TanamanWhereInput
    data: XOR<TanamanUpdateWithoutHari_penanamanInput, TanamanUncheckedUpdateWithoutHari_penanamanInput>
  }

  export type TanamanUpdateWithoutHari_penanamanInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    kategori?: kategoriTanamanUpdateOneRequiredWithoutTanamanNestedInput
    instruksi_tanaman?: InstruksiTanamanUpdateManyWithoutTanamanNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutTanamanNestedInput
  }

  export type TanamanUncheckedUpdateWithoutHari_penanamanInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    id_kategori_tanaman?: IntFieldUpdateOperationsInput | number
    instruksi_tanaman?: InstruksiTanamanUncheckedUpdateManyWithoutTanamanNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutTanamanNestedInput
  }

  export type TugasPenanamanUpsertWithWhereUniqueWithoutHari_penanamanInput = {
    where: TugasPenanamanWhereUniqueInput
    update: XOR<TugasPenanamanUpdateWithoutHari_penanamanInput, TugasPenanamanUncheckedUpdateWithoutHari_penanamanInput>
    create: XOR<TugasPenanamanCreateWithoutHari_penanamanInput, TugasPenanamanUncheckedCreateWithoutHari_penanamanInput>
  }

  export type TugasPenanamanUpdateWithWhereUniqueWithoutHari_penanamanInput = {
    where: TugasPenanamanWhereUniqueInput
    data: XOR<TugasPenanamanUpdateWithoutHari_penanamanInput, TugasPenanamanUncheckedUpdateWithoutHari_penanamanInput>
  }

  export type TugasPenanamanUpdateManyWithWhereWithoutHari_penanamanInput = {
    where: TugasPenanamanScalarWhereInput
    data: XOR<TugasPenanamanUpdateManyMutationInput, TugasPenanamanUncheckedUpdateManyWithoutHari_penanamanInput>
  }

  export type TugasPenanamanScalarWhereInput = {
    AND?: TugasPenanamanScalarWhereInput | TugasPenanamanScalarWhereInput[]
    OR?: TugasPenanamanScalarWhereInput[]
    NOT?: TugasPenanamanScalarWhereInput | TugasPenanamanScalarWhereInput[]
    id_tugas?: IntFilter<"TugasPenanaman"> | number
    nama_tugas?: StringFilter<"TugasPenanaman"> | string
    id_hari_penanaman?: IntFilter<"TugasPenanaman"> | number
  }

  export type HariPenanamanCreateWithoutTugas_penanamanInput = {
    jenis_tugas: number
    tanaman: TanamanCreateNestedOneWithoutHari_penanamanInput
  }

  export type HariPenanamanUncheckedCreateWithoutTugas_penanamanInput = {
    id_hari_penanaman?: number
    jenis_tugas: number
    id_tanaman: string
  }

  export type HariPenanamanCreateOrConnectWithoutTugas_penanamanInput = {
    where: HariPenanamanWhereUniqueInput
    create: XOR<HariPenanamanCreateWithoutTugas_penanamanInput, HariPenanamanUncheckedCreateWithoutTugas_penanamanInput>
  }

  export type HariPenanamanUpsertWithoutTugas_penanamanInput = {
    update: XOR<HariPenanamanUpdateWithoutTugas_penanamanInput, HariPenanamanUncheckedUpdateWithoutTugas_penanamanInput>
    create: XOR<HariPenanamanCreateWithoutTugas_penanamanInput, HariPenanamanUncheckedCreateWithoutTugas_penanamanInput>
    where?: HariPenanamanWhereInput
  }

  export type HariPenanamanUpdateToOneWithWhereWithoutTugas_penanamanInput = {
    where?: HariPenanamanWhereInput
    data: XOR<HariPenanamanUpdateWithoutTugas_penanamanInput, HariPenanamanUncheckedUpdateWithoutTugas_penanamanInput>
  }

  export type HariPenanamanUpdateWithoutTugas_penanamanInput = {
    jenis_tugas?: IntFieldUpdateOperationsInput | number
    tanaman?: TanamanUpdateOneRequiredWithoutHari_penanamanNestedInput
  }

  export type HariPenanamanUncheckedUpdateWithoutTugas_penanamanInput = {
    id_hari_penanaman?: IntFieldUpdateOperationsInput | number
    jenis_tugas?: IntFieldUpdateOperationsInput | number
    id_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type TanamanCreateWithoutTanaman_penggunaInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    kategori: kategoriTanamanCreateNestedOneWithoutTanamanInput
    instruksi_tanaman?: InstruksiTanamanCreateNestedManyWithoutTanamanInput
    hari_penanaman?: HariPenanamanCreateNestedManyWithoutTanamanInput
  }

  export type TanamanUncheckedCreateWithoutTanaman_penggunaInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
    id_kategori_tanaman: number
    instruksi_tanaman?: InstruksiTanamanUncheckedCreateNestedManyWithoutTanamanInput
    hari_penanaman?: HariPenanamanUncheckedCreateNestedManyWithoutTanamanInput
  }

  export type TanamanCreateOrConnectWithoutTanaman_penggunaInput = {
    where: TanamanWhereUniqueInput
    create: XOR<TanamanCreateWithoutTanaman_penggunaInput, TanamanUncheckedCreateWithoutTanaman_penggunaInput>
  }

  export type PenggunaCreateWithoutTanaman_penggunaInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaUncheckedCreateWithoutTanaman_penggunaInput = {
    id_pengguna?: string
    nama_depan_pengguna: string
    nama_belakang_pengguna: string
    tanggal_lahir_pengguna: Date | string
    email_pengguna: string
    nomor_telepon_pengguna: string
    jenisKelamin: number
    password_pengguna: string
    tanggal_pembuatan_akun: Date | string
    kode_verifikasi: string
    status_verfikasi: boolean
    avatar?: string | null
    status_aktif?: boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedCreateNestedManyWithoutPenggunaInput
    artikel?: ArtikelUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disimpan?: ArtikelDisimpanUncheckedCreateNestedManyWithoutPenggunaInput
    artikel_disukai?: ArtikelDisukaiUncheckedCreateNestedManyWithoutPenggunaInput
    komentar_artikel?: KomentarArtikelUncheckedCreateNestedManyWithoutPenggunaInput
  }

  export type PenggunaCreateOrConnectWithoutTanaman_penggunaInput = {
    where: PenggunaWhereUniqueInput
    create: XOR<PenggunaCreateWithoutTanaman_penggunaInput, PenggunaUncheckedCreateWithoutTanaman_penggunaInput>
  }

  export type HariTanamanPenggunaCreateWithoutTanaman_penggunaInput = {
    catatan: string
    tugas_penanaman?: TugasPenanamanPenggunaCreateNestedManyWithoutHari_tanamanInput
  }

  export type HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput = {
    id_hari_tanaman_pengguna?: number
    catatan: string
    tugas_penanaman?: TugasPenanamanPenggunaUncheckedCreateNestedManyWithoutHari_tanamanInput
  }

  export type HariTanamanPenggunaCreateOrConnectWithoutTanaman_penggunaInput = {
    where: HariTanamanPenggunaWhereUniqueInput
    create: XOR<HariTanamanPenggunaCreateWithoutTanaman_penggunaInput, HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput>
  }

  export type HariTanamanPenggunaCreateManyTanaman_penggunaInputEnvelope = {
    data: HariTanamanPenggunaCreateManyTanaman_penggunaInput | HariTanamanPenggunaCreateManyTanaman_penggunaInput[]
    skipDuplicates?: boolean
  }

  export type TanamanUpsertWithoutTanaman_penggunaInput = {
    update: XOR<TanamanUpdateWithoutTanaman_penggunaInput, TanamanUncheckedUpdateWithoutTanaman_penggunaInput>
    create: XOR<TanamanCreateWithoutTanaman_penggunaInput, TanamanUncheckedCreateWithoutTanaman_penggunaInput>
    where?: TanamanWhereInput
  }

  export type TanamanUpdateToOneWithWhereWithoutTanaman_penggunaInput = {
    where?: TanamanWhereInput
    data: XOR<TanamanUpdateWithoutTanaman_penggunaInput, TanamanUncheckedUpdateWithoutTanaman_penggunaInput>
  }

  export type TanamanUpdateWithoutTanaman_penggunaInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    kategori?: kategoriTanamanUpdateOneRequiredWithoutTanamanNestedInput
    instruksi_tanaman?: InstruksiTanamanUpdateManyWithoutTanamanNestedInput
    hari_penanaman?: HariPenanamanUpdateManyWithoutTanamanNestedInput
  }

  export type TanamanUncheckedUpdateWithoutTanaman_penggunaInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    id_kategori_tanaman?: IntFieldUpdateOperationsInput | number
    instruksi_tanaman?: InstruksiTanamanUncheckedUpdateManyWithoutTanamanNestedInput
    hari_penanaman?: HariPenanamanUncheckedUpdateManyWithoutTanamanNestedInput
  }

  export type PenggunaUpsertWithoutTanaman_penggunaInput = {
    update: XOR<PenggunaUpdateWithoutTanaman_penggunaInput, PenggunaUncheckedUpdateWithoutTanaman_penggunaInput>
    create: XOR<PenggunaCreateWithoutTanaman_penggunaInput, PenggunaUncheckedCreateWithoutTanaman_penggunaInput>
    where?: PenggunaWhereInput
  }

  export type PenggunaUpdateToOneWithWhereWithoutTanaman_penggunaInput = {
    where?: PenggunaWhereInput
    data: XOR<PenggunaUpdateWithoutTanaman_penggunaInput, PenggunaUncheckedUpdateWithoutTanaman_penggunaInput>
  }

  export type PenggunaUpdateWithoutTanaman_penggunaInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutPenggunaNestedInput
  }

  export type PenggunaUncheckedUpdateWithoutTanaman_penggunaInput = {
    id_pengguna?: StringFieldUpdateOperationsInput | string
    nama_depan_pengguna?: StringFieldUpdateOperationsInput | string
    nama_belakang_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_lahir_pengguna?: DateTimeFieldUpdateOperationsInput | Date | string
    email_pengguna?: StringFieldUpdateOperationsInput | string
    nomor_telepon_pengguna?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: IntFieldUpdateOperationsInput | number
    password_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    kode_verifikasi?: StringFieldUpdateOperationsInput | string
    status_verfikasi?: BoolFieldUpdateOperationsInput | boolean
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshop_terdaftar?: WorkshopTerdaftarUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel?: ArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutPenggunaNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutPenggunaNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutPenggunaNestedInput
  }

  export type HariTanamanPenggunaUpsertWithWhereUniqueWithoutTanaman_penggunaInput = {
    where: HariTanamanPenggunaWhereUniqueInput
    update: XOR<HariTanamanPenggunaUpdateWithoutTanaman_penggunaInput, HariTanamanPenggunaUncheckedUpdateWithoutTanaman_penggunaInput>
    create: XOR<HariTanamanPenggunaCreateWithoutTanaman_penggunaInput, HariTanamanPenggunaUncheckedCreateWithoutTanaman_penggunaInput>
  }

  export type HariTanamanPenggunaUpdateWithWhereUniqueWithoutTanaman_penggunaInput = {
    where: HariTanamanPenggunaWhereUniqueInput
    data: XOR<HariTanamanPenggunaUpdateWithoutTanaman_penggunaInput, HariTanamanPenggunaUncheckedUpdateWithoutTanaman_penggunaInput>
  }

  export type HariTanamanPenggunaUpdateManyWithWhereWithoutTanaman_penggunaInput = {
    where: HariTanamanPenggunaScalarWhereInput
    data: XOR<HariTanamanPenggunaUpdateManyMutationInput, HariTanamanPenggunaUncheckedUpdateManyWithoutTanaman_penggunaInput>
  }

  export type HariTanamanPenggunaScalarWhereInput = {
    AND?: HariTanamanPenggunaScalarWhereInput | HariTanamanPenggunaScalarWhereInput[]
    OR?: HariTanamanPenggunaScalarWhereInput[]
    NOT?: HariTanamanPenggunaScalarWhereInput | HariTanamanPenggunaScalarWhereInput[]
    id_hari_tanaman_pengguna?: IntFilter<"HariTanamanPengguna"> | number
    catatan?: StringFilter<"HariTanamanPengguna"> | string
    id_tanaman_pengguna?: StringFilter<"HariTanamanPengguna"> | string
  }

  export type TugasPenanamanPenggunaCreateWithoutHari_tanamanInput = {
    nama_tugas: string
  }

  export type TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput = {
    id_tugas_penanaman_pengguna?: number
    nama_tugas: string
  }

  export type TugasPenanamanPenggunaCreateOrConnectWithoutHari_tanamanInput = {
    where: TugasPenanamanPenggunaWhereUniqueInput
    create: XOR<TugasPenanamanPenggunaCreateWithoutHari_tanamanInput, TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput>
  }

  export type TugasPenanamanPenggunaCreateManyHari_tanamanInputEnvelope = {
    data: TugasPenanamanPenggunaCreateManyHari_tanamanInput | TugasPenanamanPenggunaCreateManyHari_tanamanInput[]
    skipDuplicates?: boolean
  }

  export type TanamanPenggunaCreateWithoutHari_tanamanInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    tanaman: TanamanCreateNestedOneWithoutTanaman_penggunaInput
    pengguna: PenggunaCreateNestedOneWithoutTanaman_penggunaInput
  }

  export type TanamanPenggunaUncheckedCreateWithoutHari_tanamanInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    id_tanaman: string
    id_pengguna: string
  }

  export type TanamanPenggunaCreateOrConnectWithoutHari_tanamanInput = {
    where: TanamanPenggunaWhereUniqueInput
    create: XOR<TanamanPenggunaCreateWithoutHari_tanamanInput, TanamanPenggunaUncheckedCreateWithoutHari_tanamanInput>
  }

  export type TugasPenanamanPenggunaUpsertWithWhereUniqueWithoutHari_tanamanInput = {
    where: TugasPenanamanPenggunaWhereUniqueInput
    update: XOR<TugasPenanamanPenggunaUpdateWithoutHari_tanamanInput, TugasPenanamanPenggunaUncheckedUpdateWithoutHari_tanamanInput>
    create: XOR<TugasPenanamanPenggunaCreateWithoutHari_tanamanInput, TugasPenanamanPenggunaUncheckedCreateWithoutHari_tanamanInput>
  }

  export type TugasPenanamanPenggunaUpdateWithWhereUniqueWithoutHari_tanamanInput = {
    where: TugasPenanamanPenggunaWhereUniqueInput
    data: XOR<TugasPenanamanPenggunaUpdateWithoutHari_tanamanInput, TugasPenanamanPenggunaUncheckedUpdateWithoutHari_tanamanInput>
  }

  export type TugasPenanamanPenggunaUpdateManyWithWhereWithoutHari_tanamanInput = {
    where: TugasPenanamanPenggunaScalarWhereInput
    data: XOR<TugasPenanamanPenggunaUpdateManyMutationInput, TugasPenanamanPenggunaUncheckedUpdateManyWithoutHari_tanamanInput>
  }

  export type TugasPenanamanPenggunaScalarWhereInput = {
    AND?: TugasPenanamanPenggunaScalarWhereInput | TugasPenanamanPenggunaScalarWhereInput[]
    OR?: TugasPenanamanPenggunaScalarWhereInput[]
    NOT?: TugasPenanamanPenggunaScalarWhereInput | TugasPenanamanPenggunaScalarWhereInput[]
    id_tugas_penanaman_pengguna?: IntFilter<"TugasPenanamanPengguna"> | number
    nama_tugas?: StringFilter<"TugasPenanamanPengguna"> | string
    id_hari_tanaman_pengguna?: IntFilter<"TugasPenanamanPengguna"> | number
  }

  export type TanamanPenggunaUpsertWithoutHari_tanamanInput = {
    update: XOR<TanamanPenggunaUpdateWithoutHari_tanamanInput, TanamanPenggunaUncheckedUpdateWithoutHari_tanamanInput>
    create: XOR<TanamanPenggunaCreateWithoutHari_tanamanInput, TanamanPenggunaUncheckedCreateWithoutHari_tanamanInput>
    where?: TanamanPenggunaWhereInput
  }

  export type TanamanPenggunaUpdateToOneWithWhereWithoutHari_tanamanInput = {
    where?: TanamanPenggunaWhereInput
    data: XOR<TanamanPenggunaUpdateWithoutHari_tanamanInput, TanamanPenggunaUncheckedUpdateWithoutHari_tanamanInput>
  }

  export type TanamanPenggunaUpdateWithoutHari_tanamanInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    tanaman?: TanamanUpdateOneRequiredWithoutTanaman_penggunaNestedInput
    pengguna?: PenggunaUpdateOneRequiredWithoutTanaman_penggunaNestedInput
  }

  export type TanamanPenggunaUncheckedUpdateWithoutHari_tanamanInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    id_tanaman?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type HariTanamanPenggunaCreateWithoutTugas_penanamanInput = {
    catatan: string
    tanaman_pengguna: TanamanPenggunaCreateNestedOneWithoutHari_tanamanInput
  }

  export type HariTanamanPenggunaUncheckedCreateWithoutTugas_penanamanInput = {
    id_hari_tanaman_pengguna?: number
    catatan: string
    id_tanaman_pengguna: string
  }

  export type HariTanamanPenggunaCreateOrConnectWithoutTugas_penanamanInput = {
    where: HariTanamanPenggunaWhereUniqueInput
    create: XOR<HariTanamanPenggunaCreateWithoutTugas_penanamanInput, HariTanamanPenggunaUncheckedCreateWithoutTugas_penanamanInput>
  }

  export type HariTanamanPenggunaUpsertWithoutTugas_penanamanInput = {
    update: XOR<HariTanamanPenggunaUpdateWithoutTugas_penanamanInput, HariTanamanPenggunaUncheckedUpdateWithoutTugas_penanamanInput>
    create: XOR<HariTanamanPenggunaCreateWithoutTugas_penanamanInput, HariTanamanPenggunaUncheckedCreateWithoutTugas_penanamanInput>
    where?: HariTanamanPenggunaWhereInput
  }

  export type HariTanamanPenggunaUpdateToOneWithWhereWithoutTugas_penanamanInput = {
    where?: HariTanamanPenggunaWhereInput
    data: XOR<HariTanamanPenggunaUpdateWithoutTugas_penanamanInput, HariTanamanPenggunaUncheckedUpdateWithoutTugas_penanamanInput>
  }

  export type HariTanamanPenggunaUpdateWithoutTugas_penanamanInput = {
    catatan?: StringFieldUpdateOperationsInput | string
    tanaman_pengguna?: TanamanPenggunaUpdateOneRequiredWithoutHari_tanamanNestedInput
  }

  export type HariTanamanPenggunaUncheckedUpdateWithoutTugas_penanamanInput = {
    id_hari_tanaman_pengguna?: IntFieldUpdateOperationsInput | number
    catatan?: StringFieldUpdateOperationsInput | string
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type KabupatenCreateManyProvinsiInput = {
    id_kabupaten?: number
    nama_kabupaten: string
    type: string
  }

  export type KabupatenUpdateWithoutProvinsiInput = {
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    facilitators?: FacilitatorUpdateManyWithoutKabupatenNestedInput
    workshop?: WorkshopUpdateManyWithoutKabupatenNestedInput
  }

  export type KabupatenUncheckedUpdateWithoutProvinsiInput = {
    id_kabupaten?: IntFieldUpdateOperationsInput | number
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    facilitators?: FacilitatorUncheckedUpdateManyWithoutKabupatenNestedInput
    workshop?: WorkshopUncheckedUpdateManyWithoutKabupatenNestedInput
  }

  export type KabupatenUncheckedUpdateManyWithoutProvinsiInput = {
    id_kabupaten?: IntFieldUpdateOperationsInput | number
    nama_kabupaten?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type FacilitatorCreateManyKabupatenInput = {
    id_facilitator?: string
    nama_facilitator: string
    email_facilitator: string
    nomor_telepon_facilitator: string
    password_facilitator: string
    tanggal_pembuatan_akun: Date | string
    alamat_lengkap_facilitator: string
    avatar?: string | null
    status_aktif?: boolean
  }

  export type WorkshopCreateManyKabupatenInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    id_facilitator: string
  }

  export type FacilitatorUpdateWithoutKabupatenInput = {
    id_facilitator?: StringFieldUpdateOperationsInput | string
    nama_facilitator?: StringFieldUpdateOperationsInput | string
    email_facilitator?: StringFieldUpdateOperationsInput | string
    nomor_telepon_facilitator?: StringFieldUpdateOperationsInput | string
    password_facilitator?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    alamat_lengkap_facilitator?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshops?: WorkshopUpdateManyWithoutFacilitatorNestedInput
  }

  export type FacilitatorUncheckedUpdateWithoutKabupatenInput = {
    id_facilitator?: StringFieldUpdateOperationsInput | string
    nama_facilitator?: StringFieldUpdateOperationsInput | string
    email_facilitator?: StringFieldUpdateOperationsInput | string
    nomor_telepon_facilitator?: StringFieldUpdateOperationsInput | string
    password_facilitator?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    alamat_lengkap_facilitator?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    workshops?: WorkshopUncheckedUpdateManyWithoutFacilitatorNestedInput
  }

  export type FacilitatorUncheckedUpdateManyWithoutKabupatenInput = {
    id_facilitator?: StringFieldUpdateOperationsInput | string
    nama_facilitator?: StringFieldUpdateOperationsInput | string
    email_facilitator?: StringFieldUpdateOperationsInput | string
    nomor_telepon_facilitator?: StringFieldUpdateOperationsInput | string
    password_facilitator?: StringFieldUpdateOperationsInput | string
    tanggal_pembuatan_akun?: DateTimeFieldUpdateOperationsInput | Date | string
    alamat_lengkap_facilitator?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkshopUpdateWithoutKabupatenInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    facilitator?: FacilitatorUpdateOneRequiredWithoutWorkshopsNestedInput
    pendaftaran?: WorkshopTerdaftarUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutKabupatenInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_facilitator?: StringFieldUpdateOperationsInput | string
    pendaftaran?: WorkshopTerdaftarUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateManyWithoutKabupatenInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_facilitator?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTerdaftarCreateManyPenggunaInput = {
    id_pendaftaran?: number
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran?: Date | string
    status_pembayaran: string
    nomor_tiket?: string | null
    id_workshop: string
  }

  export type ArtikelCreateManyPenggunaInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    id_kategori_artikel: number
  }

  export type ArtikelDisimpanCreateManyPenggunaInput = {
    id_penyimpanan?: number
    id_artikel: string
  }

  export type ArtikelDisukaiCreateManyPenggunaInput = {
    id_disukai?: number
    id_artikel: string
    rating: number
  }

  export type KomentarArtikelCreateManyPenggunaInput = {
    id_komentar?: number
    id_artikel: string
    komentar: string
  }

  export type TanamanPenggunaCreateManyPenggunaInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    id_tanaman: string
  }

  export type WorkshopTerdaftarUpdateWithoutPenggunaInput = {
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
    workshop?: WorkshopUpdateOneRequiredWithoutPendaftaranNestedInput
  }

  export type WorkshopTerdaftarUncheckedUpdateWithoutPenggunaInput = {
    id_pendaftaran?: IntFieldUpdateOperationsInput | number
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
    id_workshop?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTerdaftarUncheckedUpdateManyWithoutPenggunaInput = {
    id_pendaftaran?: IntFieldUpdateOperationsInput | number
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
    id_workshop?: StringFieldUpdateOperationsInput | string
  }

  export type ArtikelUpdateWithoutPenggunaInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    kategori?: KategoriArtikelUpdateOneRequiredWithoutArtikelNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutArtikelNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutArtikelNestedInput
  }

  export type ArtikelUncheckedUpdateWithoutPenggunaInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutArtikelNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutArtikelNestedInput
  }

  export type ArtikelUncheckedUpdateManyWithoutPenggunaInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kategori_artikel?: IntFieldUpdateOperationsInput | number
  }

  export type ArtikelDisimpanUpdateWithoutPenggunaInput = {
    artikel?: ArtikelUpdateOneRequiredWithoutArtikel_disimpanNestedInput
  }

  export type ArtikelDisimpanUncheckedUpdateWithoutPenggunaInput = {
    id_penyimpanan?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
  }

  export type ArtikelDisimpanUncheckedUpdateManyWithoutPenggunaInput = {
    id_penyimpanan?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
  }

  export type ArtikelDisukaiUpdateWithoutPenggunaInput = {
    rating?: IntFieldUpdateOperationsInput | number
    artikel?: ArtikelUpdateOneRequiredWithoutArtikel_disukaiNestedInput
  }

  export type ArtikelDisukaiUncheckedUpdateWithoutPenggunaInput = {
    id_disukai?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type ArtikelDisukaiUncheckedUpdateManyWithoutPenggunaInput = {
    id_disukai?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type KomentarArtikelUpdateWithoutPenggunaInput = {
    komentar?: StringFieldUpdateOperationsInput | string
    artikel?: ArtikelUpdateOneRequiredWithoutKomentar_artikelNestedInput
  }

  export type KomentarArtikelUncheckedUpdateWithoutPenggunaInput = {
    id_komentar?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    komentar?: StringFieldUpdateOperationsInput | string
  }

  export type KomentarArtikelUncheckedUpdateManyWithoutPenggunaInput = {
    id_komentar?: IntFieldUpdateOperationsInput | number
    id_artikel?: StringFieldUpdateOperationsInput | string
    komentar?: StringFieldUpdateOperationsInput | string
  }

  export type TanamanPenggunaUpdateWithoutPenggunaInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    tanaman?: TanamanUpdateOneRequiredWithoutTanaman_penggunaNestedInput
    hari_tanaman?: HariTanamanPenggunaUpdateManyWithoutTanaman_penggunaNestedInput
  }

  export type TanamanPenggunaUncheckedUpdateWithoutPenggunaInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    id_tanaman?: StringFieldUpdateOperationsInput | string
    hari_tanaman?: HariTanamanPenggunaUncheckedUpdateManyWithoutTanaman_penggunaNestedInput
  }

  export type TanamanPenggunaUncheckedUpdateManyWithoutPenggunaInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    id_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopCreateManyFacilitatorInput = {
    id_workshop: string
    judul_workshop: string
    tanggal_workshop: Date | string
    alaamt_lengkap_workshop: string
    deskripsi_workshop: string
    harga_workshop: Decimal | DecimalJsLike | number | string
    kapasitas: number
    status_verifikasi?: boolean
    lat_lokasi: number
    long_lokasi: number
    gambar_workshop: string
    status_aktif?: boolean
    id_kabupaten: number
  }

  export type WorkshopUpdateWithoutFacilitatorInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    kabupaten?: KabupatenUpdateOneRequiredWithoutWorkshopNestedInput
    pendaftaran?: WorkshopTerdaftarUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateWithoutFacilitatorInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kabupaten?: IntFieldUpdateOperationsInput | number
    pendaftaran?: WorkshopTerdaftarUncheckedUpdateManyWithoutWorkshopNestedInput
  }

  export type WorkshopUncheckedUpdateManyWithoutFacilitatorInput = {
    id_workshop?: StringFieldUpdateOperationsInput | string
    judul_workshop?: StringFieldUpdateOperationsInput | string
    tanggal_workshop?: DateTimeFieldUpdateOperationsInput | Date | string
    alaamt_lengkap_workshop?: StringFieldUpdateOperationsInput | string
    deskripsi_workshop?: StringFieldUpdateOperationsInput | string
    harga_workshop?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    kapasitas?: IntFieldUpdateOperationsInput | number
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    lat_lokasi?: FloatFieldUpdateOperationsInput | number
    long_lokasi?: FloatFieldUpdateOperationsInput | number
    gambar_workshop?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_kabupaten?: IntFieldUpdateOperationsInput | number
  }

  export type ArtikelDisimpanCreateManyArtikelInput = {
    id_penyimpanan?: number
    id_pengguna: string
  }

  export type ArtikelDisukaiCreateManyArtikelInput = {
    id_disukai?: number
    id_pengguna: string
    rating: number
  }

  export type KomentarArtikelCreateManyArtikelInput = {
    id_komentar?: number
    id_pengguna: string
    komentar: string
  }

  export type ArtikelDisimpanUpdateWithoutArtikelInput = {
    pengguna?: PenggunaUpdateOneRequiredWithoutArtikel_disimpanNestedInput
  }

  export type ArtikelDisimpanUncheckedUpdateWithoutArtikelInput = {
    id_penyimpanan?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type ArtikelDisimpanUncheckedUpdateManyWithoutArtikelInput = {
    id_penyimpanan?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type ArtikelDisukaiUpdateWithoutArtikelInput = {
    rating?: IntFieldUpdateOperationsInput | number
    pengguna?: PenggunaUpdateOneRequiredWithoutArtikel_disukaiNestedInput
  }

  export type ArtikelDisukaiUncheckedUpdateWithoutArtikelInput = {
    id_disukai?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type ArtikelDisukaiUncheckedUpdateManyWithoutArtikelInput = {
    id_disukai?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
  }

  export type KomentarArtikelUpdateWithoutArtikelInput = {
    komentar?: StringFieldUpdateOperationsInput | string
    pengguna?: PenggunaUpdateOneRequiredWithoutKomentar_artikelNestedInput
  }

  export type KomentarArtikelUncheckedUpdateWithoutArtikelInput = {
    id_komentar?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
    komentar?: StringFieldUpdateOperationsInput | string
  }

  export type KomentarArtikelUncheckedUpdateManyWithoutArtikelInput = {
    id_komentar?: IntFieldUpdateOperationsInput | number
    id_pengguna?: StringFieldUpdateOperationsInput | string
    komentar?: StringFieldUpdateOperationsInput | string
  }

  export type ArtikelCreateManyKategoriInput = {
    id_artikel: string
    judul_artikel: string
    tanggal_artikel?: Date | string
    deskripsi_artikel: string
    isi_artikel: string
    status_artikel: $Enums.StatusArtikel
    status_verifikasi?: boolean
    gambar_artikel: string
    status_aktif?: boolean
    id_pengguna: string
  }

  export type ArtikelUpdateWithoutKategoriInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    pengguna?: PenggunaUpdateOneRequiredWithoutArtikelNestedInput
    artikel_disimpan?: ArtikelDisimpanUpdateManyWithoutArtikelNestedInput
    artikel_disukai?: ArtikelDisukaiUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUpdateManyWithoutArtikelNestedInput
  }

  export type ArtikelUncheckedUpdateWithoutKategoriInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_pengguna?: StringFieldUpdateOperationsInput | string
    artikel_disimpan?: ArtikelDisimpanUncheckedUpdateManyWithoutArtikelNestedInput
    artikel_disukai?: ArtikelDisukaiUncheckedUpdateManyWithoutArtikelNestedInput
    komentar_artikel?: KomentarArtikelUncheckedUpdateManyWithoutArtikelNestedInput
  }

  export type ArtikelUncheckedUpdateManyWithoutKategoriInput = {
    id_artikel?: StringFieldUpdateOperationsInput | string
    judul_artikel?: StringFieldUpdateOperationsInput | string
    tanggal_artikel?: DateTimeFieldUpdateOperationsInput | Date | string
    deskripsi_artikel?: StringFieldUpdateOperationsInput | string
    isi_artikel?: StringFieldUpdateOperationsInput | string
    status_artikel?: EnumStatusArtikelFieldUpdateOperationsInput | $Enums.StatusArtikel
    status_verifikasi?: BoolFieldUpdateOperationsInput | boolean
    gambar_artikel?: StringFieldUpdateOperationsInput | string
    status_aktif?: BoolFieldUpdateOperationsInput | boolean
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTerdaftarCreateManyWorkshopInput = {
    id_pendaftaran?: number
    nama_peserta: string
    email_peserta: string
    nomor_telepon_peserta: string
    tanggal_pendaftaran?: Date | string
    status_pembayaran: string
    nomor_tiket?: string | null
    id_pengguna: string
  }

  export type WorkshopTerdaftarUpdateWithoutWorkshopInput = {
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
    pengguna?: PenggunaUpdateOneRequiredWithoutWorkshop_terdaftarNestedInput
  }

  export type WorkshopTerdaftarUncheckedUpdateWithoutWorkshopInput = {
    id_pendaftaran?: IntFieldUpdateOperationsInput | number
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type WorkshopTerdaftarUncheckedUpdateManyWithoutWorkshopInput = {
    id_pendaftaran?: IntFieldUpdateOperationsInput | number
    nama_peserta?: StringFieldUpdateOperationsInput | string
    email_peserta?: StringFieldUpdateOperationsInput | string
    nomor_telepon_peserta?: StringFieldUpdateOperationsInput | string
    tanggal_pendaftaran?: DateTimeFieldUpdateOperationsInput | Date | string
    status_pembayaran?: StringFieldUpdateOperationsInput | string
    nomor_tiket?: NullableStringFieldUpdateOperationsInput | string | null
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type TanamanCreateManyKategoriInput = {
    id_tanaman: string
    nama_tanaman: string
    nama_latin: string
    durasi_penanaman: number
    deskripsi_tanaman: string
  }

  export type TanamanUpdateWithoutKategoriInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    instruksi_tanaman?: InstruksiTanamanUpdateManyWithoutTanamanNestedInput
    hari_penanaman?: HariPenanamanUpdateManyWithoutTanamanNestedInput
    tanaman_pengguna?: TanamanPenggunaUpdateManyWithoutTanamanNestedInput
  }

  export type TanamanUncheckedUpdateWithoutKategoriInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
    instruksi_tanaman?: InstruksiTanamanUncheckedUpdateManyWithoutTanamanNestedInput
    hari_penanaman?: HariPenanamanUncheckedUpdateManyWithoutTanamanNestedInput
    tanaman_pengguna?: TanamanPenggunaUncheckedUpdateManyWithoutTanamanNestedInput
  }

  export type TanamanUncheckedUpdateManyWithoutKategoriInput = {
    id_tanaman?: StringFieldUpdateOperationsInput | string
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    nama_latin?: StringFieldUpdateOperationsInput | string
    durasi_penanaman?: IntFieldUpdateOperationsInput | number
    deskripsi_tanaman?: StringFieldUpdateOperationsInput | string
  }

  export type InstruksiTanamanCreateManyTanamanInput = {
    id_instruksi?: number
    instruksi: string
  }

  export type HariPenanamanCreateManyTanamanInput = {
    id_hari_penanaman?: number
    jenis_tugas: number
  }

  export type TanamanPenggunaCreateManyTanamanInput = {
    id_tanaman_pengguna: string
    tanggal_penanaman: Date | string
    status_penanaman: boolean
    nama_tanaman: string
    id_pengguna: string
  }

  export type InstruksiTanamanUpdateWithoutTanamanInput = {
    instruksi?: StringFieldUpdateOperationsInput | string
  }

  export type InstruksiTanamanUncheckedUpdateWithoutTanamanInput = {
    id_instruksi?: IntFieldUpdateOperationsInput | number
    instruksi?: StringFieldUpdateOperationsInput | string
  }

  export type InstruksiTanamanUncheckedUpdateManyWithoutTanamanInput = {
    id_instruksi?: IntFieldUpdateOperationsInput | number
    instruksi?: StringFieldUpdateOperationsInput | string
  }

  export type HariPenanamanUpdateWithoutTanamanInput = {
    jenis_tugas?: IntFieldUpdateOperationsInput | number
    tugas_penanaman?: TugasPenanamanUpdateManyWithoutHari_penanamanNestedInput
  }

  export type HariPenanamanUncheckedUpdateWithoutTanamanInput = {
    id_hari_penanaman?: IntFieldUpdateOperationsInput | number
    jenis_tugas?: IntFieldUpdateOperationsInput | number
    tugas_penanaman?: TugasPenanamanUncheckedUpdateManyWithoutHari_penanamanNestedInput
  }

  export type HariPenanamanUncheckedUpdateManyWithoutTanamanInput = {
    id_hari_penanaman?: IntFieldUpdateOperationsInput | number
    jenis_tugas?: IntFieldUpdateOperationsInput | number
  }

  export type TanamanPenggunaUpdateWithoutTanamanInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    pengguna?: PenggunaUpdateOneRequiredWithoutTanaman_penggunaNestedInput
    hari_tanaman?: HariTanamanPenggunaUpdateManyWithoutTanaman_penggunaNestedInput
  }

  export type TanamanPenggunaUncheckedUpdateWithoutTanamanInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
    hari_tanaman?: HariTanamanPenggunaUncheckedUpdateManyWithoutTanaman_penggunaNestedInput
  }

  export type TanamanPenggunaUncheckedUpdateManyWithoutTanamanInput = {
    id_tanaman_pengguna?: StringFieldUpdateOperationsInput | string
    tanggal_penanaman?: DateTimeFieldUpdateOperationsInput | Date | string
    status_penanaman?: BoolFieldUpdateOperationsInput | boolean
    nama_tanaman?: StringFieldUpdateOperationsInput | string
    id_pengguna?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanCreateManyHari_penanamanInput = {
    id_tugas?: number
    nama_tugas: string
  }

  export type TugasPenanamanUpdateWithoutHari_penanamanInput = {
    nama_tugas?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanUncheckedUpdateWithoutHari_penanamanInput = {
    id_tugas?: IntFieldUpdateOperationsInput | number
    nama_tugas?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanUncheckedUpdateManyWithoutHari_penanamanInput = {
    id_tugas?: IntFieldUpdateOperationsInput | number
    nama_tugas?: StringFieldUpdateOperationsInput | string
  }

  export type HariTanamanPenggunaCreateManyTanaman_penggunaInput = {
    id_hari_tanaman_pengguna?: number
    catatan: string
  }

  export type HariTanamanPenggunaUpdateWithoutTanaman_penggunaInput = {
    catatan?: StringFieldUpdateOperationsInput | string
    tugas_penanaman?: TugasPenanamanPenggunaUpdateManyWithoutHari_tanamanNestedInput
  }

  export type HariTanamanPenggunaUncheckedUpdateWithoutTanaman_penggunaInput = {
    id_hari_tanaman_pengguna?: IntFieldUpdateOperationsInput | number
    catatan?: StringFieldUpdateOperationsInput | string
    tugas_penanaman?: TugasPenanamanPenggunaUncheckedUpdateManyWithoutHari_tanamanNestedInput
  }

  export type HariTanamanPenggunaUncheckedUpdateManyWithoutTanaman_penggunaInput = {
    id_hari_tanaman_pengguna?: IntFieldUpdateOperationsInput | number
    catatan?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanPenggunaCreateManyHari_tanamanInput = {
    id_tugas_penanaman_pengguna?: number
    nama_tugas: string
  }

  export type TugasPenanamanPenggunaUpdateWithoutHari_tanamanInput = {
    nama_tugas?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanPenggunaUncheckedUpdateWithoutHari_tanamanInput = {
    id_tugas_penanaman_pengguna?: IntFieldUpdateOperationsInput | number
    nama_tugas?: StringFieldUpdateOperationsInput | string
  }

  export type TugasPenanamanPenggunaUncheckedUpdateManyWithoutHari_tanamanInput = {
    id_tugas_penanaman_pengguna?: IntFieldUpdateOperationsInput | number
    nama_tugas?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}